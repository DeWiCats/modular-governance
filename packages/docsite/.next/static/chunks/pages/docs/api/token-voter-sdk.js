/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/docs/api/token-voter-sdk"],{

/***/ "../../node_modules/@markdoc/next.js/src/runtime.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@markdoc/next.js/src/runtime.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// IDEA: explore better displayName functions\nfunction displayName(name) {\n  // Pascal case\n  return name\n    .match(/[a-z]+/gi)\n    .map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase())\n    .join('');\n}\n\nfunction transformRecord(config) {\n  const output = {};\n  const components = {};\n\n  if (config) {\n    Object.entries(config).forEach(([name, registration]) => {\n      if (output[name]) {\n        throw new Error(`\"${name}\" has already been declared`);\n      }\n\n      const componentName = registration.render ? displayName(name) : undefined;\n\n      output[name] = {\n        ...registration,\n        render: componentName,\n      };\n\n      if (componentName) {\n        components[componentName] = registration.render;\n      }\n    });\n  }\n\n  return {output, components};\n}\n\nexports.getSchema = function getSchema(schema) {\n  const {output: tags, components: tagComponents} = transformRecord(\n    schema.tags\n  );\n\n  const {output: nodes, components: nodeComponents} = transformRecord(\n    schema.nodes\n  );\n\n  return {\n    ...schema,\n    tags,\n    nodes,\n    components: {\n      ...tagComponents,\n      ...nodeComponents,\n    },\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXJrZG9jL25leHQuanMvc3JjL3J1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLFVBQVU7QUFDVjs7QUFFQSxpQkFBaUI7QUFDakIsU0FBUyx5Q0FBeUM7QUFDbEQ7QUFDQTs7QUFFQSxTQUFTLDJDQUEyQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AbWFya2RvYy9uZXh0LmpzL3NyYy9ydW50aW1lLmpzPzA3YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSURFQTogZXhwbG9yZSBiZXR0ZXIgZGlzcGxheU5hbWUgZnVuY3Rpb25zXG5mdW5jdGlvbiBkaXNwbGF5TmFtZShuYW1lKSB7XG4gIC8vIFBhc2NhbCBjYXNlXG4gIHJldHVybiBuYW1lXG4gICAgLm1hdGNoKC9bYS16XSsvZ2kpXG4gICAgLm1hcCgod29yZCkgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpXG4gICAgLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZWNvcmQoY29uZmlnKSB7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBjb25zdCBjb21wb25lbnRzID0ge307XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykuZm9yRWFjaCgoW25hbWUsIHJlZ2lzdHJhdGlvbl0pID0+IHtcbiAgICAgIGlmIChvdXRwdXRbbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSByZWdpc3RyYXRpb24ucmVuZGVyID8gZGlzcGxheU5hbWUobmFtZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIG91dHB1dFtuYW1lXSA9IHtcbiAgICAgICAgLi4ucmVnaXN0cmF0aW9uLFxuICAgICAgICByZW5kZXI6IGNvbXBvbmVudE5hbWUsXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudE5hbWVdID0gcmVnaXN0cmF0aW9uLnJlbmRlcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7b3V0cHV0LCBjb21wb25lbnRzfTtcbn1cblxuZXhwb3J0cy5nZXRTY2hlbWEgPSBmdW5jdGlvbiBnZXRTY2hlbWEoc2NoZW1hKSB7XG4gIGNvbnN0IHtvdXRwdXQ6IHRhZ3MsIGNvbXBvbmVudHM6IHRhZ0NvbXBvbmVudHN9ID0gdHJhbnNmb3JtUmVjb3JkKFxuICAgIHNjaGVtYS50YWdzXG4gICk7XG5cbiAgY29uc3Qge291dHB1dDogbm9kZXMsIGNvbXBvbmVudHM6IG5vZGVDb21wb25lbnRzfSA9IHRyYW5zZm9ybVJlY29yZChcbiAgICBzY2hlbWEubm9kZXNcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICB0YWdzLFxuICAgIG5vZGVzLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgIC4uLnRhZ0NvbXBvbmVudHMsXG4gICAgICAuLi5ub2RlQ29tcG9uZW50cyxcbiAgICB9LFxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@markdoc/next.js/src/runtime.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fperonif5%2FMyWorkspace%2FHeliumWorkspace%2Fmodular-governance%2Fpackages%2Fdocsite%2Fsrc%2Fpages%2Fdocs%2Fapi%2Ftoken-voter-sdk.md&page=%2Fdocs%2Fapi%2Ftoken-voter-sdk!":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fperonif5%2FMyWorkspace%2FHeliumWorkspace%2Fmodular-governance%2Fpackages%2Fdocsite%2Fsrc%2Fpages%2Fdocs%2Fapi%2Ftoken-voter-sdk.md&page=%2Fdocs%2Fapi%2Ftoken-voter-sdk! ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/docs/api/token-voter-sdk\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/docs/api/token-voter-sdk.md */ \"./src/pages/docs/api/token-voter-sdk.md\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/docs/api/token-voter-sdk\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzP2Fic29sdXRlUGFnZVBhdGg9JTJGVXNlcnMlMkZwZXJvbmlmNSUyRk15V29ya3NwYWNlJTJGSGVsaXVtV29ya3NwYWNlJTJGbW9kdWxhci1nb3Zlcm5hbmNlJTJGcGFja2FnZXMlMkZkb2NzaXRlJTJGc3JjJTJGcGFnZXMlMkZkb2NzJTJGYXBpJTJGdG9rZW4tdm90ZXItc2RrLm1kJnBhZ2U9JTJGZG9jcyUyRmFwaSUyRnRva2VuLXZvdGVyLXNkayEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx3RkFBeUM7QUFDaEU7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzRjMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9kb2NzL2FwaS90b2tlbi12b3Rlci1zZGtcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3NyYy9wYWdlcy9kb2NzL2FwaS90b2tlbi12b3Rlci1zZGsubWRcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL2RvY3MvYXBpL3Rva2VuLXZvdGVyLXNka1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fperonif5%2FMyWorkspace%2FHeliumWorkspace%2Fmodular-governance%2Fpackages%2Fdocsite%2Fsrc%2Fpages%2Fdocs%2Fapi%2Ftoken-voter-sdk.md&page=%2Fdocs%2Fapi%2Ftoken-voter-sdk!\n"));

/***/ }),

/***/ "./src/components/Callout.jsx":
/*!************************************!*\
  !*** ./src/components/Callout.jsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Callout\": function() { return /* binding */ Callout; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ \"../../node_modules/clsx/dist/clsx.m.js\");\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\n\nconst styles = {\n    note: {\n        container: \"bg-emerald-800/5 ring-emerald-500/20\",\n        title: \"text-emerald-400\",\n        body: \"[--tw-prose-background:theme(colors.emerald.50)] prose-a:text-emerald-900 text-emerald-100 prose-code:text-emerald-300\"\n    },\n    warning: {\n        container: \"bg-amber-800/5 ring-amber-500/20\",\n        title: \"text-amber-900 dark:text-amber-500\",\n        body: \"text-amber-800 [--tw-prose-underline:theme(colors.amber.400)] [--tw-prose-background:theme(colors.amber.50)] prose-a:text-amber-900 prose-code:text-amber-900 dark:text-zinc-300 dark:[--tw-prose-underline:theme(colors.teal.700)] dark:prose-code:text-zinc-300\"\n    }\n};\nconst icons = {\n    note: (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, {\n            icon: \"lightbulb\",\n            ...props\n        }, void 0, false, {\n            fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n            lineNumber: 21,\n            columnNumber: 20\n        }, undefined),\n    warning: (props)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, {\n            icon: \"warning\",\n            color: \"amber\",\n            ...props\n        }, void 0, false, {\n            fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n            lineNumber: 22,\n            columnNumber: 23\n        }, undefined)\n};\nfunction Callout(param) {\n    let { type =\"note\" , title , children  } = param;\n    let IconComponent = icons[type];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"my-6 flex gap-2.5 rounded-2xl p-6 ring-1\", styles[type].container),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n                className: \"h-8 w-8 flex-none\"\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"ml-4 flex-auto\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"m-0 font-display text-xl\", styles[type].title),\n                        children: title\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\"prose mt-2.5\", styles[type].body),\n                        children: children\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n                        lineNumber: 34,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n                lineNumber: 30,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Callout.jsx\",\n        lineNumber: 28,\n        columnNumber: 5\n    }, this);\n}\n_c = Callout;\nvar _c;\n$RefreshReg$(_c, \"Callout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9DYWxsb3V0LmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUI7QUFFaUI7QUFFeEMsTUFBTUUsU0FBUztJQUNiQyxNQUFNO1FBQ0pDLFdBQ0U7UUFDRkMsT0FBTztRQUNQQyxNQUFNO0lBQ1I7SUFDQUMsU0FBUztRQUNQSCxXQUNFO1FBQ0ZDLE9BQU87UUFDUEMsTUFBTTtJQUNSO0FBQ0Y7QUFFQSxNQUFNRSxRQUFRO0lBQ1pMLE1BQU0sQ0FBQ00sc0JBQVUsOERBQUNSLGtEQUFJQTtZQUFDUyxNQUFLO1lBQWEsR0FBR0QsS0FBSzs7Ozs7O0lBQ2pERixTQUFTLENBQUNFLHNCQUFVLDhEQUFDUixrREFBSUE7WUFBQ1MsTUFBSztZQUFVQyxPQUFNO1lBQVMsR0FBR0YsS0FBSzs7Ozs7O0FBQ2xFO0FBRU8sU0FBU0csUUFBUSxLQUFrQyxFQUFFO1FBQXBDLEVBQUVDLE1BQU8sT0FBTSxFQUFFUixNQUFLLEVBQUVTLFNBQVEsRUFBRSxHQUFsQztJQUN0QixJQUFJQyxnQkFBZ0JQLEtBQUssQ0FBQ0ssS0FBSztJQUMvQixxQkFDRSw4REFBQ0c7UUFBSUMsV0FBV2pCLGdEQUFJQSxDQUFDLDRDQUE0Q0UsTUFBTSxDQUFDVyxLQUFLLENBQUNULFNBQVM7OzBCQUNyRiw4REFBQ1c7Z0JBQWNFLFdBQVU7Ozs7OzswQkFDekIsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0M7d0JBQUVELFdBQVdqQixnREFBSUEsQ0FBQyw0QkFBNEJFLE1BQU0sQ0FBQ1csS0FBSyxDQUFDUixLQUFLO2tDQUM5REE7Ozs7OztrQ0FFSCw4REFBQ1c7d0JBQUlDLFdBQVdqQixnREFBSUEsQ0FBQyxnQkFBZ0JFLE1BQU0sQ0FBQ1csS0FBSyxDQUFDUCxJQUFJO2tDQUNuRFE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtYLENBQUM7S0FmZUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvQ2FsbG91dC5qc3g/NmIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2xzeCBmcm9tICdjbHN4J1xuXG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnQC9jb21wb25lbnRzL0ljb24nXG5cbmNvbnN0IHN0eWxlcyA9IHtcbiAgbm90ZToge1xuICAgIGNvbnRhaW5lcjpcbiAgICAgICdiZy1lbWVyYWxkLTgwMC81IHJpbmctZW1lcmFsZC01MDAvMjAnLFxuICAgIHRpdGxlOiAndGV4dC1lbWVyYWxkLTQwMCcsXG4gICAgYm9keTogJ1stLXR3LXByb3NlLWJhY2tncm91bmQ6dGhlbWUoY29sb3JzLmVtZXJhbGQuNTApXSBwcm9zZS1hOnRleHQtZW1lcmFsZC05MDAgdGV4dC1lbWVyYWxkLTEwMCBwcm9zZS1jb2RlOnRleHQtZW1lcmFsZC0zMDAnLFxuICB9LFxuICB3YXJuaW5nOiB7XG4gICAgY29udGFpbmVyOlxuICAgICAgJ2JnLWFtYmVyLTgwMC81IHJpbmctYW1iZXItNTAwLzIwJyxcbiAgICB0aXRsZTogJ3RleHQtYW1iZXItOTAwIGRhcms6dGV4dC1hbWJlci01MDAnLFxuICAgIGJvZHk6ICd0ZXh0LWFtYmVyLTgwMCBbLS10dy1wcm9zZS11bmRlcmxpbmU6dGhlbWUoY29sb3JzLmFtYmVyLjQwMCldIFstLXR3LXByb3NlLWJhY2tncm91bmQ6dGhlbWUoY29sb3JzLmFtYmVyLjUwKV0gcHJvc2UtYTp0ZXh0LWFtYmVyLTkwMCBwcm9zZS1jb2RlOnRleHQtYW1iZXItOTAwIGRhcms6dGV4dC16aW5jLTMwMCBkYXJrOlstLXR3LXByb3NlLXVuZGVybGluZTp0aGVtZShjb2xvcnMudGVhbC43MDApXSBkYXJrOnByb3NlLWNvZGU6dGV4dC16aW5jLTMwMCcsXG4gIH0sXG59XG5cbmNvbnN0IGljb25zID0ge1xuICBub3RlOiAocHJvcHMpID0+IDxJY29uIGljb249XCJsaWdodGJ1bGJcIiB7Li4ucHJvcHN9IC8+LFxuICB3YXJuaW5nOiAocHJvcHMpID0+IDxJY29uIGljb249XCJ3YXJuaW5nXCIgY29sb3I9XCJhbWJlclwiIHsuLi5wcm9wc30gLz4sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYWxsb3V0KHsgdHlwZSA9ICdub3RlJywgdGl0bGUsIGNoaWxkcmVuIH0pIHtcbiAgbGV0IEljb25Db21wb25lbnQgPSBpY29uc1t0eXBlXVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjbHN4KCdteS02IGZsZXggZ2FwLTIuNSByb3VuZGVkLTJ4bCBwLTYgcmluZy0xJywgc3R5bGVzW3R5cGVdLmNvbnRhaW5lcil9PlxuICAgICAgPEljb25Db21wb25lbnQgY2xhc3NOYW1lPVwiaC04IHctOCBmbGV4LW5vbmVcIiAvPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtbC00IGZsZXgtYXV0b1wiPlxuICAgICAgICA8cCBjbGFzc05hbWU9e2Nsc3goJ20tMCBmb250LWRpc3BsYXkgdGV4dC14bCcsIHN0eWxlc1t0eXBlXS50aXRsZSl9PlxuICAgICAgICAgIHt0aXRsZX1cbiAgICAgICAgPC9wPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xzeCgncHJvc2UgbXQtMi41Jywgc3R5bGVzW3R5cGVdLmJvZHkpfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJjbHN4IiwiSWNvbiIsInN0eWxlcyIsIm5vdGUiLCJjb250YWluZXIiLCJ0aXRsZSIsImJvZHkiLCJ3YXJuaW5nIiwiaWNvbnMiLCJwcm9wcyIsImljb24iLCJjb2xvciIsIkNhbGxvdXQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJJY29uQ29tcG9uZW50IiwiZGl2IiwiY2xhc3NOYW1lIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Callout.jsx\n"));

/***/ }),

/***/ "./src/components/Fence.jsx":
/*!**********************************!*\
  !*** ./src/components/Fence.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fence\": function() { return /* binding */ Fence; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var prism_react_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prism-react-renderer */ \"../../node_modules/prism-react-renderer/dist/index.js\");\n\n\n\nfunction Fence(param) {\n    let { children , language  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(prism_react_renderer__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        ...prism_react_renderer__WEBPACK_IMPORTED_MODULE_2__.defaultProps,\n        code: children.trimEnd(),\n        language: language,\n        theme: undefined,\n        children: (param)=>/*#__PURE__*/ {\n            let { className , style , tokens , getTokenProps  } = param;\n            return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                className: \"bg-red-500\",\n                style: style,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"code\", {\n                    children: tokens.map((line, lineIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                            children: [\n                                line.filter((token)=>!token.empty).map((token, tokenIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        ...getTokenProps({\n                                            token\n                                        })\n                                    }, tokenIndex, false, {\n                                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Fence.jsx\",\n                                        lineNumber: 20,\n                                        columnNumber: 21\n                                    }, this)),\n                                \"\\n\"\n                            ]\n                        }, lineIndex, true, {\n                            fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Fence.jsx\",\n                            lineNumber: 16,\n                            columnNumber: 15\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Fence.jsx\",\n                    lineNumber: 14,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Fence.jsx\",\n                lineNumber: 13,\n                columnNumber: 9\n            }, this);\n        }\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Fence.jsx\",\n        lineNumber: 6,\n        columnNumber: 5\n    }, this);\n}\n_c = Fence;\nvar _c;\n$RefreshReg$(_c, \"Fence\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9GZW5jZS5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnQztBQUM4QjtBQUV2RCxTQUFTRyxNQUFNLEtBQXNCLEVBQUU7UUFBeEIsRUFBRUMsU0FBUSxFQUFFQyxTQUFRLEVBQUUsR0FBdEI7SUFDcEIscUJBQ0UsOERBQUNKLDREQUFTQTtRQUNQLEdBQUdDLDhEQUFZO1FBQ2hCSSxNQUFNRixTQUFTRyxPQUFPO1FBQ3RCRixVQUFVQTtRQUNWRyxPQUFPQztrQkFFTix1QkFDQztnQkFEQSxFQUFFQyxVQUFTLEVBQUVDLE1BQUssRUFBRUMsT0FBTSxFQUFFQyxjQUFhLEVBQUU7bUJBQzNDLDhEQUFDQztnQkFBSUosV0FBVztnQkFBY0MsT0FBT0E7MEJBQ25DLDRFQUFDTDs4QkFDRU0sT0FBT0csR0FBRyxDQUFDLENBQUNDLE1BQU1DLDBCQUNqQiw4REFBQ2pCLDJDQUFRQTs7Z0NBQ05nQixLQUNFRSxNQUFNLENBQUMsQ0FBQ0MsUUFBVSxDQUFDQSxNQUFNQyxLQUFLLEVBQzlCTCxHQUFHLENBQUMsQ0FBQ0ksT0FBT0UsMkJBQ1gsOERBQUNDO3dDQUF1QixHQUFHVCxjQUFjOzRDQUFFTTt3Q0FBTSxFQUFFO3VDQUF4Q0U7Ozs7O2dDQUVkOzsyQkFOWUo7Ozs7Ozs7Ozs7Ozs7OztRQVVoQjs7Ozs7O0FBSWIsQ0FBQztLQTFCZWQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvRmVuY2UuanN4Pzg0ODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBIaWdobGlnaHQsIHsgZGVmYXVsdFByb3BzIH0gZnJvbSAncHJpc20tcmVhY3QtcmVuZGVyZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBGZW5jZSh7IGNoaWxkcmVuLCBsYW5ndWFnZSB9KSB7XG4gIHJldHVybiAoXG4gICAgPEhpZ2hsaWdodFxuICAgICAgey4uLmRlZmF1bHRQcm9wc31cbiAgICAgIGNvZGU9e2NoaWxkcmVuLnRyaW1FbmQoKX1cbiAgICAgIGxhbmd1YWdlPXtsYW5ndWFnZX1cbiAgICAgIHRoZW1lPXt1bmRlZmluZWR9XG4gICAgPlxuICAgICAgeyh7IGNsYXNzTmFtZSwgc3R5bGUsIHRva2VucywgZ2V0VG9rZW5Qcm9wcyB9KSA9PiAoXG4gICAgICAgIDxwcmUgY2xhc3NOYW1lPXsnYmctcmVkLTUwMCd9IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgPGNvZGU+XG4gICAgICAgICAgICB7dG9rZW5zLm1hcCgobGluZSwgbGluZUluZGV4KSA9PiAoXG4gICAgICAgICAgICAgIDxGcmFnbWVudCBrZXk9e2xpbmVJbmRleH0+XG4gICAgICAgICAgICAgICAge2xpbmVcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRva2VuKSA9PiAhdG9rZW4uZW1wdHkpXG4gICAgICAgICAgICAgICAgICAubWFwKCh0b2tlbiwgdG9rZW5JbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBrZXk9e3Rva2VuSW5kZXh9IHsuLi5nZXRUb2tlblByb3BzKHsgdG9rZW4gfSl9IC8+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICB7J1xcbid9XG4gICAgICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2NvZGU+XG4gICAgICAgIDwvcHJlPlxuICAgICAgKX1cbiAgICA8L0hpZ2hsaWdodD5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkZyYWdtZW50IiwiSGlnaGxpZ2h0IiwiZGVmYXVsdFByb3BzIiwiRmVuY2UiLCJjaGlsZHJlbiIsImxhbmd1YWdlIiwiY29kZSIsInRyaW1FbmQiLCJ0aGVtZSIsInVuZGVmaW5lZCIsImNsYXNzTmFtZSIsInN0eWxlIiwidG9rZW5zIiwiZ2V0VG9rZW5Qcm9wcyIsInByZSIsIm1hcCIsImxpbmUiLCJsaW5lSW5kZXgiLCJmaWx0ZXIiLCJ0b2tlbiIsImVtcHR5IiwidG9rZW5JbmRleCIsInNwYW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Fence.jsx\n"));

/***/ }),

/***/ "./src/components/Icon.jsx":
/*!*********************************!*\
  !*** ./src/components/Icon.jsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DarkMode\": function() { return /* binding */ DarkMode; },\n/* harmony export */   \"Gradient\": function() { return /* binding */ Gradient; },\n/* harmony export */   \"Icon\": function() { return /* binding */ Icon; },\n/* harmony export */   \"LightMode\": function() { return /* binding */ LightMode; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"../../node_modules/clsx/dist/clsx.m.js\");\n/* harmony import */ var _components_icons_InstallationIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/icons/InstallationIcon */ \"./src/components/icons/InstallationIcon.jsx\");\n/* harmony import */ var _components_icons_LightbulbIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/icons/LightbulbIcon */ \"./src/components/icons/LightbulbIcon.jsx\");\n/* harmony import */ var _components_icons_PluginsIcon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/icons/PluginsIcon */ \"./src/components/icons/PluginsIcon.jsx\");\n/* harmony import */ var _components_icons_PresetsIcon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/icons/PresetsIcon */ \"./src/components/icons/PresetsIcon.jsx\");\n/* harmony import */ var _components_icons_WarningIcon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/components/icons/WarningIcon */ \"./src/components/icons/WarningIcon.jsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst icons = {\n    installation: _components_icons_InstallationIcon__WEBPACK_IMPORTED_MODULE_3__.InstallationIcon,\n    presets: _components_icons_PresetsIcon__WEBPACK_IMPORTED_MODULE_6__.PresetsIcon,\n    plugins: _components_icons_PluginsIcon__WEBPACK_IMPORTED_MODULE_5__.PluginsIcon,\n    lightbulb: _components_icons_LightbulbIcon__WEBPACK_IMPORTED_MODULE_4__.LightbulbIcon,\n    warning: _components_icons_WarningIcon__WEBPACK_IMPORTED_MODULE_7__.WarningIcon\n};\nconst iconStyles = {\n    blue: \"[--icon-foreground:theme(colors.zinc.900)] [--icon-background:theme(colors.white)]\",\n    amber: \"[--icon-foreground:theme(colors.amber.900)] [--icon-background:theme(colors.amber.100)]\"\n};\nfunction Icon(param) {\n    let { color =\"blue\" , icon , className , ...props } = param;\n    _s();\n    let id = (0,react__WEBPACK_IMPORTED_MODULE_1__.useId)();\n    let IconComponent = icons[icon];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n        \"aria-hidden\": \"true\",\n        viewBox: \"0 0 32 32\",\n        fill: \"none\",\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(className, iconStyles[color]),\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IconComponent, {\n            id: id,\n            color: color\n        }, void 0, false, {\n            fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n            lineNumber: 36,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, this);\n}\n_s(Icon, \"WhsuKpSQZEWeFcB7gWlfDRQktoQ=\", false, function() {\n    return [\n        react__WEBPACK_IMPORTED_MODULE_1__.useId\n    ];\n});\n_c = Icon;\nconst gradients = {\n    blue: [\n        {\n            stopColor: \"#0EA5E9\"\n        },\n        {\n            stopColor: \"#22D3EE\",\n            offset: \".527\"\n        },\n        {\n            stopColor: \"#818CF8\",\n            offset: 1\n        }\n    ],\n    amber: [\n        {\n            stopColor: \"#FDE68A\",\n            offset: \".08\"\n        },\n        {\n            stopColor: \"#F59E0B\",\n            offset: \".837\"\n        }\n    ]\n};\nfunction Gradient(param) {\n    let { color =\"blue\" , ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"radialGradient\", {\n        cx: 0,\n        cy: 0,\n        r: 1,\n        gradientUnits: \"userSpaceOnUse\",\n        ...props,\n        children: gradients[color].map((stop, stopIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"stop\", {\n                ...stop\n            }, stopIndex, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n                lineNumber: 63,\n                columnNumber: 9\n            }, this))\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n        lineNumber: 55,\n        columnNumber: 5\n    }, this);\n}\n_c1 = Gradient;\nfunction LightMode(param) {\n    let { className , ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"dark:hidden\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n        lineNumber: 70,\n        columnNumber: 10\n    }, this);\n}\n_c2 = LightMode;\nfunction DarkMode(param) {\n    let { className , ...props } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"g\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"hidden dark:inline\", className),\n        ...props\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/Icon.jsx\",\n        lineNumber: 74,\n        columnNumber: 10\n    }, this);\n}\n_c3 = DarkMode;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Icon\");\n$RefreshReg$(_c1, \"Gradient\");\n$RefreshReg$(_c2, \"LightMode\");\n$RefreshReg$(_c3, \"DarkMode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9JY29uLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ047QUFFK0M7QUFDTjtBQUNKO0FBQ0E7QUFDQTtBQUU1RCxNQUFNTyxRQUFRO0lBQ1pDLGNBQWNOLGdGQUFnQkE7SUFDOUJPLFNBQVNKLHNFQUFXQTtJQUNwQkssU0FBU04sc0VBQVdBO0lBQ3BCTyxXQUFXUiwwRUFBYUE7SUFDeEJTLFNBQVNOLHNFQUFXQTtBQUN0QjtBQUVBLE1BQU1PLGFBQWE7SUFDakJDLE1BQU07SUFDTkMsT0FDRTtBQUNKO0FBRU8sU0FBU0MsS0FBSyxLQUE2QyxFQUFFO1FBQS9DLEVBQUVDLE9BQVEsT0FBTSxFQUFFQyxLQUFJLEVBQUVDLFVBQVMsRUFBRSxHQUFHQyxPQUFPLEdBQTdDOztJQUNuQixJQUFJQyxLQUFLckIsNENBQUtBO0lBQ2QsSUFBSXNCLGdCQUFnQmYsS0FBSyxDQUFDVyxLQUFLO0lBRS9CLHFCQUNFLDhEQUFDSztRQUNDQyxlQUFZO1FBQ1pDLFNBQVE7UUFDUkMsTUFBSztRQUNMUCxXQUFXbEIsZ0RBQUlBLENBQUNrQixXQUFXTixVQUFVLENBQUNJLE1BQU07UUFDM0MsR0FBR0csS0FBSztrQkFFVCw0RUFBQ0U7WUFBY0QsSUFBSUE7WUFBSUosT0FBT0E7Ozs7Ozs7Ozs7O0FBR3BDLENBQUM7R0FmZUQ7O1FBQ0xoQix3Q0FBS0E7OztLQURBZ0I7QUFpQmhCLE1BQU1XLFlBQVk7SUFDaEJiLE1BQU07UUFDSjtZQUFFYyxXQUFXO1FBQVU7UUFDdkI7WUFBRUEsV0FBVztZQUFXQyxRQUFRO1FBQU87UUFDdkM7WUFBRUQsV0FBVztZQUFXQyxRQUFRO1FBQUU7S0FDbkM7SUFDRGQsT0FBTztRQUNMO1lBQUVhLFdBQVc7WUFBV0MsUUFBUTtRQUFNO1FBQ3RDO1lBQUVELFdBQVc7WUFBV0MsUUFBUTtRQUFPO0tBQ3hDO0FBQ0g7QUFFTyxTQUFTQyxTQUFTLEtBQTRCLEVBQUU7UUFBOUIsRUFBRWIsT0FBUSxPQUFNLEVBQUUsR0FBR0csT0FBTyxHQUE1QjtJQUN2QixxQkFDRSw4REFBQ1c7UUFDQ0MsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLEdBQUc7UUFDSEMsZUFBYztRQUNiLEdBQUdmLEtBQUs7a0JBRVJPLFNBQVMsQ0FBQ1YsTUFBTSxDQUFDbUIsR0FBRyxDQUFDLENBQUNDLE1BQU1DLDBCQUMzQiw4REFBQ0Q7Z0JBQXNCLEdBQUdBLElBQUk7ZUFBbkJDOzs7Ozs7Ozs7O0FBSW5CLENBQUM7TUFkZVI7QUFnQlQsU0FBU1MsVUFBVSxLQUF1QixFQUFFO1FBQXpCLEVBQUVwQixVQUFTLEVBQUUsR0FBR0MsT0FBTyxHQUF2QjtJQUN4QixxQkFBTyw4REFBQ29CO1FBQUVyQixXQUFXbEIsZ0RBQUlBLENBQUMsZUFBZWtCO1FBQWEsR0FBR0MsS0FBSzs7Ozs7O0FBQ2hFLENBQUM7TUFGZW1CO0FBSVQsU0FBU0UsU0FBUyxLQUF1QixFQUFFO1FBQXpCLEVBQUV0QixVQUFTLEVBQUUsR0FBR0MsT0FBTyxHQUF2QjtJQUN2QixxQkFBTyw4REFBQ29CO1FBQUVyQixXQUFXbEIsZ0RBQUlBLENBQUMsc0JBQXNCa0I7UUFBYSxHQUFHQyxLQUFLOzs7Ozs7QUFDdkUsQ0FBQztNQUZlcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSWNvbi5qc3g/NGQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VJZCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCdcblxuaW1wb3J0IHsgSW5zdGFsbGF0aW9uSWNvbiB9IGZyb20gJ0AvY29tcG9uZW50cy9pY29ucy9JbnN0YWxsYXRpb25JY29uJ1xuaW1wb3J0IHsgTGlnaHRidWxiSWNvbiB9IGZyb20gJ0AvY29tcG9uZW50cy9pY29ucy9MaWdodGJ1bGJJY29uJ1xuaW1wb3J0IHsgUGx1Z2luc0ljb24gfSBmcm9tICdAL2NvbXBvbmVudHMvaWNvbnMvUGx1Z2luc0ljb24nXG5pbXBvcnQgeyBQcmVzZXRzSWNvbiB9IGZyb20gJ0AvY29tcG9uZW50cy9pY29ucy9QcmVzZXRzSWNvbidcbmltcG9ydCB7IFdhcm5pbmdJY29uIH0gZnJvbSAnQC9jb21wb25lbnRzL2ljb25zL1dhcm5pbmdJY29uJ1xuXG5jb25zdCBpY29ucyA9IHtcbiAgaW5zdGFsbGF0aW9uOiBJbnN0YWxsYXRpb25JY29uLFxuICBwcmVzZXRzOiBQcmVzZXRzSWNvbixcbiAgcGx1Z2luczogUGx1Z2luc0ljb24sXG4gIGxpZ2h0YnVsYjogTGlnaHRidWxiSWNvbixcbiAgd2FybmluZzogV2FybmluZ0ljb24sXG59XG5cbmNvbnN0IGljb25TdHlsZXMgPSB7XG4gIGJsdWU6ICdbLS1pY29uLWZvcmVncm91bmQ6dGhlbWUoY29sb3JzLnppbmMuOTAwKV0gWy0taWNvbi1iYWNrZ3JvdW5kOnRoZW1lKGNvbG9ycy53aGl0ZSldJyxcbiAgYW1iZXI6XG4gICAgJ1stLWljb24tZm9yZWdyb3VuZDp0aGVtZShjb2xvcnMuYW1iZXIuOTAwKV0gWy0taWNvbi1iYWNrZ3JvdW5kOnRoZW1lKGNvbG9ycy5hbWJlci4xMDApXScsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJY29uKHsgY29sb3IgPSAnYmx1ZScsIGljb24sIGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkge1xuICBsZXQgaWQgPSB1c2VJZCgpXG4gIGxldCBJY29uQ29tcG9uZW50ID0gaWNvbnNbaWNvbl1cblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDMyIDMyXCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIGNsYXNzTmFtZT17Y2xzeChjbGFzc05hbWUsIGljb25TdHlsZXNbY29sb3JdKX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8SWNvbkNvbXBvbmVudCBpZD17aWR9IGNvbG9yPXtjb2xvcn0gLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5jb25zdCBncmFkaWVudHMgPSB7XG4gIGJsdWU6IFtcbiAgICB7IHN0b3BDb2xvcjogJyMwRUE1RTknIH0sXG4gICAgeyBzdG9wQ29sb3I6ICcjMjJEM0VFJywgb2Zmc2V0OiAnLjUyNycgfSxcbiAgICB7IHN0b3BDb2xvcjogJyM4MThDRjgnLCBvZmZzZXQ6IDEgfSxcbiAgXSxcbiAgYW1iZXI6IFtcbiAgICB7IHN0b3BDb2xvcjogJyNGREU2OEEnLCBvZmZzZXQ6ICcuMDgnIH0sXG4gICAgeyBzdG9wQ29sb3I6ICcjRjU5RTBCJywgb2Zmc2V0OiAnLjgzNycgfSxcbiAgXSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEdyYWRpZW50KHsgY29sb3IgPSAnYmx1ZScsIC4uLnByb3BzIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8cmFkaWFsR3JhZGllbnRcbiAgICAgIGN4PXswfVxuICAgICAgY3k9ezB9XG4gICAgICByPXsxfVxuICAgICAgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCJcbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7Z3JhZGllbnRzW2NvbG9yXS5tYXAoKHN0b3AsIHN0b3BJbmRleCkgPT4gKFxuICAgICAgICA8c3RvcCBrZXk9e3N0b3BJbmRleH0gey4uLnN0b3B9IC8+XG4gICAgICApKX1cbiAgICA8L3JhZGlhbEdyYWRpZW50PlxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMaWdodE1vZGUoeyBjbGFzc05hbWUsIC4uLnByb3BzIH0pIHtcbiAgcmV0dXJuIDxnIGNsYXNzTmFtZT17Y2xzeCgnZGFyazpoaWRkZW4nLCBjbGFzc05hbWUpfSB7Li4ucHJvcHN9IC8+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEYXJrTW9kZSh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSkge1xuICByZXR1cm4gPGcgY2xhc3NOYW1lPXtjbHN4KCdoaWRkZW4gZGFyazppbmxpbmUnLCBjbGFzc05hbWUpfSB7Li4ucHJvcHN9IC8+XG59XG4iXSwibmFtZXMiOlsidXNlSWQiLCJjbHN4IiwiSW5zdGFsbGF0aW9uSWNvbiIsIkxpZ2h0YnVsYkljb24iLCJQbHVnaW5zSWNvbiIsIlByZXNldHNJY29uIiwiV2FybmluZ0ljb24iLCJpY29ucyIsImluc3RhbGxhdGlvbiIsInByZXNldHMiLCJwbHVnaW5zIiwibGlnaHRidWxiIiwid2FybmluZyIsImljb25TdHlsZXMiLCJibHVlIiwiYW1iZXIiLCJJY29uIiwiY29sb3IiLCJpY29uIiwiY2xhc3NOYW1lIiwicHJvcHMiLCJpZCIsIkljb25Db21wb25lbnQiLCJzdmciLCJhcmlhLWhpZGRlbiIsInZpZXdCb3giLCJmaWxsIiwiZ3JhZGllbnRzIiwic3RvcENvbG9yIiwib2Zmc2V0IiwiR3JhZGllbnQiLCJyYWRpYWxHcmFkaWVudCIsImN4IiwiY3kiLCJyIiwiZ3JhZGllbnRVbml0cyIsIm1hcCIsInN0b3AiLCJzdG9wSW5kZXgiLCJMaWdodE1vZGUiLCJnIiwiRGFya01vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Icon.jsx\n"));

/***/ }),

/***/ "./src/components/QuickLinks.jsx":
/*!***************************************!*\
  !*** ./src/components/QuickLinks.jsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"QuickLink\": function() { return /* binding */ QuickLink; },\n/* harmony export */   \"QuickLinks\": function() { return /* binding */ QuickLinks; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ \"../../node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\n\nfunction QuickLinks(param) {\n    let { children  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"not-prose my-12 grid grid-cols-1 gap-6 sm:grid-cols-2\",\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n        lineNumber: 7,\n        columnNumber: 5\n    }, this);\n}\n_c = QuickLinks;\nfunction QuickLink(param) {\n    let { title , description , href , icon  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"group relative rounded-xl border border-zinc-200 dark:border-zinc-800\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute -inset-px rounded-xl border-2 border-transparent opacity-0 [background:linear-gradient(var(--quick-links-hover-bg,theme(colors.teal.50)),var(--quick-links-hover-bg,theme(colors.teal.50)))_padding-box,linear-gradient(to_top,theme(colors.indigo.400),theme(colors.cyan.400),theme(colors.teal.500))_border-box] group-hover:opacity-100 dark:[--quick-links-hover-bg:theme(colors.zinc.800)]\"\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative overflow-hidden rounded-xl p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_2__.Icon, {\n                        icon: icon,\n                        className: \"h-8 w-8\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                        lineNumber: 18,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"mt-4 font-display text-base text-zinc-900 dark:text-white\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_1___default()), {\n                            href: href,\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"absolute -inset-px rounded-xl\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                                    lineNumber: 21,\n                                    columnNumber: 13\n                                }, this),\n                                title\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                            lineNumber: 20,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        className: \"mt-1 text-sm text-zinc-700 dark:text-zinc-400\",\n                        children: description\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                        lineNumber: 25,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/QuickLinks.jsx\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, this);\n}\n_c1 = QuickLink;\nvar _c, _c1;\n$RefreshReg$(_c, \"QuickLinks\");\n$RefreshReg$(_c1, \"QuickLink\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9RdWlja0xpbmtzLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QjtBQUVZO0FBRWpDLFNBQVNFLFdBQVcsS0FBWSxFQUFFO1FBQWQsRUFBRUMsU0FBUSxFQUFFLEdBQVo7SUFDekIscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7a0JBQ1pGOzs7Ozs7QUFHUCxDQUFDO0tBTmVEO0FBUVQsU0FBU0ksVUFBVSxLQUFrQyxFQUFFO1FBQXBDLEVBQUVDLE1BQUssRUFBRUMsWUFBVyxFQUFFQyxLQUFJLEVBQUVDLEtBQUksRUFBRSxHQUFsQztJQUN4QixxQkFDRSw4REFBQ047UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOzs7Ozs7MEJBQ2YsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0osa0RBQUlBO3dCQUFDUyxNQUFNQTt3QkFBTUwsV0FBVTs7Ozs7O2tDQUM1Qiw4REFBQ007d0JBQUdOLFdBQVU7a0NBQ1osNEVBQUNMLGtEQUFJQTs0QkFBQ1MsTUFBTUE7OzhDQUNWLDhEQUFDRztvQ0FBS1AsV0FBVTs7Ozs7O2dDQUNmRTs7Ozs7Ozs7Ozs7O2tDQUdMLDhEQUFDTTt3QkFBRVIsV0FBVTtrQ0FDVkc7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtYLENBQUM7TUFsQmVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1F1aWNrTGlua3MuanN4PzFkZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJ1xuXG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnQC9jb21wb25lbnRzL0ljb24nXG5cbmV4cG9ydCBmdW5jdGlvbiBRdWlja0xpbmtzKHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibm90LXByb3NlIG15LTEyIGdyaWQgZ3JpZC1jb2xzLTEgZ2FwLTYgc206Z3JpZC1jb2xzLTJcIj5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gUXVpY2tMaW5rKHsgdGl0bGUsIGRlc2NyaXB0aW9uLCBocmVmLCBpY29uIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImdyb3VwIHJlbGF0aXZlIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci16aW5jLTIwMCBkYXJrOmJvcmRlci16aW5jLTgwMFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSAtaW5zZXQtcHggcm91bmRlZC14bCBib3JkZXItMiBib3JkZXItdHJhbnNwYXJlbnQgb3BhY2l0eS0wIFtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCh2YXIoLS1xdWljay1saW5rcy1ob3Zlci1iZyx0aGVtZShjb2xvcnMudGVhbC41MCkpLHZhcigtLXF1aWNrLWxpbmtzLWhvdmVyLWJnLHRoZW1lKGNvbG9ycy50ZWFsLjUwKSkpX3BhZGRpbmctYm94LGxpbmVhci1ncmFkaWVudCh0b190b3AsdGhlbWUoY29sb3JzLmluZGlnby40MDApLHRoZW1lKGNvbG9ycy5jeWFuLjQwMCksdGhlbWUoY29sb3JzLnRlYWwuNTAwKSlfYm9yZGVyLWJveF0gZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgZGFyazpbLS1xdWljay1saW5rcy1ob3Zlci1iZzp0aGVtZShjb2xvcnMuemluYy44MDApXVwiIC8+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLXhsIHAtNlwiPlxuICAgICAgICA8SWNvbiBpY29uPXtpY29ufSBjbGFzc05hbWU9XCJoLTggdy04XCIgLz5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cIm10LTQgZm9udC1kaXNwbGF5IHRleHQtYmFzZSB0ZXh0LXppbmMtOTAwIGRhcms6dGV4dC13aGl0ZVwiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9e2hyZWZ9PlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYWJzb2x1dGUgLWluc2V0LXB4IHJvdW5kZWQteGxcIiAvPlxuICAgICAgICAgICAge3RpdGxlfVxuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgPC9oMj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMSB0ZXh0LXNtIHRleHQtemluYy03MDAgZGFyazp0ZXh0LXppbmMtNDAwXCI+XG4gICAgICAgICAge2Rlc2NyaXB0aW9ufVxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkxpbmsiLCJJY29uIiwiUXVpY2tMaW5rcyIsImNoaWxkcmVuIiwiZGl2IiwiY2xhc3NOYW1lIiwiUXVpY2tMaW5rIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImhyZWYiLCJpY29uIiwiaDIiLCJzcGFuIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/QuickLinks.jsx\n"));

/***/ }),

/***/ "./src/components/icons/InstallationIcon.jsx":
/*!***************************************************!*\
  !*** ./src/components/icons/InstallationIcon.jsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InstallationIcon\": function() { return /* binding */ InstallationIcon; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\nfunction InstallationIcon(param) {\n    let { id , color  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient`,\n                        color: color,\n                        gradientTransform: \"matrix(0 21 -21 0 12 3)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark`,\n                        color: color,\n                        gradientTransform: \"matrix(0 21 -21 0 16 7)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.LightMode, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                        cx: 12,\n                        cy: 12,\n                        r: 12,\n                        fill: `url(#${id}-gradient)`\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"m8 8 9 21 2-10 10-2L8 8Z\",\n                        fillOpacity: 0.5,\n                        className: \"fill-[var(--icon-background)] stroke-[color:var(--icon-foreground)]\",\n                        strokeWidth: 2,\n                        strokeLinecap: \"round\",\n                        strokeLinejoin: \"round\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                        lineNumber: 20,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.DarkMode, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                    d: \"m4 4 10.286 24 2.285-11.429L28 14.286 4 4Z\",\n                    fill: `url(#${id}-gradient-dark)`,\n                    stroke: `url(#${id}-gradient-dark)`,\n                    strokeWidth: 2,\n                    strokeLinecap: \"round\",\n                    strokeLinejoin: \"round\"\n                }, void 0, false, {\n                    fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                    lineNumber: 30,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/InstallationIcon.jsx\",\n                lineNumber: 29,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = InstallationIcon;\nvar _c;\n$RefreshReg$(_c, \"InstallationIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9pY29ucy9JbnN0YWxsYXRpb25JY29uLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRTtBQUUxRCxTQUFTRyxpQkFBaUIsS0FBYSxFQUFFO1FBQWYsRUFBRUMsR0FBRSxFQUFFQyxNQUFLLEVBQUUsR0FBYjtJQUMvQixxQkFDRTs7MEJBQ0UsOERBQUNDOztrQ0FDQyw4REFBQ0wsc0RBQVFBO3dCQUNQRyxJQUFJLENBQUMsRUFBRUEsR0FBRyxTQUFTLENBQUM7d0JBQ3BCQyxPQUFPQTt3QkFDUEUsbUJBQWtCOzs7Ozs7a0NBRXBCLDhEQUFDTixzREFBUUE7d0JBQ1BHLElBQUksQ0FBQyxFQUFFQSxHQUFHLGNBQWMsQ0FBQzt3QkFDekJDLE9BQU9BO3dCQUNQRSxtQkFBa0I7Ozs7Ozs7Ozs7OzswQkFHdEIsOERBQUNMLHVEQUFTQTs7a0NBQ1IsOERBQUNNO3dCQUFPQyxJQUFJO3dCQUFJQyxJQUFJO3dCQUFJQyxHQUFHO3dCQUFJQyxNQUFNLENBQUMsS0FBSyxFQUFFUixHQUFHLFVBQVUsQ0FBQzs7Ozs7O2tDQUMzRCw4REFBQ1M7d0JBQ0NDLEdBQUU7d0JBQ0ZDLGFBQWE7d0JBQ2JDLFdBQVU7d0JBQ1ZDLGFBQWE7d0JBQ2JDLGVBQWM7d0JBQ2RDLGdCQUFlOzs7Ozs7Ozs7Ozs7MEJBR25CLDhEQUFDbkIsc0RBQVFBOzBCQUNQLDRFQUFDYTtvQkFDQ0MsR0FBRTtvQkFDRkYsTUFBTSxDQUFDLEtBQUssRUFBRVIsR0FBRyxlQUFlLENBQUM7b0JBQ2pDZ0IsUUFBUSxDQUFDLEtBQUssRUFBRWhCLEdBQUcsZUFBZSxDQUFDO29CQUNuQ2EsYUFBYTtvQkFDYkMsZUFBYztvQkFDZEMsZ0JBQWU7Ozs7Ozs7Ozs7Ozs7QUFLekIsQ0FBQztLQXRDZWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ljb25zL0luc3RhbGxhdGlvbkljb24uanN4PzFjOTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGFya01vZGUsIEdyYWRpZW50LCBMaWdodE1vZGUgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbidcblxuZXhwb3J0IGZ1bmN0aW9uIEluc3RhbGxhdGlvbkljb24oeyBpZCwgY29sb3IgfSkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGVmcz5cbiAgICAgICAgPEdyYWRpZW50XG4gICAgICAgICAgaWQ9e2Ake2lkfS1ncmFkaWVudGB9XG4gICAgICAgICAgY29sb3I9e2NvbG9yfVxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KDAgMjEgLTIxIDAgMTIgMylcIlxuICAgICAgICAvPlxuICAgICAgICA8R3JhZGllbnRcbiAgICAgICAgICBpZD17YCR7aWR9LWdyYWRpZW50LWRhcmtgfVxuICAgICAgICAgIGNvbG9yPXtjb2xvcn1cbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgwIDIxIC0yMSAwIDE2IDcpXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGVmcz5cbiAgICAgIDxMaWdodE1vZGU+XG4gICAgICAgIDxjaXJjbGUgY3g9ezEyfSBjeT17MTJ9IHI9ezEyfSBmaWxsPXtgdXJsKCMke2lkfS1ncmFkaWVudClgfSAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJtOCA4IDkgMjEgMi0xMCAxMC0yTDggOFpcIlxuICAgICAgICAgIGZpbGxPcGFjaXR5PXswLjV9XG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmlsbC1bdmFyKC0taWNvbi1iYWNrZ3JvdW5kKV0gc3Ryb2tlLVtjb2xvcjp2YXIoLS1pY29uLWZvcmVncm91bmQpXVwiXG4gICAgICAgICAgc3Ryb2tlV2lkdGg9ezJ9XG4gICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgLz5cbiAgICAgIDwvTGlnaHRNb2RlPlxuICAgICAgPERhcmtNb2RlPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGQ9XCJtNCA0IDEwLjI4NiAyNCAyLjI4NS0xMS40MjlMMjggMTQuMjg2IDQgNFpcIlxuICAgICAgICAgIGZpbGw9e2B1cmwoIyR7aWR9LWdyYWRpZW50LWRhcmspYH1cbiAgICAgICAgICBzdHJva2U9e2B1cmwoIyR7aWR9LWdyYWRpZW50LWRhcmspYH1cbiAgICAgICAgICBzdHJva2VXaWR0aD17Mn1cbiAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAvPlxuICAgICAgPC9EYXJrTW9kZT5cbiAgICA8Lz5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkRhcmtNb2RlIiwiR3JhZGllbnQiLCJMaWdodE1vZGUiLCJJbnN0YWxsYXRpb25JY29uIiwiaWQiLCJjb2xvciIsImRlZnMiLCJncmFkaWVudFRyYW5zZm9ybSIsImNpcmNsZSIsImN4IiwiY3kiLCJyIiwiZmlsbCIsInBhdGgiLCJkIiwiZmlsbE9wYWNpdHkiLCJjbGFzc05hbWUiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/icons/InstallationIcon.jsx\n"));

/***/ }),

/***/ "./src/components/icons/LightbulbIcon.jsx":
/*!************************************************!*\
  !*** ./src/components/icons/LightbulbIcon.jsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LightbulbIcon\": function() { return /* binding */ LightbulbIcon; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\nfunction LightbulbIcon(param) {\n    let { id , color  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient`,\n                        color: color,\n                        gradientTransform: \"matrix(0 21 -21 0 20 11)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark`,\n                        color: color,\n                        gradientTransform: \"matrix(0 24.5001 -19.2498 0 16 5.5)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.LightMode, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"circle\", {\n                        cx: 20,\n                        cy: 20,\n                        r: 12,\n                        fill: `url(#${id}-gradient)`\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        fillRule: \"evenodd\",\n                        clipRule: \"evenodd\",\n                        d: \"M20 24.995c0-1.855 1.094-3.501 2.427-4.792C24.61 18.087 26 15.07 26 12.231 26 7.133 21.523 3 16 3S6 7.133 6 12.23c0 2.84 1.389 5.857 3.573 7.973C10.906 21.494 12 23.14 12 24.995V27a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-2.005Z\",\n                        className: \"fill-[var(--icon-background)]\",\n                        fillOpacity: 0.5\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 20,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M25 12.23c0 2.536-1.254 5.303-3.269 7.255l1.391 1.436c2.354-2.28 3.878-5.547 3.878-8.69h-2ZM16 4c5.047 0 9 3.759 9 8.23h2C27 6.508 21.998 2 16 2v2Zm-9 8.23C7 7.76 10.953 4 16 4V2C10.002 2 5 6.507 5 12.23h2Zm3.269 7.255C8.254 17.533 7 14.766 7 12.23H5c0 3.143 1.523 6.41 3.877 8.69l1.392-1.436ZM13 27v-2.005h-2V27h2Zm1 1a1 1 0 0 1-1-1h-2a3 3 0 0 0 3 3v-2Zm4 0h-4v2h4v-2Zm1-1a1 1 0 0 1-1 1v2a3 3 0 0 0 3-3h-2Zm0-2.005V27h2v-2.005h-2ZM8.877 20.921C10.132 22.136 11 23.538 11 24.995h2c0-2.253-1.32-4.143-2.731-5.51L8.877 20.92Zm12.854-1.436C20.32 20.852 19 22.742 19 24.995h2c0-1.457.869-2.859 2.122-4.074l-1.391-1.436Z\",\n                        className: \"fill-[var(--icon-foreground)]\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 27,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M20 26a1 1 0 1 0 0-2v2Zm-8-2a1 1 0 1 0 0 2v-2Zm2 0h-2v2h2v-2Zm1 1V13.5h-2V25h2Zm-5-11.5v1h2v-1h-2Zm3.5 4.5h5v-2h-5v2Zm8.5-3.5v-1h-2v1h2ZM20 24h-2v2h2v-2Zm-2 0h-4v2h4v-2Zm-1-10.5V25h2V13.5h-2Zm2.5-2.5a2.5 2.5 0 0 0-2.5 2.5h2a.5.5 0 0 1 .5-.5v-2Zm2.5 2.5a2.5 2.5 0 0 0-2.5-2.5v2a.5.5 0 0 1 .5.5h2ZM18.5 18a3.5 3.5 0 0 0 3.5-3.5h-2a1.5 1.5 0 0 1-1.5 1.5v2ZM10 14.5a3.5 3.5 0 0 0 3.5 3.5v-2a1.5 1.5 0 0 1-1.5-1.5h-2Zm2.5-3.5a2.5 2.5 0 0 0-2.5 2.5h2a.5.5 0 0 1 .5-.5v-2Zm2.5 2.5a2.5 2.5 0 0 0-2.5-2.5v2a.5.5 0 0 1 .5.5h2Z\",\n                        className: \"fill-[var(--icon-foreground)]\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                        lineNumber: 31,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.DarkMode, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                    fillRule: \"evenodd\",\n                    clipRule: \"evenodd\",\n                    d: \"M16 2C10.002 2 5 6.507 5 12.23c0 3.144 1.523 6.411 3.877 8.691.75.727 1.363 1.52 1.734 2.353.185.415.574.726 1.028.726H12a1 1 0 0 0 1-1v-4.5a.5.5 0 0 0-.5-.5A3.5 3.5 0 0 1 9 14.5V14a3 3 0 1 1 6 0v9a1 1 0 1 0 2 0v-9a3 3 0 1 1 6 0v.5a3.5 3.5 0 0 1-3.5 3.5.5.5 0 0 0-.5.5V23a1 1 0 0 0 1 1h.36c.455 0 .844-.311 1.03-.726.37-.833.982-1.626 1.732-2.353 2.354-2.28 3.878-5.547 3.878-8.69C27 6.507 21.998 2 16 2Zm5 25a1 1 0 0 0-1-1h-8a1 1 0 0 0-1 1 3 3 0 0 0 3 3h4a3 3 0 0 0 3-3Zm-8-13v1.5a.5.5 0 0 1-.5.5 1.5 1.5 0 0 1-1.5-1.5V14a1 1 0 1 1 2 0Zm6.5 2a.5.5 0 0 1-.5-.5V14a1 1 0 1 1 2 0v.5a1.5 1.5 0 0 1-1.5 1.5Z\",\n                    fill: `#34d399`\n                }, void 0, false, {\n                    fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                    lineNumber: 37,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/LightbulbIcon.jsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = LightbulbIcon;\nvar _c;\n$RefreshReg$(_c, \"LightbulbIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9pY29ucy9MaWdodGJ1bGJJY29uLmpzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRTtBQUUxRCxTQUFTRyxjQUFjLEtBQWEsRUFBRTtRQUFmLEVBQUVDLEdBQUUsRUFBRUMsTUFBSyxFQUFFLEdBQWI7SUFDNUIscUJBQ0U7OzBCQUNFLDhEQUFDQzs7a0NBQ0MsOERBQUNMLHNEQUFRQTt3QkFDUEcsSUFBSSxDQUFDLEVBQUVBLEdBQUcsU0FBUyxDQUFDO3dCQUNwQkMsT0FBT0E7d0JBQ1BFLG1CQUFrQjs7Ozs7O2tDQUVwQiw4REFBQ04sc0RBQVFBO3dCQUNQRyxJQUFJLENBQUMsRUFBRUEsR0FBRyxjQUFjLENBQUM7d0JBQ3pCQyxPQUFPQTt3QkFDUEUsbUJBQWtCOzs7Ozs7Ozs7Ozs7MEJBR3RCLDhEQUFDTCx1REFBU0E7O2tDQUNSLDhEQUFDTTt3QkFBT0MsSUFBSTt3QkFBSUMsSUFBSTt3QkFBSUMsR0FBRzt3QkFBSUMsTUFBTSxDQUFDLEtBQUssRUFBRVIsR0FBRyxVQUFVLENBQUM7Ozs7OztrQ0FDM0QsOERBQUNTO3dCQUNDQyxVQUFTO3dCQUNUQyxVQUFTO3dCQUNUQyxHQUFFO3dCQUNGQyxXQUFVO3dCQUNWQyxhQUFhOzs7Ozs7a0NBRWYsOERBQUNMO3dCQUNDRyxHQUFFO3dCQUNGQyxXQUFVOzs7Ozs7a0NBRVosOERBQUNKO3dCQUNDRyxHQUFFO3dCQUNGQyxXQUFVOzs7Ozs7Ozs7Ozs7MEJBR2QsOERBQUNqQixzREFBUUE7MEJBQ1AsNEVBQUNhO29CQUNDQyxVQUFTO29CQUNUQyxVQUFTO29CQUNUQyxHQUFFO29CQUNGSixNQUFNLENBQUMsT0FBTyxDQUFDOzs7Ozs7Ozs7Ozs7O0FBS3pCLENBQUM7S0EzQ2VUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL2ljb25zL0xpZ2h0YnVsYkljb24uanN4PzBjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGFya01vZGUsIEdyYWRpZW50LCBMaWdodE1vZGUgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbidcblxuZXhwb3J0IGZ1bmN0aW9uIExpZ2h0YnVsYkljb24oeyBpZCwgY29sb3IgfSkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGVmcz5cbiAgICAgICAgPEdyYWRpZW50XG4gICAgICAgICAgaWQ9e2Ake2lkfS1ncmFkaWVudGB9XG4gICAgICAgICAgY29sb3I9e2NvbG9yfVxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtPVwibWF0cml4KDAgMjEgLTIxIDAgMjAgMTEpXCJcbiAgICAgICAgLz5cbiAgICAgICAgPEdyYWRpZW50XG4gICAgICAgICAgaWQ9e2Ake2lkfS1ncmFkaWVudC1kYXJrYH1cbiAgICAgICAgICBjb2xvcj17Y29sb3J9XG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09XCJtYXRyaXgoMCAyNC41MDAxIC0xOS4yNDk4IDAgMTYgNS41KVwiXG4gICAgICAgIC8+XG4gICAgICA8L2RlZnM+XG4gICAgICA8TGlnaHRNb2RlPlxuICAgICAgICA8Y2lyY2xlIGN4PXsyMH0gY3k9ezIwfSByPXsxMn0gZmlsbD17YHVybCgjJHtpZH0tZ3JhZGllbnQpYH0gLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXG4gICAgICAgICAgZD1cIk0yMCAyNC45OTVjMC0xLjg1NSAxLjA5NC0zLjUwMSAyLjQyNy00Ljc5MkMyNC42MSAxOC4wODcgMjYgMTUuMDcgMjYgMTIuMjMxIDI2IDcuMTMzIDIxLjUyMyAzIDE2IDNTNiA3LjEzMyA2IDEyLjIzYzAgMi44NCAxLjM4OSA1Ljg1NyAzLjU3MyA3Ljk3M0MxMC45MDYgMjEuNDk0IDEyIDIzLjE0IDEyIDI0Ljk5NVYyN2EyIDIgMCAwIDAgMiAyaDRhMiAyIDAgMCAwIDItMnYtMi4wMDVaXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJmaWxsLVt2YXIoLS1pY29uLWJhY2tncm91bmQpXVwiXG4gICAgICAgICAgZmlsbE9wYWNpdHk9ezAuNX1cbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTI1IDEyLjIzYzAgMi41MzYtMS4yNTQgNS4zMDMtMy4yNjkgNy4yNTVsMS4zOTEgMS40MzZjMi4zNTQtMi4yOCAzLjg3OC01LjU0NyAzLjg3OC04LjY5aC0yWk0xNiA0YzUuMDQ3IDAgOSAzLjc1OSA5IDguMjNoMkMyNyA2LjUwOCAyMS45OTggMiAxNiAydjJabS05IDguMjNDNyA3Ljc2IDEwLjk1MyA0IDE2IDRWMkMxMC4wMDIgMiA1IDYuNTA3IDUgMTIuMjNoMlptMy4yNjkgNy4yNTVDOC4yNTQgMTcuNTMzIDcgMTQuNzY2IDcgMTIuMjNINWMwIDMuMTQzIDEuNTIzIDYuNDEgMy44NzcgOC42OWwxLjM5Mi0xLjQzNlpNMTMgMjd2LTIuMDA1aC0yVjI3aDJabTEgMWExIDEgMCAwIDEtMS0xaC0yYTMgMyAwIDAgMCAzIDN2LTJabTQgMGgtNHYyaDR2LTJabTEtMWExIDEgMCAwIDEtMSAxdjJhMyAzIDAgMCAwIDMtM2gtMlptMC0yLjAwNVYyN2gydi0yLjAwNWgtMlpNOC44NzcgMjAuOTIxQzEwLjEzMiAyMi4xMzYgMTEgMjMuNTM4IDExIDI0Ljk5NWgyYzAtMi4yNTMtMS4zMi00LjE0My0yLjczMS01LjUxTDguODc3IDIwLjkyWm0xMi44NTQtMS40MzZDMjAuMzIgMjAuODUyIDE5IDIyLjc0MiAxOSAyNC45OTVoMmMwLTEuNDU3Ljg2OS0yLjg1OSAyLjEyMi00LjA3NGwtMS4zOTEtMS40MzZaXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJmaWxsLVt2YXIoLS1pY29uLWZvcmVncm91bmQpXVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0yMCAyNmExIDEgMCAxIDAgMC0ydjJabS04LTJhMSAxIDAgMSAwIDAgMnYtMlptMiAwaC0ydjJoMnYtMlptMSAxVjEzLjVoLTJWMjVoMlptLTUtMTEuNXYxaDJ2LTFoLTJabTMuNSA0LjVoNXYtMmgtNXYyWm04LjUtMy41di0xaC0ydjFoMlpNMjAgMjRoLTJ2Mmgydi0yWm0tMiAwaC00djJoNHYtMlptLTEtMTAuNVYyNWgyVjEzLjVoLTJabTIuNS0yLjVhMi41IDIuNSAwIDAgMC0yLjUgMi41aDJhLjUuNSAwIDAgMSAuNS0uNXYtMlptMi41IDIuNWEyLjUgMi41IDAgMCAwLTIuNS0yLjV2MmEuNS41IDAgMCAxIC41LjVoMlpNMTguNSAxOGEzLjUgMy41IDAgMCAwIDMuNS0zLjVoLTJhMS41IDEuNSAwIDAgMS0xLjUgMS41djJaTTEwIDE0LjVhMy41IDMuNSAwIDAgMCAzLjUgMy41di0yYTEuNSAxLjUgMCAwIDEtMS41LTEuNWgtMlptMi41LTMuNWEyLjUgMi41IDAgMCAwLTIuNSAyLjVoMmEuNS41IDAgMCAxIC41LS41di0yWm0yLjUgMi41YTIuNSAyLjUgMCAwIDAtMi41LTIuNXYyYS41LjUgMCAwIDEgLjUuNWgyWlwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmlsbC1bdmFyKC0taWNvbi1mb3JlZ3JvdW5kKV1cIlxuICAgICAgICAvPlxuICAgICAgPC9MaWdodE1vZGU+XG4gICAgICA8RGFya01vZGU+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZmlsbFJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgICBjbGlwUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICAgIGQ9XCJNMTYgMkMxMC4wMDIgMiA1IDYuNTA3IDUgMTIuMjNjMCAzLjE0NCAxLjUyMyA2LjQxMSAzLjg3NyA4LjY5MS43NS43MjcgMS4zNjMgMS41MiAxLjczNCAyLjM1My4xODUuNDE1LjU3NC43MjYgMS4wMjguNzI2SDEyYTEgMSAwIDAgMCAxLTF2LTQuNWEuNS41IDAgMCAwLS41LS41QTMuNSAzLjUgMCAwIDEgOSAxNC41VjE0YTMgMyAwIDEgMSA2IDB2OWExIDEgMCAxIDAgMiAwdi05YTMgMyAwIDEgMSA2IDB2LjVhMy41IDMuNSAwIDAgMS0zLjUgMy41LjUuNSAwIDAgMC0uNS41VjIzYTEgMSAwIDAgMCAxIDFoLjM2Yy40NTUgMCAuODQ0LS4zMTEgMS4wMy0uNzI2LjM3LS44MzMuOTgyLTEuNjI2IDEuNzMyLTIuMzUzIDIuMzU0LTIuMjggMy44NzgtNS41NDcgMy44NzgtOC42OUMyNyA2LjUwNyAyMS45OTggMiAxNiAyWm01IDI1YTEgMSAwIDAgMC0xLTFoLThhMSAxIDAgMCAwLTEgMSAzIDMgMCAwIDAgMyAzaDRhMyAzIDAgMCAwIDMtM1ptLTgtMTN2MS41YS41LjUgMCAwIDEtLjUuNSAxLjUgMS41IDAgMCAxLTEuNS0xLjVWMTRhMSAxIDAgMSAxIDIgMFptNi41IDJhLjUuNSAwIDAgMS0uNS0uNVYxNGExIDEgMCAxIDEgMiAwdi41YTEuNSAxLjUgMCAwIDEtMS41IDEuNVpcIlxuICAgICAgICAgIGZpbGw9e2AjMzRkMzk5YH1cbiAgICAgICAgLz5cbiAgICAgIDwvRGFya01vZGU+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJEYXJrTW9kZSIsIkdyYWRpZW50IiwiTGlnaHRNb2RlIiwiTGlnaHRidWxiSWNvbiIsImlkIiwiY29sb3IiLCJkZWZzIiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJjaXJjbGUiLCJjeCIsImN5IiwiciIsImZpbGwiLCJwYXRoIiwiZmlsbFJ1bGUiLCJjbGlwUnVsZSIsImQiLCJjbGFzc05hbWUiLCJmaWxsT3BhY2l0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/icons/LightbulbIcon.jsx\n"));

/***/ }),

/***/ "./src/components/icons/PluginsIcon.jsx":
/*!**********************************************!*\
  !*** ./src/components/icons/PluginsIcon.jsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PluginsIcon\": function() { return /* binding */ PluginsIcon; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\nfunction PluginsIcon(param) {\n    let { id , color  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient`,\n                        color: color,\n                        gradientTransform: \"matrix(0 21 -21 0 20 11)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark-1`,\n                        color: color,\n                        gradientTransform: \"matrix(0 22.75 -22.75 0 16 6.25)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark-2`,\n                        color: color,\n                        gradientTransform: \"matrix(0 14 -14 0 16 10)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                        lineNumber: 17,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.DarkMode, {\n                strokeWidth: 2,\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M17.676 3.38a3.887 3.887 0 0 0-3.352 0l-9 4.288C3.907 8.342 3 9.806 3 11.416v9.168c0 1.61.907 3.073 2.324 3.748l9 4.288a3.887 3.887 0 0 0 3.352 0l9-4.288C28.093 23.657 29 22.194 29 20.584v-9.168c0-1.61-.907-3.074-2.324-3.748l-9-4.288Z\",\n                        stroke: `url(#${id}-gradient-dark-1)`\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                        lineNumber: 24,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M16.406 8.087a.989.989 0 0 0-.812 0l-7 3.598A1.012 1.012 0 0 0 8 12.61v6.78c0 .4.233.762.594.925l7 3.598a.989.989 0 0 0 .812 0l7-3.598c.361-.163.594-.525.594-.925v-6.78c0-.4-.233-.762-.594-.925l-7-3.598Z\",\n                        fill: `url(#${id}-gradient-dark-2)`,\n                        stroke: `url(#${id}-gradient-dark-2)`\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PluginsIcon.jsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = PluginsIcon;\nvar _c;\n$RefreshReg$(_c, \"PluginsIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9pY29ucy9QbHVnaW5zSWNvbi5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0Q7QUFFL0MsU0FBU0UsWUFBWSxLQUFhLEVBQUU7UUFBZixFQUFFQyxHQUFFLEVBQUVDLE1BQUssRUFBRSxHQUFiO0lBQzFCLHFCQUNFOzswQkFDRSw4REFBQ0M7O2tDQUNDLDhEQUFDSixzREFBUUE7d0JBQ1BFLElBQUksQ0FBQyxFQUFFQSxHQUFHLFNBQVMsQ0FBQzt3QkFDcEJDLE9BQU9BO3dCQUNQRSxtQkFBa0I7Ozs7OztrQ0FFcEIsOERBQUNMLHNEQUFRQTt3QkFDUEUsSUFBSSxDQUFDLEVBQUVBLEdBQUcsZ0JBQWdCLENBQUM7d0JBQzNCQyxPQUFPQTt3QkFDUEUsbUJBQWtCOzs7Ozs7a0NBRXBCLDhEQUFDTCxzREFBUUE7d0JBQ1BFLElBQUksQ0FBQyxFQUFFQSxHQUFHLGdCQUFnQixDQUFDO3dCQUMzQkMsT0FBT0E7d0JBQ1BFLG1CQUFrQjs7Ozs7Ozs7Ozs7OzBCQUd0Qiw4REFBQ04sc0RBQVFBO2dCQUFDTyxhQUFhO2dCQUFHQyxlQUFjO2dCQUFRQyxnQkFBZTs7a0NBQzdELDhEQUFDQzt3QkFDQ0MsR0FBRTt3QkFDRkMsUUFBUSxDQUFDLEtBQUssRUFBRVQsR0FBRyxpQkFBaUIsQ0FBQzs7Ozs7O2tDQUV2Qyw4REFBQ087d0JBQ0NDLEdBQUU7d0JBQ0ZFLE1BQU0sQ0FBQyxLQUFLLEVBQUVWLEdBQUcsaUJBQWlCLENBQUM7d0JBQ25DUyxRQUFRLENBQUMsS0FBSyxFQUFFVCxHQUFHLGlCQUFpQixDQUFDOzs7Ozs7Ozs7Ozs7OztBQUsvQyxDQUFDO0tBakNlRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9pY29ucy9QbHVnaW5zSWNvbi5qc3g/YTVmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXJrTW9kZSwgR3JhZGllbnQgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbidcblxuZXhwb3J0IGZ1bmN0aW9uIFBsdWdpbnNJY29uKHsgaWQsIGNvbG9yIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRlZnM+XG4gICAgICAgIDxHcmFkaWVudFxuICAgICAgICAgIGlkPXtgJHtpZH0tZ3JhZGllbnRgfVxuICAgICAgICAgIGNvbG9yPXtjb2xvcn1cbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgwIDIxIC0yMSAwIDIwIDExKVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxHcmFkaWVudFxuICAgICAgICAgIGlkPXtgJHtpZH0tZ3JhZGllbnQtZGFyay0xYH1cbiAgICAgICAgICBjb2xvcj17Y29sb3J9XG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09XCJtYXRyaXgoMCAyMi43NSAtMjIuNzUgMCAxNiA2LjI1KVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxHcmFkaWVudFxuICAgICAgICAgIGlkPXtgJHtpZH0tZ3JhZGllbnQtZGFyay0yYH1cbiAgICAgICAgICBjb2xvcj17Y29sb3J9XG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09XCJtYXRyaXgoMCAxNCAtMTQgMCAxNiAxMClcIlxuICAgICAgICAvPlxuICAgICAgPC9kZWZzPlxuICAgICAgPERhcmtNb2RlIHN0cm9rZVdpZHRoPXsyfSBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk0xNy42NzYgMy4zOGEzLjg4NyAzLjg4NyAwIDAgMC0zLjM1MiAwbC05IDQuMjg4QzMuOTA3IDguMzQyIDMgOS44MDYgMyAxMS40MTZ2OS4xNjhjMCAxLjYxLjkwNyAzLjA3MyAyLjMyNCAzLjc0OGw5IDQuMjg4YTMuODg3IDMuODg3IDAgMCAwIDMuMzUyIDBsOS00LjI4OEMyOC4wOTMgMjMuNjU3IDI5IDIyLjE5NCAyOSAyMC41ODR2LTkuMTY4YzAtMS42MS0uOTA3LTMuMDc0LTIuMzI0LTMuNzQ4bC05LTQuMjg4WlwiXG4gICAgICAgICAgc3Ryb2tlPXtgdXJsKCMke2lkfS1ncmFkaWVudC1kYXJrLTEpYH1cbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBkPVwiTTE2LjQwNiA4LjA4N2EuOTg5Ljk4OSAwIDAgMC0uODEyIDBsLTcgMy41OThBMS4wMTIgMS4wMTIgMCAwIDAgOCAxMi42MXY2Ljc4YzAgLjQuMjMzLjc2Mi41OTQuOTI1bDcgMy41OThhLjk4OS45ODkgMCAwIDAgLjgxMiAwbDctMy41OThjLjM2MS0uMTYzLjU5NC0uNTI1LjU5NC0uOTI1di02Ljc4YzAtLjQtLjIzMy0uNzYyLS41OTQtLjkyNWwtNy0zLjU5OFpcIlxuICAgICAgICAgIGZpbGw9e2B1cmwoIyR7aWR9LWdyYWRpZW50LWRhcmstMilgfVxuICAgICAgICAgIHN0cm9rZT17YHVybCgjJHtpZH0tZ3JhZGllbnQtZGFyay0yKWB9XG4gICAgICAgIC8+XG4gICAgICA8L0RhcmtNb2RlPlxuICAgIDwvPlxuICApXG59XG4iXSwibmFtZXMiOlsiRGFya01vZGUiLCJHcmFkaWVudCIsIlBsdWdpbnNJY29uIiwiaWQiLCJjb2xvciIsImRlZnMiLCJncmFkaWVudFRyYW5zZm9ybSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwicGF0aCIsImQiLCJzdHJva2UiLCJmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/icons/PluginsIcon.jsx\n"));

/***/ }),

/***/ "./src/components/icons/PresetsIcon.jsx":
/*!**********************************************!*\
  !*** ./src/components/icons/PresetsIcon.jsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PresetsIcon\": function() { return /* binding */ PresetsIcon; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\nfunction PresetsIcon(param) {\n    let { id , color  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient`,\n                        color: color,\n                        gradientTransform: \"matrix(0 21 -21 0 20 3)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark`,\n                        color: color,\n                        gradientTransform: \"matrix(0 22.75 -22.75 0 16 6.25)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.DarkMode, {\n                fill: `url(#${id}-gradient-dark)`,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        fillRule: \"evenodd\",\n                        clipRule: \"evenodd\",\n                        d: \"M3 17V4a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Zm16 10v-9a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2Zm0-23v5a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-8a1 1 0 0 0-1 1ZM3 28v-3a1 1 0 0 1 1-1h9a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1Z\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                        lineNumber: 19,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                        d: \"M2 4v13h2V4H2Zm2-2a2 2 0 0 0-2 2h2V2Zm8 0H4v2h8V2Zm2 2a2 2 0 0 0-2-2v2h2Zm0 13V4h-2v13h2Zm-2 2a2 2 0 0 0 2-2h-2v2Zm-8 0h8v-2H4v2Zm-2-2a2 2 0 0 0 2 2v-2H2Zm16 1v9h2v-9h-2Zm3-3a3 3 0 0 0-3 3h2a1 1 0 0 1 1-1v-2Zm6 0h-6v2h6v-2Zm3 3a3 3 0 0 0-3-3v2a1 1 0 0 1 1 1h2Zm0 9v-9h-2v9h2Zm-3 3a3 3 0 0 0 3-3h-2a1 1 0 0 1-1 1v2Zm-6 0h6v-2h-6v2Zm-3-3a3 3 0 0 0 3 3v-2a1 1 0 0 1-1-1h-2Zm2-18V4h-2v5h2Zm0 0h-2a2 2 0 0 0 2 2V9Zm8 0h-8v2h8V9Zm0 0v2a2 2 0 0 0 2-2h-2Zm0-5v5h2V4h-2Zm0 0h2a2 2 0 0 0-2-2v2Zm-8 0h8V2h-8v2Zm0 0V2a2 2 0 0 0-2 2h2ZM2 25v3h2v-3H2Zm2-2a2 2 0 0 0-2 2h2v-2Zm9 0H4v2h9v-2Zm2 2a2 2 0 0 0-2-2v2h2Zm0 3v-3h-2v3h2Zm-2 2a2 2 0 0 0 2-2h-2v2Zm-9 0h9v-2H4v2Zm-2-2a2 2 0 0 0 2 2v-2H2Z\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                        lineNumber: 24,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/PresetsIcon.jsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = PresetsIcon;\nvar _c;\n$RefreshReg$(_c, \"PresetsIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9pY29ucy9QcmVzZXRzSWNvbi5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUU7QUFFMUQsU0FBU0csWUFBWSxLQUFhLEVBQUU7UUFBZixFQUFFQyxHQUFFLEVBQUVDLE1BQUssRUFBRSxHQUFiO0lBQzFCLHFCQUNFOzswQkFDRSw4REFBQ0M7O2tDQUNDLDhEQUFDTCxzREFBUUE7d0JBQ1BHLElBQUksQ0FBQyxFQUFFQSxHQUFHLFNBQVMsQ0FBQzt3QkFDcEJDLE9BQU9BO3dCQUNQRSxtQkFBa0I7Ozs7OztrQ0FFcEIsOERBQUNOLHNEQUFRQTt3QkFDUEcsSUFBSSxDQUFDLEVBQUVBLEdBQUcsY0FBYyxDQUFDO3dCQUN6QkMsT0FBT0E7d0JBQ1BFLG1CQUFrQjs7Ozs7Ozs7Ozs7OzBCQUd0Qiw4REFBQ1Asc0RBQVFBO2dCQUFDUSxNQUFNLENBQUMsS0FBSyxFQUFFSixHQUFHLGVBQWUsQ0FBQzs7a0NBQ3pDLDhEQUFDSzt3QkFDQ0MsVUFBUzt3QkFDVEMsVUFBUzt3QkFDVEMsR0FBRTs7Ozs7O2tDQUVKLDhEQUFDSDt3QkFBS0csR0FBRTs7Ozs7Ozs7Ozs7Ozs7QUFJaEIsQ0FBQztLQXpCZVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvaWNvbnMvUHJlc2V0c0ljb24uanN4P2ZlMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGFya01vZGUsIEdyYWRpZW50LCBMaWdodE1vZGUgfSBmcm9tICdAL2NvbXBvbmVudHMvSWNvbidcblxuZXhwb3J0IGZ1bmN0aW9uIFByZXNldHNJY29uKHsgaWQsIGNvbG9yIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRlZnM+XG4gICAgICAgIDxHcmFkaWVudFxuICAgICAgICAgIGlkPXtgJHtpZH0tZ3JhZGllbnRgfVxuICAgICAgICAgIGNvbG9yPXtjb2xvcn1cbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgwIDIxIC0yMSAwIDIwIDMpXCJcbiAgICAgICAgLz5cbiAgICAgICAgPEdyYWRpZW50XG4gICAgICAgICAgaWQ9e2Ake2lkfS1ncmFkaWVudC1kYXJrYH1cbiAgICAgICAgICBjb2xvcj17Y29sb3J9XG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm09XCJtYXRyaXgoMCAyMi43NSAtMjIuNzUgMCAxNiA2LjI1KVwiXG4gICAgICAgIC8+XG4gICAgICA8L2RlZnM+XG4gICAgICA8RGFya01vZGUgZmlsbD17YHVybCgjJHtpZH0tZ3JhZGllbnQtZGFyaylgfT5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXG4gICAgICAgICAgZD1cIk0zIDE3VjRhMSAxIDAgMCAxIDEtMWg4YTEgMSAwIDAgMSAxIDF2MTNhMSAxIDAgMCAxLTEgMUg0YTEgMSAwIDAgMS0xLTFabTE2IDEwdi05YTIgMiAwIDAgMSAyLTJoNmEyIDIgMCAwIDEgMiAydjlhMiAyIDAgMCAxLTIgMmgtNmEyIDIgMCAwIDEtMi0yWm0wLTIzdjVhMSAxIDAgMCAwIDEgMWg4YTEgMSAwIDAgMCAxLTFWNGExIDEgMCAwIDAtMS0xaC04YTEgMSAwIDAgMC0xIDFaTTMgMjh2LTNhMSAxIDAgMCAxIDEtMWg5YTEgMSAwIDAgMSAxIDF2M2ExIDEgMCAwIDEtMSAxSDRhMSAxIDAgMCAxLTEtMVpcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aCBkPVwiTTIgNHYxM2gyVjRIMlptMi0yYTIgMiAwIDAgMC0yIDJoMlYyWm04IDBINHYyaDhWMlptMiAyYTIgMiAwIDAgMC0yLTJ2MmgyWm0wIDEzVjRoLTJ2MTNoMlptLTIgMmEyIDIgMCAwIDAgMi0yaC0ydjJabS04IDBoOHYtMkg0djJabS0yLTJhMiAyIDAgMCAwIDIgMnYtMkgyWm0xNiAxdjloMnYtOWgtMlptMy0zYTMgMyAwIDAgMC0zIDNoMmExIDEgMCAwIDEgMS0xdi0yWm02IDBoLTZ2Mmg2di0yWm0zIDNhMyAzIDAgMCAwLTMtM3YyYTEgMSAwIDAgMSAxIDFoMlptMCA5di05aC0ydjloMlptLTMgM2EzIDMgMCAwIDAgMy0zaC0yYTEgMSAwIDAgMS0xIDF2MlptLTYgMGg2di0yaC02djJabS0zLTNhMyAzIDAgMCAwIDMgM3YtMmExIDEgMCAwIDEtMS0xaC0yWm0yLTE4VjRoLTJ2NWgyWm0wIDBoLTJhMiAyIDAgMCAwIDIgMlY5Wm04IDBoLTh2Mmg4VjlabTAgMHYyYTIgMiAwIDAgMCAyLTJoLTJabTAtNXY1aDJWNGgtMlptMCAwaDJhMiAyIDAgMCAwLTItMnYyWm0tOCAwaDhWMmgtOHYyWm0wIDBWMmEyIDIgMCAwIDAtMiAyaDJaTTIgMjV2M2gydi0zSDJabTItMmEyIDIgMCAwIDAtMiAyaDJ2LTJabTkgMEg0djJoOXYtMlptMiAyYTIgMiAwIDAgMC0yLTJ2MmgyWm0wIDN2LTNoLTJ2M2gyWm0tMiAyYTIgMiAwIDAgMCAyLTJoLTJ2MlptLTkgMGg5di0ySDR2MlptLTItMmEyIDIgMCAwIDAgMiAydi0ySDJaXCIgLz5cbiAgICAgIDwvRGFya01vZGU+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJEYXJrTW9kZSIsIkdyYWRpZW50IiwiTGlnaHRNb2RlIiwiUHJlc2V0c0ljb24iLCJpZCIsImNvbG9yIiwiZGVmcyIsImdyYWRpZW50VHJhbnNmb3JtIiwiZmlsbCIsInBhdGgiLCJmaWxsUnVsZSIsImNsaXBSdWxlIiwiZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/icons/PresetsIcon.jsx\n"));

/***/ }),

/***/ "./src/components/icons/WarningIcon.jsx":
/*!**********************************************!*\
  !*** ./src/components/icons/WarningIcon.jsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WarningIcon\": function() { return /* binding */ WarningIcon; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Icon */ \"./src/components/Icon.jsx\");\n\n\nfunction WarningIcon(param) {\n    let { id , color  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"defs\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient`,\n                        color: color,\n                        gradientTransform: \"rotate(65.924 1.519 20.92) scale(25.7391)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/WarningIcon.jsx\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.Gradient, {\n                        id: `${id}-gradient-dark`,\n                        color: color,\n                        gradientTransform: \"matrix(0 24.5 -24.5 0 16 5.5)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/WarningIcon.jsx\",\n                        lineNumber: 12,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/WarningIcon.jsx\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Icon__WEBPACK_IMPORTED_MODULE_1__.DarkMode, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                    fillRule: \"evenodd\",\n                    clipRule: \"evenodd\",\n                    d: \"M2 16C2 8.268 8.268 2 16 2s14 6.268 14 14-6.268 14-14 14S2 23.732 2 16Zm11.386-4.85a2.66 2.66 0 1 1 5.228 0l-1.039 5.543a1.602 1.602 0 0 1-3.15 0l-1.04-5.543ZM16 20a2 2 0 1 0 0 4 2 2 0 0 0 0-4Z\",\n                    fill: `#F7AA20`\n                }, void 0, false, {\n                    fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/WarningIcon.jsx\",\n                    lineNumber: 19,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/components/icons/WarningIcon.jsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = WarningIcon;\nvar _c;\n$RefreshReg$(_c, \"WarningIcon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9pY29ucy9XYXJuaW5nSWNvbi5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUU7QUFFMUQsU0FBU0csWUFBWSxLQUFhLEVBQUU7UUFBZixFQUFFQyxHQUFFLEVBQUVDLE1BQUssRUFBRSxHQUFiO0lBQzFCLHFCQUNFOzswQkFDRSw4REFBQ0M7O2tDQUNDLDhEQUFDTCxzREFBUUE7d0JBQ1BHLElBQUksQ0FBQyxFQUFFQSxHQUFHLFNBQVMsQ0FBQzt3QkFDcEJDLE9BQU9BO3dCQUNQRSxtQkFBa0I7Ozs7OztrQ0FFcEIsOERBQUNOLHNEQUFRQTt3QkFDUEcsSUFBSSxDQUFDLEVBQUVBLEdBQUcsY0FBYyxDQUFDO3dCQUN6QkMsT0FBT0E7d0JBQ1BFLG1CQUFrQjs7Ozs7Ozs7Ozs7OzBCQUd0Qiw4REFBQ1Asc0RBQVFBOzBCQUNQLDRFQUFDUTtvQkFDQ0MsVUFBUztvQkFDVEMsVUFBUztvQkFDVEMsR0FBRTtvQkFDRkMsTUFBTSxDQUFDLE9BQU8sQ0FBQzs7Ozs7Ozs7Ozs7OztBQUt6QixDQUFDO0tBekJlVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9pY29ucy9XYXJuaW5nSWNvbi5qc3g/MWU4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXJrTW9kZSwgR3JhZGllbnQsIExpZ2h0TW9kZSB9IGZyb20gJ0AvY29tcG9uZW50cy9JY29uJ1xuXG5leHBvcnQgZnVuY3Rpb24gV2FybmluZ0ljb24oeyBpZCwgY29sb3IgfSkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGVmcz5cbiAgICAgICAgPEdyYWRpZW50XG4gICAgICAgICAgaWQ9e2Ake2lkfS1ncmFkaWVudGB9XG4gICAgICAgICAgY29sb3I9e2NvbG9yfVxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtPVwicm90YXRlKDY1LjkyNCAxLjUxOSAyMC45Mikgc2NhbGUoMjUuNzM5MSlcIlxuICAgICAgICAvPlxuICAgICAgICA8R3JhZGllbnRcbiAgICAgICAgICBpZD17YCR7aWR9LWdyYWRpZW50LWRhcmtgfVxuICAgICAgICAgIGNvbG9yPXtjb2xvcn1cbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybT1cIm1hdHJpeCgwIDI0LjUgLTI0LjUgMCAxNiA1LjUpXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGVmcz5cbiAgICAgIDxEYXJrTW9kZT5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBmaWxsUnVsZT1cImV2ZW5vZGRcIlxuICAgICAgICAgIGNsaXBSdWxlPVwiZXZlbm9kZFwiXG4gICAgICAgICAgZD1cIk0yIDE2QzIgOC4yNjggOC4yNjggMiAxNiAyczE0IDYuMjY4IDE0IDE0LTYuMjY4IDE0LTE0IDE0UzIgMjMuNzMyIDIgMTZabTExLjM4Ni00Ljg1YTIuNjYgMi42NiAwIDEgMSA1LjIyOCAwbC0xLjAzOSA1LjU0M2ExLjYwMiAxLjYwMiAwIDAgMS0zLjE1IDBsLTEuMDQtNS41NDNaTTE2IDIwYTIgMiAwIDEgMCAwIDQgMiAyIDAgMCAwIDAtNFpcIlxuICAgICAgICAgIGZpbGw9e2AjRjdBQTIwYH1cbiAgICAgICAgLz5cbiAgICAgIDwvRGFya01vZGU+XG4gICAgPC8+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJEYXJrTW9kZSIsIkdyYWRpZW50IiwiTGlnaHRNb2RlIiwiV2FybmluZ0ljb24iLCJpZCIsImNvbG9yIiwiZGVmcyIsImdyYWRpZW50VHJhbnNmb3JtIiwicGF0aCIsImZpbGxSdWxlIiwiY2xpcFJ1bGUiLCJkIiwiZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/icons/WarningIcon.jsx\n"));

/***/ }),

/***/ "./src/markdoc/nodes.js":
/*!******************************!*\
  !*** ./src/markdoc/nodes.js ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @markdoc/markdoc */ \"../../node_modules/@markdoc/markdoc/dist/index.mjs\");\n/* harmony import */ var _components_Fence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/Fence */ \"./src/components/Fence.jsx\");\n\n\nconst nodes = {\n    document: {\n        render: undefined\n    },\n    th: {\n        ..._markdoc_markdoc__WEBPACK_IMPORTED_MODULE_1__.nodes.th,\n        attributes: {\n            ..._markdoc_markdoc__WEBPACK_IMPORTED_MODULE_1__.nodes.th.attributes,\n            scope: {\n                type: String,\n                default: \"col\"\n            }\n        }\n    },\n    fence: {\n        render: _components_Fence__WEBPACK_IMPORTED_MODULE_0__.Fence,\n        attributes: {\n            language: {\n                type: String\n            }\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (nodes);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFya2RvYy9ub2Rlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBd0Q7QUFFZDtBQUUxQyxNQUFNQSxRQUFRO0lBQ1pHLFVBQVU7UUFDUkMsUUFBUUM7SUFDVjtJQUNBQyxJQUFJO1FBQ0YsR0FBR0wsc0RBQWU7UUFDbEJNLFlBQVk7WUFDVixHQUFHTixpRUFBMEI7WUFDN0JPLE9BQU87Z0JBQ0xDLE1BQU1DO2dCQUNOQyxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBQ0FDLE9BQU87UUFDTFIsUUFBUUYsb0RBQUtBO1FBQ2JLLFlBQVk7WUFDVk0sVUFBVTtnQkFDUkosTUFBTUM7WUFDUjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlVixLQUFLQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9tYXJrZG9jL25vZGVzLmpzPzA3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9kZXMgYXMgZGVmYXVsdE5vZGVzIH0gZnJvbSAnQG1hcmtkb2MvbWFya2RvYydcblxuaW1wb3J0IHsgRmVuY2UgfSBmcm9tICdAL2NvbXBvbmVudHMvRmVuY2UnXG5cbmNvbnN0IG5vZGVzID0ge1xuICBkb2N1bWVudDoge1xuICAgIHJlbmRlcjogdW5kZWZpbmVkLFxuICB9LFxuICB0aDoge1xuICAgIC4uLmRlZmF1bHROb2Rlcy50aCxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAuLi5kZWZhdWx0Tm9kZXMudGguYXR0cmlidXRlcyxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ2NvbCcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIGZlbmNlOiB7XG4gICAgcmVuZGVyOiBGZW5jZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBsYW5ndWFnZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVzXG4iXSwibmFtZXMiOlsibm9kZXMiLCJkZWZhdWx0Tm9kZXMiLCJGZW5jZSIsImRvY3VtZW50IiwicmVuZGVyIiwidW5kZWZpbmVkIiwidGgiLCJhdHRyaWJ1dGVzIiwic2NvcGUiLCJ0eXBlIiwiU3RyaW5nIiwiZGVmYXVsdCIsImZlbmNlIiwibGFuZ3VhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/markdoc/nodes.js\n"));

/***/ }),

/***/ "./src/markdoc/tags.js":
/*!*****************************!*\
  !*** ./src/markdoc/tags.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Callout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Callout */ \"./src/components/Callout.jsx\");\n/* harmony import */ var _components_QuickLinks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/QuickLinks */ \"./src/components/QuickLinks.jsx\");\n\n\n\nconst tags = {\n    callout: {\n        attributes: {\n            title: {\n                type: String\n            },\n            type: {\n                type: String,\n                default: \"note\",\n                matches: [\n                    \"note\",\n                    \"warning\"\n                ],\n                errorLevel: \"critical\"\n            }\n        },\n        render: _components_Callout__WEBPACK_IMPORTED_MODULE_1__.Callout\n    },\n    figure: {\n        selfClosing: true,\n        attributes: {\n            src: {\n                type: String\n            },\n            alt: {\n                type: String\n            },\n            caption: {\n                type: String\n            }\n        },\n        render: (param)=>/*#__PURE__*/ {\n            let { src , alt =\"\" , caption  } = param;\n            return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"figure\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        src: src,\n                        alt: alt\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/markdoc/tags.js\",\n                        lineNumber: 27,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"figcaption\", {\n                        children: caption\n                    }, void 0, false, {\n                        fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/markdoc/tags.js\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/peronif5/MyWorkspace/HeliumWorkspace/modular-governance/packages/docsite/src/markdoc/tags.js\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, undefined);\n        }\n    },\n    \"quick-links\": {\n        render: _components_QuickLinks__WEBPACK_IMPORTED_MODULE_2__.QuickLinks\n    },\n    \"quick-link\": {\n        selfClosing: true,\n        render: _components_QuickLinks__WEBPACK_IMPORTED_MODULE_2__.QuickLink,\n        attributes: {\n            title: {\n                type: String\n            },\n            description: {\n                type: String\n            },\n            icon: {\n                type: String\n            },\n            href: {\n                type: String\n            }\n        }\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (tags);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFya2RvYy90YWdzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNpQjtBQUUvRCxNQUFNRyxPQUFPO0lBQ1hDLFNBQVM7UUFDUEMsWUFBWTtZQUNWQyxPQUFPO2dCQUFFQyxNQUFNQztZQUFPO1lBQ3RCRCxNQUFNO2dCQUNKQSxNQUFNQztnQkFDTkMsU0FBUztnQkFDVEMsU0FBUztvQkFBQztvQkFBUTtpQkFBVTtnQkFDNUJDLFlBQVk7WUFDZDtRQUNGO1FBQ0FDLFFBQVFaLHdEQUFPQTtJQUNqQjtJQUNBYSxRQUFRO1FBQ05DLGFBQWEsSUFBSTtRQUNqQlQsWUFBWTtZQUNWVSxLQUFLO2dCQUFFUixNQUFNQztZQUFPO1lBQ3BCUSxLQUFLO2dCQUFFVCxNQUFNQztZQUFPO1lBQ3BCUyxTQUFTO2dCQUFFVixNQUFNQztZQUFPO1FBQzFCO1FBQ0FJLFFBQVEsdUJBQ047Z0JBRE8sRUFBRUcsSUFBRyxFQUFFQyxLQUFNLEdBQUUsRUFBRUMsUUFBTyxFQUFFO21CQUNqQyw4REFBQ0o7O2tDQUVDLDhEQUFDSzt3QkFBSUgsS0FBS0E7d0JBQUtDLEtBQUtBOzs7Ozs7a0NBQ3BCLDhEQUFDRztrQ0FBWUY7Ozs7Ozs7Ozs7OztRQUNQO0lBRVo7SUFDQSxlQUFlO1FBQ2JMLFFBQVFWLDhEQUFVQTtJQUNwQjtJQUNBLGNBQWM7UUFDWlksYUFBYSxJQUFJO1FBQ2pCRixRQUFRWCw2REFBU0E7UUFDakJJLFlBQVk7WUFDVkMsT0FBTztnQkFBRUMsTUFBTUM7WUFBTztZQUN0QlksYUFBYTtnQkFBRWIsTUFBTUM7WUFBTztZQUM1QmEsTUFBTTtnQkFBRWQsTUFBTUM7WUFBTztZQUNyQmMsTUFBTTtnQkFBRWYsTUFBTUM7WUFBTztRQUN2QjtJQUNGO0FBQ0Y7QUFFQSwrREFBZUwsSUFBSUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbWFya2RvYy90YWdzLmpzPzU3ODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FsbG91dCB9IGZyb20gJ0AvY29tcG9uZW50cy9DYWxsb3V0J1xuaW1wb3J0IHsgUXVpY2tMaW5rLCBRdWlja0xpbmtzIH0gZnJvbSAnQC9jb21wb25lbnRzL1F1aWNrTGlua3MnXG5cbmNvbnN0IHRhZ3MgPSB7XG4gIGNhbGxvdXQ6IHtcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnbm90ZScsXG4gICAgICAgIG1hdGNoZXM6IFsnbm90ZScsICd3YXJuaW5nJ10sXG4gICAgICAgIGVycm9yTGV2ZWw6ICdjcml0aWNhbCcsXG4gICAgICB9LFxuICAgIH0sXG4gICAgcmVuZGVyOiBDYWxsb3V0LFxuICB9LFxuICBmaWd1cmU6IHtcbiAgICBzZWxmQ2xvc2luZzogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBzcmM6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgICBhbHQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgICBjYXB0aW9uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIH0sXG4gICAgcmVuZGVyOiAoeyBzcmMsIGFsdCA9ICcnLCBjYXB0aW9uIH0pID0+IChcbiAgICAgIDxmaWd1cmU+XG4gICAgICAgIHsvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQG5leHQvbmV4dC9uby1pbWctZWxlbWVudCAqL31cbiAgICAgICAgPGltZyBzcmM9e3NyY30gYWx0PXthbHR9IC8+XG4gICAgICAgIDxmaWdjYXB0aW9uPntjYXB0aW9ufTwvZmlnY2FwdGlvbj5cbiAgICAgIDwvZmlndXJlPlxuICAgICksXG4gIH0sXG4gICdxdWljay1saW5rcyc6IHtcbiAgICByZW5kZXI6IFF1aWNrTGlua3MsXG4gIH0sXG4gICdxdWljay1saW5rJzoge1xuICAgIHNlbGZDbG9zaW5nOiB0cnVlLFxuICAgIHJlbmRlcjogUXVpY2tMaW5rLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgICAgZGVzY3JpcHRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgICBpY29uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgICAgaHJlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB9LFxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCB0YWdzXG4iXSwibmFtZXMiOlsiQ2FsbG91dCIsIlF1aWNrTGluayIsIlF1aWNrTGlua3MiLCJ0YWdzIiwiY2FsbG91dCIsImF0dHJpYnV0ZXMiLCJ0aXRsZSIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwibWF0Y2hlcyIsImVycm9yTGV2ZWwiLCJyZW5kZXIiLCJmaWd1cmUiLCJzZWxmQ2xvc2luZyIsInNyYyIsImFsdCIsImNhcHRpb24iLCJpbWciLCJmaWdjYXB0aW9uIiwiZGVzY3JpcHRpb24iLCJpY29uIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/markdoc/tags.js\n"));

/***/ }),

/***/ "./src/pages/docs/api/token-voter-sdk.md":
/*!***********************************************!*\
  !*** ./src/pages/docs/api/token-voter-sdk.md ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__N_SSG\": function() { return /* binding */ __N_SSG; },\n/* harmony export */   \"default\": function() { return /* binding */ MarkdocComponent; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @markdoc/markdoc */ \"../../node_modules/@markdoc/markdoc/dist/index.mjs\");\n/* harmony import */ var _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_node_modules_markdoc_next_js_src_runtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/@markdoc/next.js/src/runtime.js */ \"../../node_modules/@markdoc/next.js/src/runtime.js\");\n/* harmony import */ var _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/markdoc/tags.js */ \"./src/markdoc/tags.js\");\n/* harmony import */ var _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/markdoc/nodes.js */ \"./src/markdoc/nodes.js\");\n\n// renderers is imported separately so Markdoc isn't sent to the client\n\n\n/**\n * Schema is imported like this so end-user's code is compiled using build-in babel/webpack configs.\n * This enables typescript/ESnext support\n */ const config = {};\n\n\nconst functions = {};\nconst schema = {\n    tags: _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_2__ ? _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] || _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_tags_js__WEBPACK_IMPORTED_MODULE_2__ : {},\n    nodes: _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_3__ ? _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"] || _Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_packages_docsite_src_markdoc_nodes_js__WEBPACK_IMPORTED_MODULE_3__ : {},\n    functions: functions ? functions.default || functions : {},\n    ...config ? config.default || config : {}\n};\nconst { components  } = (0,_Users_peronif5_MyWorkspace_HeliumWorkspace_modular_governance_node_modules_markdoc_next_js_src_runtime_js__WEBPACK_IMPORTED_MODULE_1__.getSchema)(schema);\nvar __N_SSG = true;\nfunction MarkdocComponent(props) {\n    // Only execute HMR code in development\n    return _markdoc_markdoc__WEBPACK_IMPORTED_MODULE_4__.renderers.react(props.markdoc.content, (react__WEBPACK_IMPORTED_MODULE_0___default()), {\n        components: {\n            ...components,\n            // Allows users to override default components at runtime, via their _app\n            ...props.components\n        }\n    });\n}\n_c = MarkdocComponent;\nvar _c;\n$RefreshReg$(_c, \"MarkdocComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvZG9jcy9hcGkvdG9rZW4tdm90ZXItc2RrLm1kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBCO0FBRTFCLHVFQUF1RTtBQUNwQjtBQUVtRjtBQUN0STs7O0NBR0MsR0FDRCxNQUFNRyxTQUFTLENBQUM7QUFDMkc7QUFDRTtBQUM3SCxNQUFNRyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBUztJQUNmSCxNQUFNQSxnSUFBSUEsR0FBSUEsMklBQVksSUFBSUEsZ0lBQUlBLEdBQUksQ0FBQyxDQUFDO0lBQ3hDQyxPQUFPQSxpSUFBS0EsR0FBSUEsNElBQWEsSUFBSUEsaUlBQUtBLEdBQUksQ0FBQyxDQUFDO0lBQzVDQyxXQUFXQSxZQUFhQSxVQUFVRSxPQUFPLElBQUlGLFlBQWEsQ0FBQyxDQUFDO0lBQzVELEdBQUlILFNBQVVBLE9BQU9LLE9BQU8sSUFBSUwsU0FBVSxDQUFDLENBQUM7QUFDNUM7QUFpQkEsTUFBTSxFQUFDTSxXQUFVLEVBQVUsR0FBR1AscUpBQVNBLENBQUNLOztBQTZDekIsU0FBU0csaUJBQWlCQyxLQUFLLEVBQUU7SUFDOUMsdUNBQXVDO0lBQ3ZDLE9BQU9WLDZEQUFlLENBQUNVLE1BQU1FLE9BQU8sQ0FBQ0MsT0FBTyxFQUFFZCw4Q0FBS0EsRUFBRTtRQUNuRFMsWUFBWTtZQUNWLEdBQUdBLFVBQVU7WUFDYix5RUFBeUU7WUFDekUsR0FBR0UsTUFBTUYsVUFBVTtRQUNyQjtJQUNGO0FBQ0YsQ0FBQztLQVR1QkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2RvY3MvYXBpL3Rva2VuLXZvdGVyLXNkay5tZD84ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeWFtbCBmcm9tICdqcy15YW1sJztcbi8vIHJlbmRlcmVycyBpcyBpbXBvcnRlZCBzZXBhcmF0ZWx5IHNvIE1hcmtkb2MgaXNuJ3Qgc2VudCB0byB0aGUgY2xpZW50XG5pbXBvcnQgTWFya2RvYywge3JlbmRlcmVyc30gZnJvbSAnQG1hcmtkb2MvbWFya2RvYydcblxuaW1wb3J0IHtnZXRTY2hlbWF9IGZyb20gJy9Vc2Vycy9wZXJvbmlmNS9NeVdvcmtzcGFjZS9IZWxpdW1Xb3Jrc3BhY2UvbW9kdWxhci1nb3Zlcm5hbmNlL25vZGVfbW9kdWxlcy9AbWFya2RvYy9uZXh0LmpzL3NyYy9ydW50aW1lLmpzJztcbi8qKlxuICogU2NoZW1hIGlzIGltcG9ydGVkIGxpa2UgdGhpcyBzbyBlbmQtdXNlcidzIGNvZGUgaXMgY29tcGlsZWQgdXNpbmcgYnVpbGQtaW4gYmFiZWwvd2VicGFjayBjb25maWdzLlxuICogVGhpcyBlbmFibGVzIHR5cGVzY3JpcHQvRVNuZXh0IHN1cHBvcnRcbiAqL1xuY29uc3QgY29uZmlnID0ge307XG5pbXBvcnQgKiBhcyB0YWdzIGZyb20gJy9Vc2Vycy9wZXJvbmlmNS9NeVdvcmtzcGFjZS9IZWxpdW1Xb3Jrc3BhY2UvbW9kdWxhci1nb3Zlcm5hbmNlL3BhY2thZ2VzL2RvY3NpdGUvc3JjL21hcmtkb2MvdGFncy5qcydcbmltcG9ydCAqIGFzIG5vZGVzIGZyb20gJy9Vc2Vycy9wZXJvbmlmNS9NeVdvcmtzcGFjZS9IZWxpdW1Xb3Jrc3BhY2UvbW9kdWxhci1nb3Zlcm5hbmNlL3BhY2thZ2VzL2RvY3NpdGUvc3JjL21hcmtkb2Mvbm9kZXMuanMnXG5jb25zdCBmdW5jdGlvbnMgPSB7fTtcbmNvbnN0IHNjaGVtYSA9IHtcbnRhZ3M6IHRhZ3MgPyAodGFncy5kZWZhdWx0IHx8IHRhZ3MpIDoge30sXG5ub2Rlczogbm9kZXMgPyAobm9kZXMuZGVmYXVsdCB8fCBub2RlcykgOiB7fSxcbmZ1bmN0aW9uczogZnVuY3Rpb25zID8gKGZ1bmN0aW9ucy5kZWZhdWx0IHx8IGZ1bmN0aW9ucykgOiB7fSxcbi4uLihjb25maWcgPyAoY29uZmlnLmRlZmF1bHQgfHwgY29uZmlnKSA6IHt9KSxcbn07XG5cbi8qKlxuICogU291cmNlIHdpbGwgbmV2ZXIgY2hhbmdlIGF0IHJ1bnRpbWUsIHNvIHBhcnNlIGhhcHBlbnMgYXQgdGhlIGZpbGUgcm9vdFxuICovXG5jb25zdCBzb3VyY2UgPSBcIiMgVG9rZW4gVm90ZXIgU0RLXFxuXFxueyUgY2FsbG91dCB0aXRsZT1cXFwiUXVpY2sgdGlwXFxcIiAlfVxcbklmIHlvdSBhcmUgbG9va2luZyBmb3IgYSBxdWljayBzdGFydCBndWlkZSwgY2hlY2sgb3V0IHRoZSBbR2V0dGluZyBTdGFydGVkXSgvZG9jcy9sZWFybi9nZXR0aW5nX3N0YXJ0ZWQpIGd1aWRlLiBXZSBhbHNvIGhhdmUgc29tZSByZWFjdCBleGFtcGxlcyBbaGVyZV0oL2RvY3MvbGVhcm4vcmVhY3QpLlxcbnslIC9jYWxsb3V0ICV9XFxuXFxuIyMgSW5zdHJ1Y3Rpb25zXFxuXFxuIyMjIGluaXRpYWxpemVUb2tlblZvdGVyVjBcXG5cXG4jIyMjIEFjY291bnRzXFxuXFxufCBOYW1lICAgICAgICAgICAgICAgICAgIHwgTXV0YWJpbGl0eSB8IFNpZ25lciB8IERvY3MgfFxcbnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0gfCAtLS0tLS0gfCAtLS0tIHxcXG58IHBheWVyICAgICAgICAgICAgICAgICAgfCBtdXQgICAgICAgIHwgeWVzICAgIHwgICAgICB8XFxufCB0b2tlblZvdGVyICAgICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgY29sbGVjdGlvbiAgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IG1ldGFkYXRhICAgICAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBtYXN0ZXJFZGl0aW9uICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgdG9rZW5BY2NvdW50ICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IG1pbnQgICAgICAgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCByZW50ICAgICAgICAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgdG9rZW5Qcm9ncmFtICAgICAgICAgICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IGFzc29jaWF0ZWRUb2tlblByb2dyYW0gfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB0b2tlbk1ldGFkYXRhUHJvZ3JhbSAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgc3lzdGVtUHJvZ3JhbSAgICAgICAgICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG5cXG4jIyMjIEFyZ3NcXG5cXG58IE5hbWUgfCBUeXBlICAgICAgICAgICAgICAgICAgICAgICB8IERvY3MgfFxcbnwgLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLSB8XFxufCBhcmdzIHwgSW5pdGlhbGl6ZVRva2VuVm90ZXJBcmdzVjAgfCAgICAgIHxcXG5cXG4jIyMgZGVwb3NpdFYwXFxuXFxuIyMjIyBBY2NvdW50c1xcblxcbnwgTmFtZSAgICAgICAgICAgICAgICAgICAgfCBNdXRhYmlsaXR5IHwgU2lnbmVyIHwgRG9jcyB8XFxufCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0gfCAtLS0tLS0gfCAtLS0tIHxcXG58IHRva2VuVm90ZXIgICAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgY29sbGVjdGlvbiAgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBjb2xsZWN0aW9uTWV0YWRhdGEgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IGNvbGxlY3Rpb25NYXN0ZXJFZGl0aW9uIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgcmVjZWlwdCAgICAgICAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBtaW50ICAgICAgICAgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IG1ldGFkYXRhICAgICAgICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgbWFzdGVyRWRpdGlvbiAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCByZWNlaXB0VG9rZW5BY2NvdW50ICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHJlY2lwaWVudCAgICAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgdmF1bHQgICAgICAgICAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB0b2tlbkFjY291bnQgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHBheWVyICAgICAgICAgICAgICAgICAgIHwgbXV0ICAgICAgICB8IHllcyAgICB8ICAgICAgfFxcbnwgZGVwb3NpdE1pbnQgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBzeXN0ZW1Qcm9ncmFtICAgICAgICAgICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHRva2VuUHJvZ3JhbSAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgYXNzb2NpYXRlZFRva2VuUHJvZ3JhbSAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB0b2tlbk1ldGFkYXRhUHJvZ3JhbSAgICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHJlbnQgICAgICAgICAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcblxcbiMjIyMgQXJnc1xcblxcbnwgTmFtZSB8IFR5cGUgICAgICAgICAgfCBEb2NzIHxcXG58IC0tLS0gfCAtLS0tLS0tLS0tLS0tIHwgLS0tLSB8XFxufCBhcmdzIHwgRGVwb3NpdEFyZ3NWMCB8ICAgICAgfFxcblxcbiMjIyByZWxpbnF1aXNoVm90ZVYwXFxuXFxuIyMjIyBBY2NvdW50c1xcblxcbnwgTmFtZSAgICAgICAgICAgIHwgTXV0YWJpbGl0eSB8IFNpZ25lciB8IERvY3MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLSB8IC0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxcbnwgcmVmdW5kICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8IEFjY291bnQgdG8gcmVjZWl2ZSBzb2wgcmVmdW5kIGlmIG1hcmtlciBpcyBjbG9zZWQgfFxcbnwgbWFya2VyICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgdG9rZW5Wb3RlciAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgdm90ZXIgICAgICAgICAgIHwgaW1tdXQgICAgICB8IHllcyAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgcmVjZWlwdCAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgbWludCAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgdG9rZW5BY2NvdW50ICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgcHJvcG9zYWwgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgcHJvcG9zYWxDb25maWcgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgc3RhdGVDb250cm9sbGVyIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgb25Wb3RlSG9vayAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgcHJvcG9zYWxQcm9ncmFtIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcbnwgc3lzdGVtUHJvZ3JhbSAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcblxcbiMjIyMgQXJnc1xcblxcbnwgTmFtZSB8IFR5cGUgICAgICAgICAgICAgICAgIHwgRG9jcyB8XFxufCAtLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tIHxcXG58IGFyZ3MgfCBSZWxpbnF1aXNoVm90ZUFyZ3NWMCB8ICAgICAgfFxcblxcbiMjIyB2b3RlVjBcXG5cXG4jIyMjIEFjY291bnRzXFxuXFxufCBOYW1lICAgICAgICAgICAgfCBNdXRhYmlsaXR5IHwgU2lnbmVyIHwgRG9jcyB8XFxufCAtLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tIHwgLS0tLS0tIHwgLS0tLSB8XFxufCBwYXllciAgICAgICAgICAgfCBtdXQgICAgICAgIHwgeWVzICAgIHwgICAgICB8XFxufCBtYXJrZXIgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB0b2tlblZvdGVyICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB2b3RlciAgICAgICAgICAgfCBpbW11dCAgICAgIHwgeWVzICAgIHwgICAgICB8XFxufCByZWNlaXB0ICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBtaW50ICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCB0b2tlbkFjY291bnQgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBwcm9wb3NhbCAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBwcm9wb3NhbENvbmZpZyAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBzdGF0ZUNvbnRyb2xsZXIgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBvblZvdGVIb29rICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBwcm9wb3NhbFByb2dyYW0gfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBzeXN0ZW1Qcm9ncmFtICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxuXFxuIyMjIyBBcmdzXFxuXFxufCBOYW1lIHwgVHlwZSAgICAgICB8IERvY3MgfFxcbnwgLS0tLSB8IC0tLS0tLS0tLS0gfCAtLS0tIHxcXG58IGFyZ3MgfCBWb3RlQXJnc1YwIHwgICAgICB8XFxuXFxuIyMjIHdpdGhkcmF3VjBcXG5cXG4jIyMjIEFjY291bnRzXFxuXFxufCBOYW1lICAgICAgICAgICAgICAgICAgIHwgTXV0YWJpbGl0eSB8IFNpZ25lciB8IERvY3MgfFxcbnwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0gfCAtLS0tLS0gfCAtLS0tIHxcXG58IHRva2VuVm90ZXIgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBjb2xsZWN0aW9uICAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgY29sbGVjdGlvbk1ldGFkYXRhICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHJlY2VpcHQgICAgICAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBtaW50ICAgICAgICAgICAgICAgICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgbWV0YWRhdGEgICAgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IG1hc3RlckVkaXRpb24gICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCByZWNlaXB0VG9rZW5BY2NvdW50ICAgIHwgbXV0ICAgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgdmF1bHQgICAgICAgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHRva2VuQWNjb3VudCAgICAgICAgICAgfCBtdXQgICAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBwYXllciAgICAgICAgICAgICAgICAgIHwgbXV0ICAgICAgICB8IHllcyAgICB8ICAgICAgfFxcbnwgcmVmdW5kICAgICAgICAgICAgICAgICB8IG11dCAgICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IG93bmVyICAgICAgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgeWVzICAgIHwgICAgICB8XFxufCBkZXBvc2l0TWludCAgICAgICAgICAgIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgc3lzdGVtUHJvZ3JhbSAgICAgICAgICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHRva2VuUHJvZ3JhbSAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxufCBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtIHwgaW1tdXQgICAgICB8IG5vICAgICB8ICAgICAgfFxcbnwgdG9rZW5NZXRhZGF0YVByb2dyYW0gICB8IGltbXV0ICAgICAgfCBubyAgICAgfCAgICAgIHxcXG58IHJlbnQgICAgICAgICAgICAgICAgICAgfCBpbW11dCAgICAgIHwgbm8gICAgIHwgICAgICB8XFxuXFxuIyMjIyBBcmdzXFxuXFxufCBOYW1lIHwgVHlwZSB8IERvY3MgfFxcbnwgLS0tLSB8IC0tLS0gfCAtLS0tIHxcXG5cXG4jIyBBY2NvdW50c1xcblxcbnwgTmFtZSAgICAgICAgICAgfCBUeXBlICAgICAgICAgICAgfCBEb2NzICB8XFxufCAtLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tIHwgLS0tLSB8XFxufCBUb2tlblZvdGVyVjAgICB8ICAgICAgICAgICAgICAgICB8IEZpZWxkIHwgVHlwZSB8XFxufCAtLS0tLSAgICAgICAgICB8IC0tLS0gICAgICAgICAgICB8XFxufCBhdXRob3JpdHkgICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBkZXBvc2l0TWludCAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBjb2xsZWN0aW9uICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBuYW1lICAgICAgICAgICB8IHN0cmluZyAgICAgICAgICB8XFxufCBidW1wU2VlZCAgICAgICB8IHU4ICAgICAgICAgICAgICB8XFxufCAgICAgICAgICAgICAgICB8XFxufCBSZWNlaXB0VjAgICAgICB8ICAgICAgICAgICAgICAgICB8IEZpZWxkIHwgVHlwZSB8XFxufCAtLS0tLSAgICAgICAgICB8IC0tLS0gICAgICAgICAgICB8XFxufCB0b2tlblZvdGVyICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBtaW50ICAgICAgICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBhbW91bnQgICAgICAgICB8IHU2NCAgICAgICAgICAgICB8XFxufCBudW1BY3RpdmVWb3RlcyB8IHU2NCAgICAgICAgICAgICB8XFxufCBidW1wU2VlZCAgICAgICB8IHU4ICAgICAgICAgICAgICB8XFxufCAgICAgICAgICAgICAgICB8XFxufCBWb3RlTWFya2VyVjAgICB8ICAgICAgICAgICAgICAgICB8IEZpZWxkIHwgVHlwZSB8XFxufCAtLS0tLSAgICAgICAgICB8IC0tLS0gICAgICAgICAgICB8XFxufCB2b3RlciAgICAgICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCB0b2tlblZvdGVyICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBwcm9wb3NhbCAgICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBtaW50ICAgICAgICAgICB8IHB1YmxpY0tleSAgICAgICB8XFxufCBjaG9pY2VzICAgICAgICB8IFtvYmplY3QgT2JqZWN0XSB8XFxufCBidW1wU2VlZCAgICAgICB8IHU4ICAgICAgICAgICAgICB8XFxufCAgICAgICAgICAgICAgICB8XFxuXFxuIyMgVHlwZXNcXG5cXG4jIyMgRGVwb3NpdEFyZ3NWMFxcblxcbnwgRmllbGQgICAgICAgfCBUeXBlICAgfFxcbnwgLS0tLS0tLS0tLS0gfCAtLS0tLS0gfFxcbnwgYW1vdW50ICAgICAgfCB1NjQgICAgfFxcbnwgbWV0YWRhdGFVcmkgfCBzdHJpbmcgfFxcblxcbiMjIyBJbml0aWFsaXplVG9rZW5Wb3RlckFyZ3NWMFxcblxcbnwgRmllbGQgICAgICAgICB8IFR5cGUgICAgICB8XFxufCAtLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tIHxcXG58IG5hbWUgICAgICAgICAgfCBzdHJpbmcgICAgfFxcbnwgYXV0aG9yaXR5ICAgICB8IHB1YmxpY0tleSB8XFxufCBjb2xsZWN0aW9uVXJpIHwgc3RyaW5nICAgIHxcXG5cXG4jIyMgUmVsaW5xdWlzaFZvdGVBcmdzVjBcXG5cXG58IEZpZWxkICB8IFR5cGUgfFxcbnwgLS0tLS0tIHwgLS0tLSB8XFxufCBjaG9pY2UgfCB1MTYgIHxcXG5cXG4jIyMgVm90ZUFyZ3NWMFxcblxcbnwgRmllbGQgIHwgVHlwZSB8XFxufCAtLS0tLS0gfCAtLS0tIHxcXG58IGNob2ljZSB8IHUxNiAgfFxcblxcbiMjIyBVc2VNZXRob2RcXG5cXG58IFZhcmlhbnQgIHwgRmllbGRzIHxcXG58IC0tLS0tLS0tIHwgLS0tLS0tIHxcXG58IEJ1cm4gICAgIHwgICAgICAgIHxcXG58IE11bHRpcGxlIHwgICAgICAgIHxcXG58IFNpbmdsZSAgIHwgICAgICAgIHxcXG5cXG4jIyMgQ29sbGVjdGlvbkRldGFpbHNcXG5cXG58IFZhcmlhbnQgfCBGaWVsZHMgICAgfFxcbnwgLS0tLS0tLSB8IC0tLS0tLS0tLSB8XFxufCBWMSAgICAgIHwgc2l6ZTogdTY0IHxcXG5cIjtcbmNvbnN0IGZpbGVwYXRoID0gXCIvZG9jcy9hcGkvdG9rZW4tdm90ZXItc2RrLm1kXCI7XG5jb25zdCBhc3QgPSBNYXJrZG9jLnBhcnNlKHNvdXJjZSk7XG5cbi8qKlxuICogTGlrZSB0aGUgQVNULCBmcm9udG1hdHRlciB3b24ndCBjaGFuZ2UgYXQgcnVudGltZSwgc28gaXQgaXMgbG9hZGVkIGF0IGZpbGUgcm9vdC5cbiAqIFRoaXMgdW5ibG9ja3MgZnV0dXJlIGZlYXR1cmVzLCBzdWNoIGEgcGVyLXBhZ2UgZGF0YUZldGNoaW5nRnVuY3Rpb24uXG4gKi9cbmNvbnN0IGZyb250bWF0dGVyID0gYXN0LmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXJcbiAgPyB5YW1sLmxvYWQoYXN0LmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIpXG4gIDoge307XG5cbmNvbnN0IHtjb21wb25lbnRzLCAuLi5yZXN0fSA9IGdldFNjaGVtYShzY2hlbWEpXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdGF0aWNQcm9wcyhjb250ZXh0KSB7XG4gIGNvbnN0IHBhcnRpYWxzID0ge307XG5cbiAgLy8gRW5zdXJlIE5vZGUudHJhbnNmb3JtQ2hpbGRyZW4gaXMgYXZhaWxhYmxlXG4gIE9iamVjdC5rZXlzKHBhcnRpYWxzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBwYXJ0aWFsc1trZXldID0gTWFya2RvYy5wYXJzZShwYXJ0aWFsc1trZXldKTtcbiAgfSk7XG5cbiAgY29uc3QgY2ZnID0ge1xuICAgIC4uLnJlc3QsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAuLi4ocmVzdCA/IHJlc3QudmFyaWFibGVzIDoge30pLFxuICAgICAgLy8gdXNlciBjYW4ndCBvdmVycmlkZSB0aGlzIG5hbWVzcGFjZVxuICAgICAgbWFya2RvYzoge2Zyb250bWF0dGVyfSxcbiAgICAgIC8vIEFsbG93cyB1c2VycyB0byBlamVjdCBmcm9tIE1hcmtkb2MgcmVuZGVyaW5nIGFuZCBwYXNzIGluIGR5bmFtaWMgdmFyaWFibGVzIHZpYSBnZXRTZXJ2ZXJTaWRlUHJvcHNcbiAgICAgIC4uLihjb250ZXh0LnZhcmlhYmxlcyB8fCB7fSlcbiAgICB9LFxuICAgIHBhcnRpYWxzLFxuICAgIHNvdXJjZSxcbiAgfTtcblxuICAvKipcbiAgICogdHJhbnNmb3JtIG11c3QgYmUgY2FsbGVkIGluIGRhdGFGZXRjaGluZ0Z1bmN0aW9uIHRvIHN1cHBvcnQgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdoaWxlXG4gICAqIGFjY2Vzc2luZyB2YXJpYWJsZXMgb24gdGhlIHNlcnZlclxuICAgKi9cbiAgY29uc3QgY29udGVudCA9IE1hcmtkb2MudHJhbnNmb3JtKGFzdCwgY2ZnKTtcblxuICByZXR1cm4ge1xuICAgIC8vIFJlbW92ZXMgdW5kZWZpbmVkXG4gICAgcHJvcHM6IEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1hcmtkb2M6IHtcbiAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgIGZyb250bWF0dGVyLFxuICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgIHBhdGg6IGZpbGVwYXRoXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApLFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXJrZG9jQ29tcG9uZW50KHByb3BzKSB7XG4gIC8vIE9ubHkgZXhlY3V0ZSBITVIgY29kZSBpbiBkZXZlbG9wbWVudFxuICByZXR1cm4gcmVuZGVyZXJzLnJlYWN0KHByb3BzLm1hcmtkb2MuY29udGVudCwgUmVhY3QsIHtcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICAuLi5jb21wb25lbnRzLFxuICAgICAgLy8gQWxsb3dzIHVzZXJzIHRvIG92ZXJyaWRlIGRlZmF1bHQgY29tcG9uZW50cyBhdCBydW50aW1lLCB2aWEgdGhlaXIgX2FwcFxuICAgICAgLi4ucHJvcHMuY29tcG9uZW50cyxcbiAgICB9LFxuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInJlbmRlcmVycyIsImdldFNjaGVtYSIsImNvbmZpZyIsInRhZ3MiLCJub2RlcyIsImZ1bmN0aW9ucyIsInNjaGVtYSIsImRlZmF1bHQiLCJjb21wb25lbnRzIiwiTWFya2RvY0NvbXBvbmVudCIsInByb3BzIiwicmVhY3QiLCJtYXJrZG9jIiwiY29udGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/docs/api/token-voter-sdk.md\n"));

/***/ }),

/***/ "../../node_modules/prism-react-renderer/dist/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/prism-react-renderer/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Prism\": function() { return /* reexport safe */ _prism_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   \"defaultProps\": function() { return /* binding */ defaultProps; }\n/* harmony export */ });\n/* harmony import */ var _prism_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../prism/index.js */ \"../../node_modules/prism-react-renderer/prism/index.js\");\n/* harmony import */ var _themes_duotoneDark__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../themes/duotoneDark */ \"../../node_modules/prism-react-renderer/themes/duotoneDark/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: _prism_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  theme: _themes_duotoneDark__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Highlight);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNDO0FBQ2U7QUFDWDtBQUNSOztBQUVsQztBQUNBO0FBQ0EsU0FBUyx1REFBSztBQUNkLFNBQVMsMkRBQUs7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLG9FQUFvRTs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVix3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHLFNBQVM7O0FBRVosMEJBQTBCOztBQUUxQiwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxNQUFNOztBQUVkO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUMsQ0FBQyw0Q0FBUzs7QUFFWCwrREFBZSxTQUFTLEVBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL2Rpc3QvaW5kZXguanM/YTY5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcHJpc20gZnJvbSAnLi4vcHJpc20vaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcmlzbSB9IGZyb20gJy4uL3ByaXNtL2luZGV4LmpzJztcbmltcG9ydCB0aGVtZSBmcm9tICcuLi90aGVtZXMvZHVvdG9uZURhcmsnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICAvLyAkRmxvd0ZpeE1lXG4gIFByaXNtOiBwcmlzbSxcbiAgdGhlbWU6IHRoZW1lXG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIG5ld2xpbmVSZSA9IC9cXHJcXG58XFxyfFxcbi87IC8vIEVtcHR5IGxpbmVzIG5lZWQgdG8gY29udGFpbiBhIHNpbmdsZSBlbXB0eSB0b2tlbiwgZGVub3RlZCB3aXRoIHsgZW1wdHk6IHRydWUgfVxuXG52YXIgbm9ybWFsaXplRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgIGxpbmUucHVzaCh7XG4gICAgICB0eXBlczogW1wicGxhaW5cIl0sXG4gICAgICBjb250ZW50OiBcIlxcblwiLFxuICAgICAgZW1wdHk6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gMSAmJiBsaW5lWzBdLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICBsaW5lWzBdLmNvbnRlbnQgPSBcIlxcblwiO1xuICAgIGxpbmVbMF0uZW1wdHkgPSB0cnVlO1xuICB9XG59O1xuXG52YXIgYXBwZW5kVHlwZXMgPSBmdW5jdGlvbiAodHlwZXMsIGFkZCkge1xuICB2YXIgdHlwZXNTaXplID0gdHlwZXMubGVuZ3RoO1xuXG4gIGlmICh0eXBlc1NpemUgPiAwICYmIHR5cGVzW3R5cGVzU2l6ZSAtIDFdID09PSBhZGQpIHtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cblxuICByZXR1cm4gdHlwZXMuY29uY2F0KGFkZCk7XG59OyAvLyBUYWtlcyBhbiBhcnJheSBvZiBQcmlzbSdzIHRva2VucyBhbmQgZ3JvdXBzIHRoZW0gYnkgbGluZSwgdHVybmluZyBwbGFpblxuLy8gc3RyaW5ncyBpbnRvIHRva2VucyBhcyB3ZWxsLiBUb2tlbnMgY2FuIGJlY29tZSByZWN1cnNpdmUgaW4gc29tZSBjYXNlcyxcbi8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlaXIgdHlwZXMgYXJlIGNvbmNhdGVuYXRlZC4gUGxhaW4tc3RyaW5nIHRva2VucyBob3dldmVyXG4vLyBhcmUgYWx3YXlzIG9mIHR5cGUgXCJwbGFpblwiLlxuLy8gVGhpcyBpcyBub3QgcmVjdXJzaXZlIHRvIGF2b2lkIGV4Y2VlZGluZyB0aGUgY2FsbC1zdGFjayBsaW1pdCwgc2luY2UgaXQncyB1bmNsZWFyXG4vLyBob3cgbmVzdGVkIFByaXNtJ3MgdG9rZW5zIGNhbiBiZWNvbWVcblxuXG52YXIgbm9ybWFsaXplVG9rZW5zID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB2YXIgdHlwZUFyclN0YWNrID0gW1tdXTtcbiAgdmFyIHRva2VuQXJyU3RhY2sgPSBbdG9rZW5zXTtcbiAgdmFyIHRva2VuQXJySW5kZXhTdGFjayA9IFswXTtcbiAgdmFyIHRva2VuQXJyU2l6ZVN0YWNrID0gW3Rva2Vucy5sZW5ndGhdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdGFja0luZGV4ID0gMDtcbiAgdmFyIGN1cnJlbnRMaW5lID0gW107XG4gIHZhciBhY2MgPSBbY3VycmVudExpbmVdO1xuXG4gIHdoaWxlIChzdGFja0luZGV4ID4gLTEpIHtcbiAgICB3aGlsZSAoKGkgPSB0b2tlbkFyckluZGV4U3RhY2tbc3RhY2tJbmRleF0rKykgPCB0b2tlbkFyclNpemVTdGFja1tzdGFja0luZGV4XSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG4gICAgICB2YXIgdHlwZXMgPSB0eXBlQXJyU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICB2YXIgdG9rZW5BcnIgPSB0b2tlbkFyclN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5BcnJbaV07IC8vIERldGVybWluZSBjb250ZW50IGFuZCBhcHBlbmQgdHlwZSB0byB0eXBlcyBpZiBuZWNlc3NhcnlcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0eXBlcyA9IHN0YWNrSW5kZXggPiAwID8gdHlwZXMgOiBbXCJwbGFpblwiXTtcbiAgICAgICAgY29udGVudCA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBhcHBlbmRUeXBlcyh0eXBlcywgdG9rZW4udHlwZSk7XG5cbiAgICAgICAgaWYgKHRva2VuLmFsaWFzKSB7XG4gICAgICAgICAgdHlwZXMgPSBhcHBlbmRUeXBlcyh0eXBlcywgdG9rZW4uYWxpYXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICB9IC8vIElmIHRva2VuLmNvbnRlbnQgaXMgYW4gYXJyYXksIGluY3JlYXNlIHRoZSBzdGFjayBkZXB0aCBhbmQgcmVwZWF0IHRoaXMgd2hpbGUtbG9vcFxuXG5cbiAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdGFja0luZGV4Kys7XG4gICAgICAgIHR5cGVBcnJTdGFjay5wdXNoKHR5cGVzKTtcbiAgICAgICAgdG9rZW5BcnJTdGFjay5wdXNoKGNvbnRlbnQpO1xuICAgICAgICB0b2tlbkFyckluZGV4U3RhY2sucHVzaCgwKTtcbiAgICAgICAgdG9rZW5BcnJTaXplU3RhY2sucHVzaChjb250ZW50Lmxlbmd0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBTcGxpdCBieSBuZXdsaW5lc1xuXG5cbiAgICAgIHZhciBzcGxpdEJ5TmV3bGluZXMgPSBjb250ZW50LnNwbGl0KG5ld2xpbmVSZSk7XG4gICAgICB2YXIgbmV3bGluZUNvdW50ID0gc3BsaXRCeU5ld2xpbmVzLmxlbmd0aDtcbiAgICAgIGN1cnJlbnRMaW5lLnB1c2goe1xuICAgICAgICB0eXBlczogdHlwZXMsXG4gICAgICAgIGNvbnRlbnQ6IHNwbGl0QnlOZXdsaW5lc1swXVxuICAgICAgfSk7IC8vIENyZWF0ZSBhIG5ldyBsaW5lIGZvciBlYWNoIHN0cmluZyBvbiBhIG5ldyBsaW5lXG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG5ld2xpbmVDb3VudDsgaSQxKyspIHtcbiAgICAgICAgbm9ybWFsaXplRW1wdHlMaW5lcyhjdXJyZW50TGluZSk7XG4gICAgICAgIGFjYy5wdXNoKGN1cnJlbnRMaW5lID0gW10pO1xuICAgICAgICBjdXJyZW50TGluZS5wdXNoKHtcbiAgICAgICAgICB0eXBlczogdHlwZXMsXG4gICAgICAgICAgY29udGVudDogc3BsaXRCeU5ld2xpbmVzW2kkMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBEZWNyZWF0ZSB0aGUgc3RhY2sgZGVwdGhcblxuXG4gICAgc3RhY2tJbmRleC0tO1xuICAgIHR5cGVBcnJTdGFjay5wb3AoKTtcbiAgICB0b2tlbkFyclN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJySW5kZXhTdGFjay5wb3AoKTtcbiAgICB0b2tlbkFyclNpemVTdGFjay5wb3AoKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUVtcHR5TGluZXMoY3VycmVudExpbmUpO1xuICByZXR1cm4gYWNjO1xufTtcblxudmFyIHRoZW1lVG9EaWN0ID0gZnVuY3Rpb24gKHRoZW1lLCBsYW5ndWFnZSkge1xuICB2YXIgcGxhaW4gPSB0aGVtZS5wbGFpbjsgLy8gJEZsb3dGaXhNZVxuXG4gIHZhciBiYXNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHRoZW1lRGljdCA9IHRoZW1lLnN0eWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGhlbWVFbnRyeSkge1xuICAgIHZhciBsYW5ndWFnZXMgPSB0aGVtZUVudHJ5Lmxhbmd1YWdlcztcbiAgICB2YXIgc3R5bGUgPSB0aGVtZUVudHJ5LnN0eWxlO1xuXG4gICAgaWYgKGxhbmd1YWdlcyAmJiAhbGFuZ3VhZ2VzLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICB0aGVtZUVudHJ5LnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHZhciBhY2NTdHlsZSA9IF9leHRlbmRzKHt9LCBhY2NbdHlwZV0sIHN0eWxlKTtcblxuICAgICAgYWNjW3R5cGVdID0gYWNjU3R5bGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgYmFzZSk7IC8vICRGbG93Rml4TWVcblxuICB0aGVtZURpY3Qucm9vdCA9IHBsYWluOyAvLyAkRmxvd0ZpeE1lXG5cbiAgdGhlbWVEaWN0LnBsYWluID0gX2V4dGVuZHMoe30sIHBsYWluLCB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhlbWVEaWN0O1xufTtcblxuZnVuY3Rpb24gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHRhcmdldFtrXSA9IG9ialtrXTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgSGlnaGxpZ2h0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gSGlnaGxpZ2h0KCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuXG4gICAgQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VGhlbWVEaWN0XCIsIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgaWYgKHRoaXMkMS50aGVtZURpY3QgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy50aGVtZSA9PT0gdGhpcyQxLnByZXZUaGVtZSAmJiBwcm9wcy5sYW5ndWFnZSA9PT0gdGhpcyQxLnByZXZMYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcyQxLnRoZW1lRGljdDtcbiAgICAgIH1cblxuICAgICAgdGhpcyQxLnByZXZUaGVtZSA9IHByb3BzLnRoZW1lO1xuICAgICAgdGhpcyQxLnByZXZMYW5ndWFnZSA9IHByb3BzLmxhbmd1YWdlO1xuICAgICAgdmFyIHRoZW1lRGljdCA9IHByb3BzLnRoZW1lID8gdGhlbWVUb0RpY3QocHJvcHMudGhlbWUsIHByb3BzLmxhbmd1YWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzJDEudGhlbWVEaWN0ID0gdGhlbWVEaWN0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TGluZVByb3BzXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgcmVzdCQxID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVmLCBbXCJrZXlcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImxpbmVcIl0pO1xuICAgICAgdmFyIHJlc3QgPSByZXN0JDE7XG5cbiAgICAgIHZhciBvdXRwdXQgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICBjbGFzc05hbWU6IFwidG9rZW4tbGluZVwiLFxuICAgICAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgICAgICBrZXk6IHVuZGVmaW5lZFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0aGVtZURpY3QgPSB0aGlzJDEuZ2V0VGhlbWVEaWN0KHRoaXMkMS5wcm9wcyk7XG5cbiAgICAgIGlmICh0aGVtZURpY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuc3R5bGUgPSB0aGVtZURpY3QucGxhaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IG91dHB1dC5zdHlsZSAhPT0gdW5kZWZpbmVkID8gX2V4dGVuZHMoe30sIG91dHB1dC5zdHlsZSwgc3R5bGUpIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQua2V5ID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIG91dHB1dC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRTdHlsZUZvclRva2VuXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciB0eXBlcyA9IHJlZi50eXBlcztcbiAgICAgIHZhciBlbXB0eSA9IHJlZi5lbXB0eTtcbiAgICAgIHZhciB0eXBlc1NpemUgPSB0eXBlcy5sZW5ndGg7XG4gICAgICB2YXIgdGhlbWVEaWN0ID0gdGhpcyQxLmdldFRoZW1lRGljdCh0aGlzJDEucHJvcHMpO1xuXG4gICAgICBpZiAodGhlbWVEaWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXNTaXplID09PSAxICYmIHR5cGVzWzBdID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5ID8ge1xuICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXNTaXplID09PSAxICYmICFlbXB0eSkge1xuICAgICAgICByZXR1cm4gdGhlbWVEaWN0W3R5cGVzWzBdXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2VTdHlsZSA9IGVtcHR5ID8ge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgICB9IDoge307IC8vICRGbG93Rml4TWVcblxuICAgICAgdmFyIHR5cGVTdHlsZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoZW1lRGljdFt0eXBlXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbYmFzZVN0eWxlXS5jb25jYXQodHlwZVN0eWxlcykpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VG9rZW5Qcm9wc1wiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgICAgdmFyIHRva2VuID0gcmVmLnRva2VuO1xuICAgICAgdmFyIHJlc3QkMSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlZiwgW1wia2V5XCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJ0b2tlblwiXSk7XG4gICAgICB2YXIgcmVzdCA9IHJlc3QkMTtcblxuICAgICAgdmFyIG91dHB1dCA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0b2tlbiBcIiArIHRva2VuLnR5cGVzLmpvaW4oXCIgXCIpLFxuICAgICAgICBjaGlsZHJlbjogdG9rZW4uY29udGVudCxcbiAgICAgICAgc3R5bGU6IHRoaXMkMS5nZXRTdHlsZUZvclRva2VuKHRva2VuKSxcbiAgICAgICAga2V5OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuc3R5bGUgPSBvdXRwdXQuc3R5bGUgIT09IHVuZGVmaW5lZCA/IF9leHRlbmRzKHt9LCBvdXRwdXQuc3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LmtleSA9IGtleTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBvdXRwdXQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9rZW5pemVcIiwgZnVuY3Rpb24gKFByaXNtLCBjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB0b2tlbnM6IFtdXG4gICAgICB9O1xuICAgICAgUHJpc20uaG9va3MucnVuKFwiYmVmb3JlLXRva2VuaXplXCIsIGVudik7XG4gICAgICB2YXIgdG9rZW5zID0gZW52LnRva2VucyA9IFByaXNtLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcbiAgICAgIFByaXNtLmhvb2tzLnJ1bihcImFmdGVyLXRva2VuaXplXCIsIGVudik7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKENvbXBvbmVudCkgSGlnaGxpZ2h0Ll9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgSGlnaGxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICBIaWdobGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGlnaGxpZ2h0O1xuXG4gIEhpZ2hsaWdodC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBQcmlzbSA9IHJlZi5QcmlzbTtcbiAgICB2YXIgbGFuZ3VhZ2UgPSByZWYubGFuZ3VhZ2U7XG4gICAgdmFyIGNvZGUgPSByZWYuY29kZTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHRoZW1lRGljdCA9IHRoaXMuZ2V0VGhlbWVEaWN0KHRoaXMucHJvcHMpO1xuICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcbiAgICB2YXIgbWl4ZWRUb2tlbnMgPSBncmFtbWFyICE9PSB1bmRlZmluZWQgPyB0aGlzLnRva2VuaXplKFByaXNtLCBjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkgOiBbY29kZV07XG4gICAgdmFyIHRva2VucyA9IG5vcm1hbGl6ZVRva2VucyhtaXhlZFRva2Vucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuKHtcbiAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgY2xhc3NOYW1lOiBcInByaXNtLWNvZGUgbGFuZ3VhZ2UtXCIgKyBsYW5ndWFnZSxcbiAgICAgIHN0eWxlOiB0aGVtZURpY3QgIT09IHVuZGVmaW5lZCA/IHRoZW1lRGljdC5yb290IDoge30sXG4gICAgICBnZXRMaW5lUHJvcHM6IHRoaXMuZ2V0TGluZVByb3BzLFxuICAgICAgZ2V0VG9rZW5Qcm9wczogdGhpcy5nZXRUb2tlblByb3BzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhpZ2hsaWdodDtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgSGlnaGxpZ2h0O1xuZXhwb3J0IHsgZGVmYXVsdFByb3BzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/prism-react-renderer/dist/index.js\n"));

/***/ }),

/***/ "../../node_modules/prism-react-renderer/prism/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/prism-react-renderer/prism/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\n/**\n * prism-react-renderer:\n * This file has been modified to remove:\n * - globals and window dependency\n * - worker support\n * - highlightAll and other element dependent methods\n * - _.hooks helpers\n * - UMD/node-specific hacks\n * It has also been run through prettier\n */\n\n var Prism = (function () {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\treturn _;\n\n}());\n\nvar prism = Prism;\nPrism.default = Prism;\n\n/* This content is auto-generated to include some prismjs language components: */\n\n/* \"prismjs/components/prism-markup\" */\n\nprism.languages.markup = {\n  'comment': {\n    pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n    greedy: true\n  },\n  'prolog': {\n    pattern: /<\\?[\\s\\S]+?\\?>/,\n    greedy: true\n  },\n  'doctype': {\n    // https://www.w3.org/TR/xml/#NT-doctypedecl\n    pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n    greedy: true,\n    inside: {\n      'internal-subset': {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      },\n      'string': {\n        pattern: /\"[^\"]*\"|'[^']*'/,\n        greedy: true\n      },\n      'punctuation': /^<!|>$|[[\\]]/,\n      'doctype-tag': /^DOCTYPE/i,\n      'name': /[^\\s<>'\"]+/\n    }\n  },\n  'cdata': {\n    pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n    greedy: true\n  },\n  'tag': {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: true,\n    inside: {\n      'tag': {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          'punctuation': /^<\\/?/,\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      },\n      'special-attr': [],\n      'attr-value': {\n        pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n        inside: {\n          'punctuation': [{\n            pattern: /^=/,\n            alias: 'attr-equals'\n          }, /\"|'/]\n        }\n      },\n      'punctuation': /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      }\n    }\n  },\n  'entity': [{\n    pattern: /&[\\da-z]{1,8};/i,\n    alias: 'named-entity'\n  }, /&#x?[\\da-f]{1,8};/i]\n};\nprism.languages.markup['tag'].inside['attr-value'].inside['entity'] = prism.languages.markup['entity'];\nprism.languages.markup['doctype'].inside['internal-subset'].inside = prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov\n\nprism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addInlined', {\n  /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */\n  value: function addInlined(tagName, lang) {\n    var includedCdataInside = {};\n    includedCdataInside['language-' + lang] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: true,\n      inside: prism.languages[lang]\n    };\n    includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n    var inside = {\n      'included-cdata': {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: includedCdataInside\n      }\n    };\n    inside['language-' + lang] = {\n      pattern: /[\\s\\S]+/,\n      inside: prism.languages[lang]\n    };\n    var def = {};\n    def[tagName] = {\n      pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () {\n        return tagName;\n      }), 'i'),\n      lookbehind: true,\n      greedy: true,\n      inside: inside\n    };\n    prism.languages.insertBefore('markup', 'cdata', def);\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addAttribute', {\n  /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */\n  value: function (attrName, lang) {\n    prism.languages.markup.tag.inside['special-attr'].push({\n      pattern: RegExp(/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, 'i'),\n      lookbehind: true,\n      inside: {\n        'attr-name': /^[^\\s=]+/,\n        'attr-value': {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            'value': {\n              pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: true,\n              alias: [lang, 'language-' + lang],\n              inside: prism.languages[lang]\n            },\n            'punctuation': [{\n              pattern: /^=/,\n              alias: 'attr-equals'\n            }, /\"|'/]\n          }\n        }\n      }\n    });\n  }\n});\nprism.languages.html = prism.languages.markup;\nprism.languages.mathml = prism.languages.markup;\nprism.languages.svg = prism.languages.markup;\nprism.languages.xml = prism.languages.extend('markup', {});\nprism.languages.ssml = prism.languages.xml;\nprism.languages.atom = prism.languages.xml;\nprism.languages.rss = prism.languages.xml;\n/* \"prismjs/components/prism-bash\" */\n\n(function (Prism) {\n  // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n  // + LC_ALL, RANDOM, REPLY, SECONDS.\n  // + make sure PS1..4 are here as they are not always set,\n  // - some useless things.\n  var envVars = '\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b';\n  var commandAfterHeredoc = {\n    pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n    lookbehind: true,\n    alias: 'punctuation',\n    // this looks reasonably well in all themes\n    inside: null // see below\n\n  };\n  var insideString = {\n    'bash': commandAfterHeredoc,\n    'environment': {\n      pattern: RegExp('\\\\$' + envVars),\n      alias: 'constant'\n    },\n    'variable': [// [0]: Arithmetic Environment\n    {\n      pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n      greedy: true,\n      inside: {\n        // If there is a $ sign at the beginning highlight $(( and )) as variable\n        'variable': [{\n          pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n          lookbehind: true\n        }, /^\\$\\(\\(/],\n        'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n        'operator': /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n        // If there is no $ sign at the beginning highlight (( and )) as punctuation\n        'punctuation': /\\(\\(?|\\)\\)?|,|;/\n      }\n    }, // [1]: Command Substitution\n    {\n      pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n      greedy: true,\n      inside: {\n        'variable': /^\\$\\(|^`|\\)$|`$/\n      }\n    }, // [2]: Brace expansion\n    {\n      pattern: /\\$\\{[^}]+\\}/,\n      greedy: true,\n      inside: {\n        'operator': /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n        'punctuation': /[\\[\\]]/,\n        'environment': {\n          pattern: RegExp('(\\\\{)' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      }\n    }, /\\$(?:\\w+|[#?*!@$])/],\n    // Escape sequences from echo and printf's manuals, and escaped quotes.\n    'entity': /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n  };\n  Prism.languages.bash = {\n    'shebang': {\n      pattern: /^#!\\s*\\/.*/,\n      alias: 'important'\n    },\n    'comment': {\n      pattern: /(^|[^\"{\\\\$])#.*/,\n      lookbehind: true\n    },\n    'function-name': [// a) function foo {\n    // b) foo() {\n    // c) function foo() {\n    // but not “foo {”\n    {\n      // a) and c)\n      pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n      lookbehind: true,\n      alias: 'function'\n    }, {\n      // b)\n      pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n      alias: 'function'\n    }],\n    // Highlight variable names as variables in for and select beginnings.\n    'for-or-select': {\n      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n      alias: 'variable',\n      lookbehind: true\n    },\n    // Highlight variable names as variables in the left-hand part\n    // of assignments (“=” and “+=”).\n    'assign-left': {\n      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?=\\+?=)/,\n      inside: {\n        'environment': {\n          pattern: RegExp('(^|[\\\\s;|&]|[<>]\\\\()' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      },\n      alias: 'variable',\n      lookbehind: true\n    },\n    'string': [// Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, // Here-document with quotes around the tag\n    // → No expansion (so no “inside”).\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'bash': commandAfterHeredoc\n      }\n    }, // “Normal” string\n    {\n      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n      pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n      pattern: /(^|[^$\\\\])'[^']*'/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n      pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n      greedy: true,\n      inside: {\n        'entity': insideString.entity\n      }\n    }],\n    'environment': {\n      pattern: RegExp('\\\\$?' + envVars),\n      alias: 'constant'\n    },\n    'variable': insideString.variable,\n    'function': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'keyword': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n    'builtin': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n      lookbehind: true,\n      // Alias added to make those easier to distinguish from strings.\n      alias: 'class-name'\n    },\n    'boolean': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'file-descriptor': {\n      pattern: /\\B&\\d\\b/,\n      alias: 'important'\n    },\n    'operator': {\n      // Lots of redirections here, but not just that.\n      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n      inside: {\n        'file-descriptor': {\n          pattern: /^\\d/,\n          alias: 'important'\n        }\n      }\n    },\n    'punctuation': /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n    'number': {\n      pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n      lookbehind: true\n    }\n  };\n  commandAfterHeredoc.inside = Prism.languages.bash;\n  /* Patterns in command substitution. */\n\n  var toBeCopied = ['comment', 'function-name', 'for-or-select', 'assign-left', 'string', 'environment', 'function', 'keyword', 'builtin', 'boolean', 'file-descriptor', 'operator', 'punctuation', 'number'];\n  var inside = insideString.variable[1].inside;\n\n  for (var i = 0; i < toBeCopied.length; i++) {\n    inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n  }\n\n  Prism.languages.shell = Prism.languages.bash;\n})(prism);\n/* \"prismjs/components/prism-clike\" */\n\n\nprism.languages.clike = {\n  'comment': [{\n    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    lookbehind: true,\n    greedy: true\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: true,\n    greedy: true\n  }],\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      'punctuation': /[.\\\\]/\n    }\n  },\n  'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'function': /\\b\\w+(?=\\()/,\n  'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\n/* \"prismjs/components/prism-c\" */\n\nprism.languages.c = prism.languages.extend('clike', {\n  'comment': {\n    pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'string': {\n    // https://en.cppreference.com/w/c/language/string_literal\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n    lookbehind: true\n  },\n  'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n  'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n  'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n  'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nprism.languages.insertBefore('c', 'string', {\n  'char': {\n    // https://en.cppreference.com/w/c/language/character_constant\n    pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n    greedy: true\n  }\n});\nprism.languages.insertBefore('c', 'string', {\n  'macro': {\n    // allow for multiline macro definitions\n    // spaces after the # character compile fine with gcc\n    pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property',\n    inside: {\n      'string': [{\n        // highlight the path of the include statement as a string\n        pattern: /^(#\\s*include\\s*)<[^>]+>/,\n        lookbehind: true\n      }, prism.languages.c['string']],\n      'char': prism.languages.c['char'],\n      'comment': prism.languages.c['comment'],\n      'macro-name': [{\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n        lookbehind: true\n      }, {\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n        lookbehind: true,\n        alias: 'function'\n      }],\n      // highlight macro directives as keywords\n      'directive': {\n        pattern: /^(#\\s*)[a-z]+/,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'directive-hash': /^#/,\n      'punctuation': /##|\\\\(?=[\\r\\n])/,\n      'expression': {\n        pattern: /\\S[\\s\\S]*/,\n        inside: prism.languages.c\n      }\n    }\n  }\n});\nprism.languages.insertBefore('c', 'function', {\n  // highlight predefined macros as constants\n  'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete prism.languages.c['boolean'];\n/* \"prismjs/components/prism-cpp\" */\n\n(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:false|true)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + '(?:' + // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(prism);\n/* \"prismjs/components/prism-css\" */\n\n\n(function (Prism) {\n  var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n  Prism.languages.css = {\n    'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n    'atrule': {\n      pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n      inside: {\n        'rule': /^@[\\w-]+/,\n        'selector-function-argument': {\n          pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: true,\n          alias: 'selector'\n        },\n        'keyword': {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: true\n        } // See rest below\n\n      }\n    },\n    'url': {\n      // https://drafts.csswg.org/css-values-3/#urls\n      pattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n      greedy: true,\n      inside: {\n        'function': /^url/i,\n        'punctuation': /^\\(|\\)$/,\n        'string': {\n          pattern: RegExp('^' + string.source + '$'),\n          alias: 'url'\n        }\n      }\n    },\n    'selector': {\n      pattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n      lookbehind: true\n    },\n    'string': {\n      pattern: string,\n      greedy: true\n    },\n    'property': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: true\n    },\n    'important': /!important\\b/i,\n    'function': {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: true\n    },\n    'punctuation': /[(){};:,]/\n  };\n  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n  var markup = Prism.languages.markup;\n\n  if (markup) {\n    markup.tag.addInlined('style', 'css');\n    markup.tag.addAttribute('style', 'css');\n  }\n})(prism);\n/* \"prismjs/components/prism-css-extras\" */\n\n\n(function (Prism) {\n  var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n  var selectorInside;\n  Prism.languages.css.selector = {\n    pattern: Prism.languages.css.selector.pattern,\n    lookbehind: true,\n    inside: selectorInside = {\n      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n      'pseudo-class': /:[-\\w]+/,\n      'class': /\\.[-\\w]+/,\n      'id': /#[-\\w]+/,\n      'attribute': {\n        pattern: RegExp('\\\\[(?:[^[\\\\]\"\\']|' + string.source + ')*\\\\]'),\n        greedy: true,\n        inside: {\n          'punctuation': /^\\[|\\]$/,\n          'case-sensitivity': {\n            pattern: /(\\s)[si]$/i,\n            lookbehind: true,\n            alias: 'keyword'\n          },\n          'namespace': {\n            pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n            lookbehind: true,\n            inside: {\n              'punctuation': /\\|$/\n            }\n          },\n          'attr-name': {\n            pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n            lookbehind: true\n          },\n          'attr-value': [string, {\n            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n            lookbehind: true\n          }],\n          'operator': /[|~*^$]?=/\n        }\n      },\n      'n-th': [{\n        pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n        lookbehind: true,\n        inside: {\n          'number': /[\\dn]+/,\n          'operator': /[+-]/\n        }\n      }, {\n        pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n        lookbehind: true\n      }],\n      'combinator': />|\\+|~|\\|\\|/,\n      // the `tag` token has been existed and removed.\n      // because we can't find a perfect tokenize to match it.\n      // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n      'punctuation': /[(),]/\n    }\n  };\n  Prism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;\n  Prism.languages.insertBefore('css', 'property', {\n    'variable': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n      lookbehind: true\n    }\n  });\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  Prism.languages.insertBefore('css', 'function', {\n    'operator': {\n      pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n      lookbehind: true\n    },\n    // CAREFUL!\n    // Previewers and Inline color use hexcode and color.\n    'hexcode': {\n      pattern: /\\B#[\\da-f]{3,8}\\b/i,\n      alias: 'color'\n    },\n    'color': [{\n      pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n      lookbehind: true\n    }, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    // it's important that there is no boundary assertion after the hex digits\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'number': number\n  });\n})(prism);\n/* \"prismjs/components/prism-javascript\" */\n\n\nprism.languages.javascript = prism.languages.extend('clike', {\n  'class-name': [prism.languages.clike['class-name'], {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n    lookbehind: true\n  }],\n  'keyword': [{\n    pattern: /((?:^|\\})\\s*)catch\\b/,\n    lookbehind: true\n  }, {\n    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n    lookbehind: true\n  }],\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  'number': {\n    pattern: RegExp(/(^|[^\\w$])/.source + '(?:' + ( // constant\n    /NaN|Infinity/.source + '|' + // binary integer\n    /0[bB][01]+(?:_[01]+)*n?/.source + '|' + // octal integer\n    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + '|' + // hexadecimal integer\n    /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + '|' + // decimal bigint\n    /\\d+(?:_\\d+)*n/.source + '|' + // decimal number (integer or float) but no bigint\n    /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + ')' + /(?![\\w$])/.source),\n    lookbehind: true\n  },\n  'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nprism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nprism.languages.insertBefore('javascript', 'keyword', {\n  'regex': {\n    // eslint-disable-next-line regexp/no-dupe-characters-character-class\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n    lookbehind: true,\n    greedy: true,\n    inside: {\n      'regex-source': {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: true,\n        alias: 'language-regex',\n        inside: prism.languages.regex\n      },\n      'regex-delimiter': /^\\/|\\/$/,\n      'regex-flags': /^[a-z]+$/\n    }\n  },\n  // This must be declared before keyword because we use \"function\" inside the look-forward\n  'function-variable': {\n    pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: 'function'\n  },\n  'parameter': [{\n    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }],\n  'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nprism.languages.insertBefore('javascript', 'string', {\n  'hashbang': {\n    pattern: /^#!.*/,\n    greedy: true,\n    alias: 'comment'\n  },\n  'template-string': {\n    pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: true,\n    inside: {\n      'template-punctuation': {\n        pattern: /^`|`$/,\n        alias: 'string'\n      },\n      'interpolation': {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          rest: prism.languages.javascript\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'string-property': {\n    pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property'\n  }\n});\nprism.languages.insertBefore('javascript', 'operator', {\n  'literal-property': {\n    pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n    lookbehind: true,\n    alias: 'property'\n  }\n});\n\nif (prism.languages.markup) {\n  prism.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.\n  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\n  prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');\n}\n\nprism.languages.js = prism.languages.javascript;\n/* \"prismjs/components/prism-coffeescript\" */\n\n(function (Prism) {\n  // Ignore comments starting with { to privilege string interpolation highlighting\n  var comment = /#(?!\\{).+/;\n  var interpolation = {\n    pattern: /#\\{[^}]+\\}/,\n    alias: 'variable'\n  };\n  Prism.languages.coffeescript = Prism.languages.extend('javascript', {\n    'comment': comment,\n    'string': [// Strings are multiline\n    {\n      pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n      greedy: true\n    }, {\n      // Strings are multiline\n      pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n      greedy: true,\n      inside: {\n        'interpolation': interpolation\n      }\n    }],\n    'keyword': /\\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n    'class-member': {\n      pattern: /@(?!\\d)\\w+/,\n      alias: 'variable'\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'comment', {\n    'multiline-comment': {\n      pattern: /###[\\s\\S]+?###/,\n      alias: 'comment'\n    },\n    // Block regexp can contain comments and interpolation\n    'block-regex': {\n      pattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n      alias: 'regex',\n      inside: {\n        'comment': comment,\n        'interpolation': interpolation\n      }\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'string', {\n    'inline-javascript': {\n      pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n      inside: {\n        'delimiter': {\n          pattern: /^`|`$/,\n          alias: 'punctuation'\n        },\n        'script': {\n          pattern: /[\\s\\S]+/,\n          alias: 'language-javascript',\n          inside: Prism.languages.javascript\n        }\n      }\n    },\n    // Block strings\n    'multiline-string': [{\n      pattern: /'''[\\s\\S]*?'''/,\n      greedy: true,\n      alias: 'string'\n    }, {\n      pattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        interpolation: interpolation\n      }\n    }]\n  });\n  Prism.languages.insertBefore('coffeescript', 'keyword', {\n    // Object property\n    'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n  });\n  delete Prism.languages.coffeescript['template-string'];\n  Prism.languages.coffee = Prism.languages.coffeescript;\n})(prism);\n/* \"prismjs/components/prism-yaml\" */\n\n\n(function (Prism) {\n  // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n  // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n  var anchorOrAlias = /[*&][^\\s[\\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n\n  var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n\n  var properties = '(?:' + tag.source + '(?:[ \\t]+' + anchorOrAlias.source + ')?|' + anchorOrAlias.source + '(?:[ \\t]+' + tag.source + ')?)'; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n  // This is a simplified version that doesn't support \"#\" and multiline keys\n  // All these long scarry character classes are simplified versions of YAML's characters\n\n  var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function () {\n    return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n  });\n  var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n  /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function createValuePattern(value, flags) {\n    flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag\n\n    var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function () {\n      return properties;\n    }).replace(/<<value>>/g, function () {\n      return value;\n    });\n    return RegExp(pattern, flags);\n  }\n\n  Prism.languages.yaml = {\n    'scalar': {\n      pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      })),\n      lookbehind: true,\n      alias: 'string'\n    },\n    'comment': /#.*/,\n    'key': {\n      pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      }).replace(/<<key>>/g, function () {\n        return '(?:' + plainKey + '|' + string + ')';\n      })),\n      lookbehind: true,\n      greedy: true,\n      alias: 'atrule'\n    },\n    'directive': {\n      pattern: /(^[ \\t]*)%.+/m,\n      lookbehind: true,\n      alias: 'important'\n    },\n    'datetime': {\n      pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n      lookbehind: true,\n      alias: 'number'\n    },\n    'boolean': {\n      pattern: createValuePattern(/false|true/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'null': {\n      pattern: createValuePattern(/null|~/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'string': {\n      pattern: createValuePattern(string),\n      lookbehind: true,\n      greedy: true\n    },\n    'number': {\n      pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, 'i'),\n      lookbehind: true\n    },\n    'tag': tag,\n    'important': anchorOrAlias,\n    'punctuation': /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n  };\n  Prism.languages.yml = Prism.languages.yaml;\n})(prism);\n/* \"prismjs/components/prism-markdown\" */\n\n\n(function (Prism) {\n  // Allow only one line break\n  var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n  /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */\n\n  function createInline(pattern) {\n    pattern = pattern.replace(/<inner>/g, function () {\n      return inner;\n    });\n    return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n  }\n\n  var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n  var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () {\n    return tableCell;\n  });\n  var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n  Prism.languages.markdown = Prism.languages.extend('markup', {});\n  Prism.languages.insertBefore('markdown', 'prolog', {\n    'front-matter-block': {\n      pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'punctuation': /^---|---$/,\n        'front-matter': {\n          pattern: /\\S+(?:\\s+\\S+)*/,\n          alias: ['yaml', 'language-yaml'],\n          inside: Prism.languages.yaml\n        }\n      }\n    },\n    'blockquote': {\n      // > ...\n      pattern: /^>(?:[\\t ]*>)*/m,\n      alias: 'punctuation'\n    },\n    'table': {\n      pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n      inside: {\n        'table-data-rows': {\n          pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n          lookbehind: true,\n          inside: {\n            'table-data': {\n              pattern: RegExp(tableCell),\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        },\n        'table-line': {\n          pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n          lookbehind: true,\n          inside: {\n            'punctuation': /\\||:?-{3,}:?/\n          }\n        },\n        'table-header-row': {\n          pattern: RegExp('^' + tableRow + '$'),\n          inside: {\n            'table-header': {\n              pattern: RegExp(tableCell),\n              alias: 'important',\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        }\n      }\n    },\n    'code': [{\n      // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n      pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n      lookbehind: true,\n      alias: 'keyword'\n    }, {\n      // ```optional language\n      // code block\n      // ```\n      pattern: /^```[\\s\\S]*?^```$/m,\n      greedy: true,\n      inside: {\n        'code-block': {\n          pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n          lookbehind: true\n        },\n        'code-language': {\n          pattern: /^(```).+/,\n          lookbehind: true\n        },\n        'punctuation': /```/\n      }\n    }],\n    'title': [{\n      // title 1\n      // =======\n      // title 2\n      // -------\n      pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n      alias: 'important',\n      inside: {\n        punctuation: /==+$|--+$/\n      }\n    }, {\n      // # title 1\n      // ###### title 6\n      pattern: /(^\\s*)#.+/m,\n      lookbehind: true,\n      alias: 'important',\n      inside: {\n        punctuation: /^#+|#+$/\n      }\n    }],\n    'hr': {\n      // ***\n      // ---\n      // * * *\n      // -----------\n      pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'list': {\n      // * item\n      // + item\n      // - item\n      // 1. item\n      pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'url-reference': {\n      // [id]: http://example.com \"Optional title\"\n      // [id]: http://example.com 'Optional title'\n      // [id]: http://example.com (Optional title)\n      // [id]: <http://example.com> \"Optional title\"\n      pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n      inside: {\n        'variable': {\n          pattern: /^(!?\\[)[^\\]]+/,\n          lookbehind: true\n        },\n        'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n        'punctuation': /^[\\[\\]!:]|[<>]/\n      },\n      alias: 'url'\n    },\n    'bold': {\n      // **strong**\n      // __strong__\n      // allow one nested instance of italic text using the same delimiter\n      pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^..)[\\s\\S]+(?=..$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /\\*\\*|__/\n      }\n    },\n    'italic': {\n      // *em*\n      // _em_\n      // allow one nested instance of bold text using the same delimiter\n      pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^.)[\\s\\S]+(?=.$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /[*_]/\n      }\n    },\n    'strike': {\n      // ~~strike through~~\n      // ~strike~\n      // eslint-disable-next-line regexp/strict\n      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /~~?/\n      }\n    },\n    'code-snippet': {\n      // `code`\n      // ``code``\n      pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n      lookbehind: true,\n      greedy: true,\n      alias: ['code', 'keyword']\n    },\n    'url': {\n      // [example](http://example.com \"Optional title\")\n      // [example][id]\n      // [example] [id]\n      pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'operator': /^!/,\n        'content': {\n          pattern: /(^\\[)[^\\]]+(?=\\])/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'variable': {\n          pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n          lookbehind: true\n        },\n        'url': {\n          pattern: /(^\\]\\()[^\\s)]+/,\n          lookbehind: true\n        },\n        'string': {\n          pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n          lookbehind: true\n        }\n      }\n    }\n  });\n  ['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n    ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n      if (token !== inside) {\n        Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n      }\n    });\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'markdown' && env.language !== 'md') {\n      return;\n    }\n\n    function walkTokens(tokens) {\n      if (!tokens || typeof tokens === 'string') {\n        return;\n      }\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (token.type !== 'code') {\n          walkTokens(token.content);\n          continue;\n        }\n        /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */\n\n\n        var codeLang = token.content[1];\n        var codeBlock = token.content[3];\n\n        if (codeLang && codeBlock && codeLang.type === 'code-language' && codeBlock.type === 'code-block' && typeof codeLang.content === 'string') {\n          // this might be a language that Prism does not support\n          // do some replacements to support C++, C#, and F#\n          var lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp'); // only use the first word\n\n          lang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n          var alias = 'language-' + lang; // add alias\n\n          if (!codeBlock.alias) {\n            codeBlock.alias = [alias];\n          } else if (typeof codeBlock.alias === 'string') {\n            codeBlock.alias = [codeBlock.alias, alias];\n          } else {\n            codeBlock.alias.push(alias);\n          }\n        }\n      }\n    }\n\n    walkTokens(env.tokens);\n  });\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type !== 'code-block') {\n      return;\n    }\n\n    var codeLang = '';\n\n    for (var i = 0, l = env.classes.length; i < l; i++) {\n      var cls = env.classes[i];\n      var match = /language-(.+)/.exec(cls);\n\n      if (match) {\n        codeLang = match[1];\n        break;\n      }\n    }\n\n    var grammar = Prism.languages[codeLang];\n\n    if (!grammar) {\n      if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n        var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n        env.attributes['id'] = id;\n        Prism.plugins.autoloader.loadLanguages(codeLang, function () {\n          var ele = document.getElementById(id);\n\n          if (ele) {\n            ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n          }\n        });\n      }\n    } else {\n      env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n    }\n  });\n  var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n  /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */\n\n  var KNOWN_ENTITY_NAMES = {\n    'amp': '&',\n    'lt': '<',\n    'gt': '>',\n    'quot': '\"'\n  }; // IE 11 doesn't support `String.fromCodePoint`\n\n  var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n  /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */\n\n  function textContent(html) {\n    // remove all tags\n    var text = html.replace(tagPattern, ''); // decode known entities\n\n    text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n      code = code.toLowerCase();\n\n      if (code[0] === '#') {\n        var value;\n\n        if (code[1] === 'x') {\n          value = parseInt(code.slice(2), 16);\n        } else {\n          value = Number(code.slice(1));\n        }\n\n        return fromCodePoint(value);\n      } else {\n        var known = KNOWN_ENTITY_NAMES[code];\n\n        if (known) {\n          return known;\n        } // unable to decode\n\n\n        return m;\n      }\n    });\n    return text;\n  }\n\n  Prism.languages.md = Prism.languages.markdown;\n})(prism);\n/* \"prismjs/components/prism-graphql\" */\n\n\nprism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:false|true)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /\\b[A-Z]\\w*Input\\b/,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nprism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n/* \"prismjs/components/prism-sql\" */\n\nprism.languages.sql = {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n    lookbehind: true\n  },\n  'variable': [{\n    pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n    greedy: true\n  }, /@[\\w.$]+/],\n  'string': {\n    pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n    greedy: true,\n    lookbehind: true\n  },\n  'identifier': {\n    pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n    greedy: true,\n    lookbehind: true,\n    inside: {\n      'punctuation': /^`|`$/\n    }\n  },\n  'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n  // Should we highlight user defined functions too?\n  'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n  'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n  'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n  'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n  'punctuation': /[;[\\]()`,.]/\n};\n/* \"prismjs/components/prism-js-templates\" */\n\n(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // sql`...`\n  createTemplate('sql', /\\bsql/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {\n          /* noop */\n        }\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(prism);\n/* \"prismjs/components/prism-typescript\" */\n\n\n(function (Prism) {\n  Prism.languages.typescript = Prism.languages.extend('javascript', {\n    'class-name': {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n      lookbehind: true,\n      greedy: true,\n      inside: null // see below\n\n    },\n    'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n  }); // The keywords TypeScript adds to JavaScript\n\n  Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n  /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n  /\\btype\\b(?=\\s*(?:[\\{*]|$))/); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.typescript['parameter'];\n  delete Prism.languages.typescript['literal-property']; // a version of typescript specifically for highlighting types\n\n  var typeInside = Prism.languages.extend('typescript', {});\n  delete typeInside['class-name'];\n  Prism.languages.typescript['class-name'].inside = typeInside;\n  Prism.languages.insertBefore('typescript', 'function', {\n    'decorator': {\n      pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n      inside: {\n        'at': {\n          pattern: /^@/,\n          alias: 'operator'\n        },\n        'function': /^[\\s\\S]+/\n      }\n    },\n    'generic-function': {\n      // e.g. foo<T extends \"bar\" | \"baz\">( ...\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n      greedy: true,\n      inside: {\n        'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          // everything after the first <\n          alias: 'class-name',\n          inside: typeInside\n        }\n      }\n    }\n  });\n  Prism.languages.ts = Prism.languages.typescript;\n})(prism);\n/* \"prismjs/components/prism-js-extras\" */\n\n\n(function (Prism) {\n  Prism.languages.insertBefore('javascript', 'function-variable', {\n    'method-variable': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function-variable'].pattern.source),\n      lookbehind: true,\n      alias: ['function-variable', 'method', 'function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'function', {\n    'method': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function'].source),\n      lookbehind: true,\n      alias: ['function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'constant', {\n    'known-class-name': [{\n      // standard built-ins\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n      pattern: /\\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\\b/,\n      alias: 'class-name'\n    }, {\n      // errors\n      pattern: /\\b(?:[A-Z]\\w*)Error\\b/,\n      alias: 'class-name'\n    }]\n  });\n  /**\n   * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.\n   *\n   * @param {string} source\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function withId(source, flags) {\n    return RegExp(source.replace(/<ID>/g, function () {\n      return /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/.source;\n    }), flags);\n  }\n\n  Prism.languages.insertBefore('javascript', 'keyword', {\n    'imports': {\n      // https://tc39.es/ecma262/#sec-imports\n      pattern: withId(/(\\bimport\\b\\s*)(?:<ID>(?:\\s*,\\s*(?:\\*\\s*as\\s+<ID>|\\{[^{}]*\\}))?|\\*\\s*as\\s+<ID>|\\{[^{}]*\\})(?=\\s*\\bfrom\\b)/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    'exports': {\n      // https://tc39.es/ecma262/#sec-exports\n      pattern: withId(/(\\bexport\\b\\s*)(?:\\*(?:\\s*as\\s+<ID>)?(?=\\s*\\bfrom\\b)|\\{[^{}]*\\})/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    }\n  });\n  Prism.languages.javascript['keyword'].unshift({\n    pattern: /\\b(?:as|default|export|from|import)\\b/,\n    alias: 'module'\n  }, {\n    pattern: /\\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\\b/,\n    alias: 'control-flow'\n  }, {\n    pattern: /\\bnull\\b/,\n    alias: ['null', 'nil']\n  }, {\n    pattern: /\\bundefined\\b/,\n    alias: 'nil'\n  });\n  Prism.languages.insertBefore('javascript', 'operator', {\n    'spread': {\n      pattern: /\\.{3}/,\n      alias: 'operator'\n    },\n    'arrow': {\n      pattern: /=>/,\n      alias: 'operator'\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'punctuation', {\n    'property-access': {\n      pattern: withId(/(\\.\\s*)#?<ID>/.source),\n      lookbehind: true\n    },\n    'maybe-class-name': {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[A-Z][$\\w\\xA0-\\uFFFF]+/,\n      lookbehind: true\n    },\n    'dom': {\n      // this contains only a few commonly used DOM variables\n      pattern: /\\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\\b/,\n      alias: 'variable'\n    },\n    'console': {\n      pattern: /\\bconsole(?=\\s*\\.)/,\n      alias: 'class-name'\n    }\n  }); // add 'maybe-class-name' to tokens which might be a class name\n\n  var maybeClassNameTokens = ['function', 'function-variable', 'method', 'method-variable', 'property-access'];\n\n  for (var i = 0; i < maybeClassNameTokens.length; i++) {\n    var token = maybeClassNameTokens[i];\n    var value = Prism.languages.javascript[token]; // convert regex to object\n\n    if (Prism.util.type(value) === 'RegExp') {\n      value = Prism.languages.javascript[token] = {\n        pattern: value\n      };\n    } // keep in mind that we don't support arrays\n\n\n    var inside = value.inside || {};\n    value.inside = inside;\n    inside['maybe-class-name'] = /^[A-Z][\\s\\S]*/;\n  }\n})(prism);\n/* \"prismjs/components/prism-jsx\" */\n\n\n(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n  var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n  var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n  var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n  /**\n   * @param {string} source\n   * @param {string} [flags]\n   */\n\n  function re(source, flags) {\n    source = source.replace(/<S>/g, function () {\n      return space;\n    }).replace(/<BRACES>/g, function () {\n      return braces;\n    }).replace(/<SPREAD>/g, function () {\n      return spread;\n    });\n    return RegExp(source, flags);\n  }\n\n  spread = re(spread).source;\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n  Prism.languages.insertBefore('inside', 'attr-name', {\n    'spread': {\n      pattern: re(/<SPREAD>/.source),\n      inside: Prism.languages.jsx\n    }\n  }, Prism.languages.jsx.tag);\n  Prism.languages.insertBefore('inside', 'special-attr', {\n    'script': {\n      // Allow for two levels of nesting\n      pattern: re(/=<BRACES>/.source),\n      alias: 'language-javascript',\n      inside: {\n        'script-punctuation': {\n          pattern: /^=(?=\\{)/,\n          alias: 'punctuation'\n        },\n        rest: Prism.languages.jsx\n      }\n    }\n  }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n  var stringifyToken = function (token) {\n    if (!token) {\n      return '';\n    }\n\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function (tokens) {\n    var openedTags = [];\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') ; else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token); // And merge text with adjacent text\n\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n\n    walkTokens(env.tokens);\n  });\n})(prism);\n/* \"prismjs/components/prism-diff\" */\n\n\n(function (Prism) {\n  Prism.languages.diff = {\n    'coord': [// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n    /^(?:\\*{3}|-{3}|\\+{3}).*$/m, // Match \"@@ ... @@\" coord lines in unified diff.\n    /^@@.*@@$/m, // Match coord lines in normal diff (starts with a number).\n    /^\\d.*$/m] // deleted, inserted, unchanged, diff\n\n  };\n  /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */\n\n  var PREFIXES = {\n    'deleted-sign': '-',\n    'deleted-arrow': '<',\n    'inserted-sign': '+',\n    'inserted-arrow': '>',\n    'unchanged': ' ',\n    'diff': '!'\n  }; // add a token for each prefix\n\n  Object.keys(PREFIXES).forEach(function (name) {\n    var prefix = PREFIXES[name];\n    var alias = [];\n\n    if (!/^\\w+$/.test(name)) {\n      // \"deleted-sign\" -> \"deleted\"\n      alias.push(/\\w+/.exec(name)[0]);\n    }\n\n    if (name === 'diff') {\n      alias.push('bold');\n    }\n\n    Prism.languages.diff[name] = {\n      pattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n      alias: alias,\n      inside: {\n        'line': {\n          pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n          lookbehind: true\n        },\n        'prefix': {\n          pattern: /[\\s\\S]/,\n          alias: /\\w+/.exec(name)[0]\n        }\n      }\n    };\n  }); // make prefixes available to Diff plugin\n\n  Object.defineProperty(Prism.languages.diff, 'PREFIXES', {\n    value: PREFIXES\n  });\n})(prism);\n/* \"prismjs/components/prism-git\" */\n\n\nprism.languages.git = {\n  /*\n   * A simple one line comment like in a git status command\n   * For instance:\n   * $ git status\n   * # On branch infinite-scroll\n   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n   * # and have 1 and 2 different commits each, respectively.\n   * nothing to commit (working directory clean)\n   */\n  'comment': /^#.*/m,\n\n  /*\n   * Regexp to match the changed lines in a git diff output. Check the example below.\n   */\n  'deleted': /^[-–].*/m,\n  'inserted': /^\\+.*/m,\n\n  /*\n   * a string (double and simple quote)\n   */\n  'string': /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\n  /*\n   * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n   * For instance:\n   * $ git add file.txt\n   */\n  'command': {\n    pattern: /^.*\\$ git .*$/m,\n    inside: {\n      /*\n       * A git command can contain a parameter starting by a single or a double dash followed by a string\n       * For instance:\n       * $ git diff --cached\n       * $ git log -p\n       */\n      'parameter': /\\s--?\\w+/\n    }\n  },\n\n  /*\n   * Coordinates displayed in a git diff command\n   * For instance:\n   * $ git diff\n   * diff --git file.txt file.txt\n   * index 6214953..1d54a52 100644\n   * --- file.txt\n   * +++ file.txt\n   * @@ -1 +1,2 @@\n   * -Here's my tetx file\n   * +Here's my text file\n   * +And this is the second line\n   */\n  'coord': /^@@.*@@$/m,\n\n  /*\n   * Match a \"commit [SHA1]\" line in a git log output.\n   * For instance:\n   * $ git log\n   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n   * Author: lgiraudel\n   * Date:   Mon Feb 17 11:18:34 2014 +0100\n   *\n   *     Add of a new line\n   */\n  'commit-sha1': /^commit \\w{40}$/m\n};\n/* \"prismjs/components/prism-go\" */\n\nprism.languages.go = prism.languages.extend('clike', {\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n    lookbehind: true,\n    greedy: true\n  },\n  'keyword': /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n  'boolean': /\\b(?:_|false|iota|nil|true)\\b/,\n  'number': [// binary and octal integers\n  /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i, // hexadecimal integers and floats\n  /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i, // decimal integers and floats\n  /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i],\n  'operator': /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n  'builtin': /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nprism.languages.insertBefore('go', 'string', {\n  'char': {\n    pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n    greedy: true\n  }\n});\ndelete prism.languages.go['class-name'];\n/* \"prismjs/components/prism-markup-templating\" */\n\n(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function (env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = tokenStack.length;\n          var placeholder; // Check for existing strings\n\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          tokenStack[i] = match;\n          return placeholder;\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function (env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n\n                replacement.push(middle);\n\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content\n            /* && typeof token.content !== 'string' */\n            ) {\n                walkTokens(token.content);\n              }\n          }\n\n          return tokens;\n        }\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-handlebars\" */\n\n\n(function (Prism) {\n  Prism.languages.handlebars = {\n    'comment': /\\{\\{![\\s\\S]*?\\}\\}/,\n    'delimiter': {\n      pattern: /^\\{\\{\\{?|\\}\\}\\}?$/,\n      alias: 'punctuation'\n    },\n    'string': /([\"'])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n    'boolean': /\\b(?:false|true)\\b/,\n    'block': {\n      pattern: /^(\\s*(?:~\\s*)?)[#\\/]\\S+?(?=\\s*(?:~\\s*)?$|\\s)/,\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'brackets': {\n      pattern: /\\[[^\\]]+\\]/,\n      inside: {\n        punctuation: /\\[|\\]/,\n        variable: /[\\s\\S]+/\n      }\n    },\n    'punctuation': /[!\"#%&':()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n    'variable': /[^!\"#%&'()*+,\\/;<=>@\\[\\\\\\]^`{|}~\\s]+/\n  };\n  Prism.hooks.add('before-tokenize', function (env) {\n    var handlebarsPattern = /\\{\\{\\{[\\s\\S]+?\\}\\}\\}|\\{\\{[\\s\\S]+?\\}\\}/g;\n    Prism.languages['markup-templating'].buildPlaceholders(env, 'handlebars', handlebarsPattern);\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');\n  });\n  Prism.languages.hbs = Prism.languages.handlebars;\n})(prism);\n/* \"prismjs/components/prism-json\" */\n// https://www.json.org/json-en.html\n\n\nprism.languages.json = {\n  'property': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'comment': {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'number': /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'punctuation': /[{}[\\],]/,\n  'operator': /:/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  }\n};\nprism.languages.webmanifest = prism.languages.json;\n/* \"prismjs/components/prism-less\" */\n\n/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */\n\nprism.languages.less = prism.languages.extend('css', {\n  'comment': [/\\/\\*[\\s\\S]*?\\*\\//, {\n    pattern: /(^|[^\\\\])\\/\\/.*/,\n    lookbehind: true\n  }],\n  'atrule': {\n    pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      'punctuation': /[:()]/\n    }\n  },\n  // selectors and mixins are considered the same\n  'selector': {\n    pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      // mixin parameters\n      'variable': /@+[\\w-]+/\n    }\n  },\n  'property': /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n  'operator': /[+\\-*\\/]/\n});\nprism.languages.insertBefore('less', 'property', {\n  'variable': [// Variable declaration (the colon must be consumed!)\n  {\n    pattern: /@[\\w-]+\\s*:/,\n    inside: {\n      'punctuation': /:/\n    }\n  }, // Variable usage\n  /@@?[\\w-]+/],\n  'mixin-usage': {\n    pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n    lookbehind: true,\n    alias: 'function'\n  }\n});\n/* \"prismjs/components/prism-makefile\" */\n\nprism.languages.makefile = {\n  'comment': {\n    pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n    lookbehind: true\n  },\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'builtin-target': {\n    pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n    alias: 'builtin'\n  },\n  'target': {\n    pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n    alias: 'symbol',\n    inside: {\n      'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n    }\n  },\n  'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n  // Directives\n  'keyword': /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n  'function': {\n    pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n    lookbehind: true\n  },\n  'operator': /(?:::|[?:+!])?=|[|@]/,\n  'punctuation': /[:;(){}]/\n};\n/* \"prismjs/components/prism-objectivec\" */\n\nprism.languages.objectivec = prism.languages.extend('c', {\n  'string': {\n    pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n  'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete prism.languages.objectivec['class-name'];\nprism.languages.objc = prism.languages.objectivec;\n/* \"prismjs/components/prism-ocaml\" */\n// https://ocaml.org/manual/lex.html\n\nprism.languages.ocaml = {\n  'comment': {\n    pattern: /\\(\\*[\\s\\S]*?\\*\\)/,\n    greedy: true\n  },\n  'char': {\n    pattern: /'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\n    greedy: true\n  },\n  'string': [{\n    pattern: /\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  }, {\n    pattern: /\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,\n    greedy: true\n  }],\n  'number': [// binary and octal\n  /\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i, // hexadecimal\n  /\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i, // decimal\n  /\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i],\n  'directive': {\n    pattern: /\\B#\\w+/,\n    alias: 'property'\n  },\n  'label': {\n    pattern: /\\B~\\w+/,\n    alias: 'property'\n  },\n  'type-variable': {\n    pattern: /\\B'\\w+/,\n    alias: 'function'\n  },\n  'variant': {\n    pattern: /`\\w+/,\n    alias: 'symbol'\n  },\n  // For the list of keywords and operators,\n  // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\n  'keyword': /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'operator-like-punctuation': {\n    pattern: /\\[[<>|]|[>|]\\]|\\{<|>\\}/,\n    alias: 'punctuation'\n  },\n  // Custom operators are allowed\n  'operator': /\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n  'punctuation': /;;|::|[(){}\\[\\].,:;#]|\\b_\\b/\n};\n/* \"prismjs/components/prism-python\" */\n\nprism.languages.python = {\n  'comment': {\n    pattern: /(^|[^\\\\])#.*/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string-interpolation': {\n    pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n    greedy: true,\n    inside: {\n      'interpolation': {\n        // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n        pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'format-spec': {\n            pattern: /(:)[^:(){}]+(?=\\}$)/,\n            lookbehind: true\n          },\n          'conversion-option': {\n            pattern: /![sra](?=[:}]$)/,\n            alias: 'punctuation'\n          },\n          rest: null\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'triple-quoted-string': {\n    pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n    greedy: true,\n    alias: 'string'\n  },\n  'string': {\n    pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n    greedy: true\n  },\n  'function': {\n    pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n    lookbehind: true\n  },\n  'class-name': {\n    pattern: /(\\bclass\\s+)\\w+/i,\n    lookbehind: true\n  },\n  'decorator': {\n    pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n    lookbehind: true,\n    alias: ['annotation', 'punctuation'],\n    inside: {\n      'punctuation': /\\./\n    }\n  },\n  'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n  'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n  'boolean': /\\b(?:False|None|True)\\b/,\n  'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n  'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\nprism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = prism.languages.python;\nprism.languages.py = prism.languages.python;\n/* \"prismjs/components/prism-reason\" */\n\nprism.languages.reason = prism.languages.extend('clike', {\n  'string': {\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  },\n  // 'class-name' must be matched *after* 'constructor' defined below\n  'class-name': /\\b[A-Z]\\w*/,\n  'keyword': /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n  'operator': /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:asr|land|lor|lsl|lsr|lxor|mod)\\b/\n});\nprism.languages.insertBefore('reason', 'class-name', {\n  'char': {\n    pattern: /'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,\n    greedy: true\n  },\n  // Negative look-ahead prevents from matching things like String.capitalize\n  'constructor': /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n  'label': {\n    pattern: /\\b[a-z]\\w*(?=::)/,\n    alias: 'symbol'\n  }\n}); // We can't match functions property, so let's not even try.\n\ndelete prism.languages.reason.function;\n/* \"prismjs/components/prism-sass\" */\n\n(function (Prism) {\n  Prism.languages.sass = Prism.languages.extend('css', {\n    // Sass comments don't need to be closed, only indented\n    'comment': {\n      pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('sass', 'atrule', {\n    // We want to consume the whole line\n    'atrule-line': {\n      // Includes support for = and + shortcuts\n      pattern: /^(?:[ \\t]*)[@+=].+/m,\n      greedy: true,\n      inside: {\n        'atrule': /(?:@[\\w-]+|[+=])/\n      }\n    }\n  });\n  delete Prism.languages.sass.atrule;\n  var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n  var operator = [/[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/, {\n    pattern: /(\\s)-(?=\\s)/,\n    lookbehind: true\n  }];\n  Prism.languages.insertBefore('sass', 'property', {\n    // We want to consume the whole line\n    'variable-line': {\n      pattern: /^[ \\t]*\\$.+/m,\n      greedy: true,\n      inside: {\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator\n      }\n    },\n    // We want to consume the whole line\n    'property-line': {\n      pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n      greedy: true,\n      inside: {\n        'property': [/[^:\\s]+(?=\\s*:)/, {\n          pattern: /(:)[^:\\s]+/,\n          lookbehind: true\n        }],\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator,\n        'important': Prism.languages.sass.important\n      }\n    }\n  });\n  delete Prism.languages.sass.property;\n  delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,\n  // what's left should be selectors\n\n  Prism.languages.insertBefore('sass', 'punctuation', {\n    'selector': {\n      pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-scss\" */\n\n\nprism.languages.scss = prism.languages.extend('css', {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n    lookbehind: true\n  },\n  'atrule': {\n    pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n    inside: {\n      'rule': /@[\\w-]+/ // See rest below\n\n    }\n  },\n  // url, compassified\n  'url': /(?:[-a-z]+-)?url(?=\\()/i,\n  // CSS selector regex is not appropriate for Sass\n  // since there can be lot more things (var, @ directive, nesting..)\n  // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n  // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n  // can \"pass\" as a selector- e.g: proper#{$erty})\n  // this one was hard to do, so please be careful if you edit this one :)\n  'selector': {\n    // Initial look-ahead is used to prevent matching of blank selectors\n    pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n    inside: {\n      'parent': {\n        pattern: /&/,\n        alias: 'important'\n      },\n      'placeholder': /%[-\\w]+/,\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  },\n  'property': {\n    pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n    inside: {\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  }\n});\nprism.languages.insertBefore('scss', 'atrule', {\n  'keyword': [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i, {\n    pattern: /( )(?:from|through)(?= )/,\n    lookbehind: true\n  }]\n});\nprism.languages.insertBefore('scss', 'important', {\n  // var and interpolated vars\n  'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nprism.languages.insertBefore('scss', 'function', {\n  'module-modifier': {\n    pattern: /\\b(?:as|hide|show|with)\\b/i,\n    alias: 'keyword'\n  },\n  'placeholder': {\n    pattern: /%[-\\w]+/,\n    alias: 'selector'\n  },\n  'statement': {\n    pattern: /\\B!(?:default|optional)\\b/i,\n    alias: 'keyword'\n  },\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  },\n  'operator': {\n    pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n    lookbehind: true\n  }\n});\nprism.languages.scss['atrule'].inside.rest = prism.languages.scss;\n/* \"prismjs/components/prism-stylus\" */\n\n(function (Prism) {\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+)/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  var inside = {\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true\n    },\n    'url': {\n      pattern: /\\burl\\(([\"']?).*?\\1\\)/i,\n      greedy: true\n    },\n    'string': {\n      pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n      greedy: true\n    },\n    'interpolation': null,\n    // See below\n    'func': null,\n    // See below\n    'important': /\\B!(?:important|optional)\\b/i,\n    'keyword': {\n      pattern: /(^|\\s+)(?:(?:else|for|if|return|unless)(?=\\s|$)|@[\\w-]+)/,\n      lookbehind: true\n    },\n    'hexcode': /#[\\da-f]{3,6}/i,\n    'color': [/\\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\\b/i, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'boolean': /\\b(?:false|true)\\b/,\n    'operator': [// We want non-word chars around \"-\" because it is\n    // accepted in property names.\n    /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.{2,3}|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/],\n    'number': number,\n    'punctuation': /[{}()\\[\\];:,]/\n  };\n  inside['interpolation'] = {\n    pattern: /\\{[^\\r\\n}:]+\\}/,\n    alias: 'variable',\n    inside: {\n      'delimiter': {\n        pattern: /^\\{|\\}$/,\n        alias: 'punctuation'\n      },\n      rest: inside\n    }\n  };\n  inside['func'] = {\n    pattern: /[\\w-]+\\([^)]*\\).*/,\n    inside: {\n      'function': /^[^(]+/,\n      rest: inside\n    }\n  };\n  Prism.languages.stylus = {\n    'atrule-declaration': {\n      pattern: /(^[ \\t]*)@.+/m,\n      lookbehind: true,\n      inside: {\n        'atrule': /^@[\\w-]+/,\n        rest: inside\n      }\n    },\n    'variable-declaration': {\n      pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:\\{[^{}]*\\}|\\S.*|$)/m,\n      lookbehind: true,\n      inside: {\n        'variable': /^\\S+/,\n        rest: inside\n      }\n    },\n    'statement': {\n      pattern: /(^[ \\t]*)(?:else|for|if|return|unless)[ \\t].+/m,\n      lookbehind: true,\n      inside: {\n        'keyword': /^\\S+/,\n        rest: inside\n      }\n    },\n    // A property/value pair cannot end with a comma or a brace\n    // It cannot have indented content unless it ended with a semicolon\n    'property-declaration': {\n      pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)(?!\\s)[^{\\r\\n]*(?:;|[^{\\r\\n,]$(?!(?:\\r?\\n|\\r)(?:\\{|\\2[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'property': {\n          pattern: /^[^\\s:]+/,\n          inside: {\n            'interpolation': inside.interpolation\n          }\n        },\n        rest: inside\n      }\n    },\n    // A selector can contain parentheses only as part of a pseudo-element\n    // It can span multiple lines.\n    // It must end with a comma or an accolade or have indented content.\n    'selector': {\n      pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'interpolation': inside.interpolation,\n        'comment': inside.comment,\n        'punctuation': /[{},]/\n      }\n    },\n    'func': inside.func,\n    'string': inside.string,\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true,\n      greedy: true\n    },\n    'interpolation': inside.interpolation,\n    'punctuation': /[{}()\\[\\];:.]/\n  };\n})(prism);\n/* \"prismjs/components/prism-tsx\" */\n\n\n(function (Prism) {\n  var typescript = Prism.util.clone(Prism.languages.typescript);\n  Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.tsx['parameter'];\n  delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.\n  // Idea by https://github.com/karlhorky\n  // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\n  var tag = Prism.languages.tsx.tag;\n  tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n  tag.lookbehind = true;\n})(prism);\n/* \"prismjs/components/prism-wasm\" */\n\n\nprism.languages.wasm = {\n  'comment': [/\\(;[\\s\\S]*?;\\)/, {\n    pattern: /;;.*/,\n    greedy: true\n  }],\n  'string': {\n    pattern: /\"(?:\\\\[\\s\\S]|[^\"\\\\])*\"/,\n    greedy: true\n  },\n  'keyword': [{\n    pattern: /\\b(?:align|offset)=/,\n    inside: {\n      'operator': /=/\n    }\n  }, {\n    pattern: /\\b(?:(?:f32|f64|i32|i64)(?:\\.(?:abs|add|and|ceil|clz|const|convert_[su]\\/i(?:32|64)|copysign|ctz|demote\\/f64|div(?:_[su])?|eqz?|extend_[su]\\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\\/f32|reinterpret\\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\\/f(?:32|64))?|wrap\\/i64|xor))?|memory\\.(?:grow|size))\\b/,\n    inside: {\n      'punctuation': /\\./\n    }\n  }, /\\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\\b/],\n  'variable': /\\$[\\w!#$%&'*+\\-./:<=>?@\\\\^`|~]+/,\n  'number': /[+-]?\\b(?:\\d(?:_?\\d)*(?:\\.\\d(?:_?\\d)*)?(?:[eE][+-]?\\d(?:_?\\d)*)?|0x[\\da-fA-F](?:_?[\\da-fA-F])*(?:\\.[\\da-fA-F](?:_?[\\da-fA-D])*)?(?:[pP][+-]?\\d(?:_?\\d)*)?)\\b|\\binf\\b|\\bnan(?::0x[\\da-fA-F](?:_?[\\da-fA-D])*)?\\b/,\n  'punctuation': /[()]/\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (prism);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL3ByaXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLHFCQUFxQjtBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsTUFBTTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixLQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTyxjQUFjLEtBQUs7QUFDNUM7QUFDQSxPQUFPOztBQUVQLHdCQUF3QixLQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFD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ZXIvcHJpc20vaW5kZXguanM/OTZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBAbGljZW5zZSBNSVQgPGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUPlxuICogQGF1dGhvciBMZWEgVmVyb3UgPGh0dHBzOi8vbGVhLnZlcm91Lm1lPlxuICogQG5hbWVzcGFjZVxuICogQHB1YmxpY1xuICovXG4vKipcbiAqIHByaXNtLXJlYWN0LXJlbmRlcmVyOlxuICogVGhpcyBmaWxlIGhhcyBiZWVuIG1vZGlmaWVkIHRvIHJlbW92ZTpcbiAqIC0gZ2xvYmFscyBhbmQgd2luZG93IGRlcGVuZGVuY3lcbiAqIC0gd29ya2VyIHN1cHBvcnRcbiAqIC0gaGlnaGxpZ2h0QWxsIGFuZCBvdGhlciBlbGVtZW50IGRlcGVuZGVudCBtZXRob2RzXG4gKiAtIF8uaG9va3MgaGVscGVyc1xuICogLSBVTUQvbm9kZS1zcGVjaWZpYyBoYWNrc1xuICogSXQgaGFzIGFsc28gYmVlbiBydW4gdGhyb3VnaCBwcmV0dGllclxuICovXG5cbiB2YXIgUHJpc20gPSAoZnVuY3Rpb24gKCkge1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIHZhcnNcblx0dmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaTtcblx0dmFyIHVuaXF1ZUlkID0gMDtcblxuXHQvLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxuXHR2YXIgcGxhaW5UZXh0R3JhbW1hciA9IHt9O1xuXG5cblx0dmFyIF8gPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcy5cblx0XHQgKlxuXHRcdCAqIEFsbCBmdW5jdGlvbiBpbiB0aGlzIG5hbWVzcGFjZSB0aGF0IGFyZSBub3QgZXhwbGljaXRseSBtYXJrZWQgYXMgX3B1YmxpY18gYXJlIGZvciBfX2ludGVybmFsIHVzZSBvbmx5X18gYW5kIG1heVxuXHRcdCAqIGNoYW5nZSBvciBkaXNhcHBlYXIgYXQgYW55IHRpbWUuXG5cdFx0ICpcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICovXG5cdFx0dXRpbDoge1xuXHRcdFx0ZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUodG9rZW5zKSB7XG5cdFx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIGVuY29kZSh0b2tlbnMuY29udGVudCksIHRva2Vucy5hbGlhcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5tYXAoZW5jb2RlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1xcdTAwYTAvZywgJyAnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gb1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB0eXBlKG51bGwpICAgICAgPT09ICdOdWxsJ1xuXHRcdFx0ICogdHlwZSh1bmRlZmluZWQpID09PSAnVW5kZWZpbmVkJ1xuXHRcdFx0ICogdHlwZSgxMjMpICAgICAgID09PSAnTnVtYmVyJ1xuXHRcdFx0ICogdHlwZSgnZm9vJykgICAgID09PSAnU3RyaW5nJ1xuXHRcdFx0ICogdHlwZSh0cnVlKSAgICAgID09PSAnQm9vbGVhbidcblx0XHRcdCAqIHR5cGUoWzEsIDJdKSAgICA9PT0gJ0FycmF5J1xuXHRcdFx0ICogdHlwZSh7fSkgICAgICAgID09PSAnT2JqZWN0J1xuXHRcdFx0ICogdHlwZShTdHJpbmcpICAgID09PSAnRnVuY3Rpb24nXG5cdFx0XHQgKiB0eXBlKC9hYmMrLykgICAgPT09ICdSZWdFeHAnXG5cdFx0XHQgKi9cblx0XHRcdHR5cGU6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIGEgdW5pcXVlIG51bWJlciBmb3IgdGhlIGdpdmVuIG9iamVjdC4gTGF0ZXIgY2FsbHMgd2lsbCBzdGlsbCByZXR1cm4gdGhlIHNhbWUgbnVtYmVyLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0XHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0XHRcdG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdGlmICghb2JqWydfX2lkJ10pIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9ialsnX19pZCddO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIGludGVuZGVkIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGNsb25lIGxhbmd1YWdlIGRlZmluaXRpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7VH0gb1xuXHRcdFx0ICogQHBhcmFtIHtSZWNvcmQ8bnVtYmVyLCBhbnk+fSBbdmlzaXRlZF1cblx0XHRcdCAqIEByZXR1cm5zIHtUfVxuXHRcdFx0ICogQHRlbXBsYXRlIFRcblx0XHRcdCAqL1xuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uIGRlZXBDbG9uZShvLCB2aXNpdGVkKSB7XG5cdFx0XHRcdHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuXG5cdFx0XHRcdHZhciBjbG9uZTsgdmFyIGlkO1xuXHRcdFx0XHRzd2l0Y2ggKF8udXRpbC50eXBlKG8pKSB7XG5cdFx0XHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lW2tleV0gPSBkZWVwQ2xvbmUob1trZXldLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtpZF0gPSBjbG9uZTtcblxuXHRcdFx0XHRcdFx0KC8qKiBAdHlwZSB7QXJyYXl9ICovKC8qKiBAdHlwZSB7YW55fSAqLyhvKSkpLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVbaV0gPSBkZWVwQ2xvbmUodiwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHJldHVybiBvO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIFByaXNtIGxhbmd1YWdlIG9mIHRoZSBnaXZlbiBlbGVtZW50IHNldCBieSBhIGBsYW5ndWFnZS14eHh4YCBvciBgbGFuZy14eHh4YCBjbGFzcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBubyBsYW5ndWFnZSBpcyBzZXQgZm9yIHRoZSBlbGVtZW50IG9yIHRoZSBlbGVtZW50IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgYG5vbmVgIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRnZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgbSA9IGxhbmcuZXhlYyhlbGVtZW50LmNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0aWYgKG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBtWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICdub25lJztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU2V0cyB0aGUgUHJpc20gYGxhbmd1YWdlLXh4eHhgIGNsYXNzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG5cdFx0XHQgKiBAcmV0dXJucyB7dm9pZH1cblx0XHRcdCAqL1xuXHRcdFx0c2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50LCBsYW5ndWFnZSkge1xuXHRcdFx0XHQvLyByZW1vdmUgYWxsIGBsYW5ndWFnZS14eHh4YCBjbGFzc2VzXG5cdFx0XHRcdC8vICh0aGlzIG1pZ2h0IGxlYXZlIGJlaGluZCBhIGxlYWRpbmcgc3BhY2UpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShSZWdFeHAobGFuZywgJ2dpJyksICcnKTtcblxuXHRcdFx0XHQvLyBhZGQgdGhlIG5ldyBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Ncblx0XHRcdFx0Ly8gKHVzaW5nIGBjbGFzc0xpc3RgIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBzcGFjZXMgZm9yIHVzKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcblx0XHRcdCAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcblx0XHRcdCAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG5cdFx0XHQgKlxuXHRcdFx0ICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG5cdFx0XHQgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcblx0XHRcdCAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcblx0XHRcdCAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuXHRcdFx0XHR2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcblxuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKG5vKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIWRlZmF1bHRBY3RpdmF0aW9uO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBhbGwgY3VycmVudGx5IGxvYWRlZCBsYW5ndWFnZXMgYW5kIHRoZSBzb21lIGhlbHBlciBmdW5jdGlvbnMgdG8gY3JlYXRlIGFuZCBtb2RpZnkgbGFuZ3VhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRsYW5ndWFnZXM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuXHRcdFx0ICovXG5cdFx0XHRwbGFpbjogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHBsYWludGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0eHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2Vcblx0XHRcdCAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIEJlc3QgcHJhY3RpY2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcblx0XHRcdCAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cblx0XHRcdCAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG5cdFx0XHQgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG5cdFx0XHQgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuXHRcdFx0ICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogICAgICdjb21tZW50JzogeyAuLi4gfSxcblx0XHRcdCAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG5cdFx0XHQgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICovXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcblx0XHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGxhbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFVzYWdlXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuXHRcdFx0ICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcblx0XHRcdCAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcblx0XHRcdCAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cblx0XHRcdCAqIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG5cdFx0XHQgKiAgICAgLy8gdG9rZW5cblx0XHRcdCAqIH07XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuXHRcdFx0ICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcblx0XHRcdCAqICAgICAnc3R5bGUnOiB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHRva2VuXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBTcGVjaWFsIGNhc2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG5cdFx0XHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcblx0XHRcdCAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcblx0XHRcdCAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIExpbWl0YXRpb25zXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuXHRcdFx0ICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcblx0XHRcdCAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG5cdFx0XHQgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdCAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG5cdFx0XHQgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuXHRcdFx0ICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdFx0XHQgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcblx0XHRcdCAqXG5cdFx0XHQgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcblx0XHRcdFx0cm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovIChfLmxhbmd1YWdlcyk7XG5cdFx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHQvKiogQHR5cGUge0dyYW1tYXJ9ICovXG5cdFx0XHRcdHZhciByZXQgPSB7fTtcblxuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldFtuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEbyBub3QgaW5zZXJ0IHRva2VuIHdoaWNoIGFsc28gb2NjdXIgaW4gaW5zZXJ0LiBTZWUgIzE1MjVcblx0XHRcdFx0XHRcdGlmICghaW5zZXJ0Lmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0cm9vdFtpbnNpZGVdID0gcmV0O1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG5cdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0XHRERlM6IGZ1bmN0aW9uIERGUyhvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gb1tpXTtcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVR5cGUgPSBfLnV0aWwudHlwZShwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwbHVnaW5zOiB7fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogTG93LWxldmVsIGZ1bmN0aW9uLCBvbmx5IHVzZSBpZiB5b3Uga25vdyB3aGF0IHlvdeKAmXJlIGRvaW5nLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS10b2tlbml6ZWBcblx0XHQgKiAyLiBgYWZ0ZXItdG9rZW5pemVgXG5cdFx0ICogMy4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBwYXNzZWQgdG8gYGdyYW1tYXJgLlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIFByaXNtLmhpZ2hsaWdodCgndmFyIGZvbyA9IHRydWU7JywgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0Jyk7XG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGNvZGU6IHRleHQsXG5cdFx0XHRcdGdyYW1tYXI6IGdyYW1tYXIsXG5cdFx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdFx0fTtcblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0ZW52LnRva2VucyA9IF8udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyKTtcblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci10b2tlbml6ZScsIGVudik7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUoZW52LnRva2VucyksIGVudi5sYW5ndWFnZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG5cdFx0ICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcblx0XHQgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG5cdFx0ICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG5cdFx0ICogICAgIH1cblx0XHQgKiB9KTtcblx0XHQgKi9cblx0XHR0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcblx0XHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXHRcdFx0aWYgKHJlc3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRcdGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9rZW5MaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgdG9rZW5MaXN0LmhlYWQsIHRleHQpO1xuXG5cdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG5cblx0XHRcdHJldHVybiB0b0FycmF5KHRva2VuTGlzdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aG9va3M6IHtcblx0XHRcdGFsbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuXHRcdFx0ICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuXHRcdFx0ICpcblx0XHRcdCAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0XHRob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRcdGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7KSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZW52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRUb2tlbjogVG9rZW5cblx0fTtcblxuXG5cdC8vIFR5cGVzY3JpcHQgbm90ZTpcblx0Ly8gVGhlIGZvbGxvd2luZyBjYW4gYmUgdXNlZCB0byBpbXBvcnQgdGhlIFRva2VuIHR5cGUgaW4gSlNEb2M6XG5cdC8vXG5cdC8vICAgQHR5cGVkZWYge0luc3RhbmNlVHlwZTxpbXBvcnQoXCIuL3ByaXNtLWNvcmVcIilbXCJUb2tlblwiXT59IFRva2VuXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNlZSB7QGxpbmsgVG9rZW4jdHlwZSB0eXBlfVxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuU3RyZWFtfSBjb250ZW50IFNlZSB7QGxpbmsgVG9rZW4jY29udGVudCBjb250ZW50fVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFttYXRjaGVkU3RyPVwiXCJdIEEgY29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tLlxuXHQgKiBAY2xhc3Ncblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBUb2tlbih0eXBlLCBjb250ZW50LCBhbGlhcywgbWF0Y2hlZFN0cikge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgaXMgdXN1YWxseSB0aGUga2V5IG9mIGEgcGF0dGVybiBpbiBhIHtAbGluayBHcmFtbWFyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHQvKipcblx0XHQgKiBUaGUgc3RyaW5ncyBvciB0b2tlbnMgY29udGFpbmVkIGJ5IHRoaXMgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIHdpbGwgYmUgYSB0b2tlbiBzdHJlYW0gaWYgdGhlIHBhdHRlcm4gbWF0Y2hlZCBhbHNvIGRlZmluZWQgYW4gYGluc2lkZWAgZ3JhbW1hci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmcgfCBUb2tlblN0cmVhbX1cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHQvKipcblx0XHQgKiBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHRcdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHRcdHRoaXMubGVuZ3RoID0gKG1hdGNoZWRTdHIgfHwgJycpLmxlbmd0aCB8IDA7XG5cdH1cblxuXHQvKipcblx0ICogQSB0b2tlbiBzdHJlYW0gaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQge0BsaW5rIFRva2VuIFRva2VufSBvYmplY3RzLlxuXHQgKlxuXHQgKiBUb2tlbiBzdHJlYW1zIGhhdmUgdG8gZnVsZmlsbCBhIGZldyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFzc3VtZWQgYnkgbW9zdCBmdW5jdGlvbnMgKG1vc3RseSBpbnRlcm5hbCBvbmVzKSB0aGF0IHByb2Nlc3Ncblx0ICogdGhlbS5cblx0ICpcblx0ICogMS4gTm8gYWRqYWNlbnQgc3RyaW5ncy5cblx0ICogMi4gTm8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogICAgVGhlIG9ubHkgZXhjZXB0aW9uIGhlcmUgaXMgdGhlIHRva2VuIHN0cmVhbSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGVtcHR5IHN0cmluZyBhbmQgbm90aGluZyBlbHNlLlxuXHQgKlxuXHQgKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nIHwgVG9rZW4+fSBUb2tlblN0cmVhbVxuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYW4gSFRNTCByZXByZXNlbnRhdGlvbi5cblx0ICpcblx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0ICogMS4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW4gfCBUb2tlblN0cmVhbX0gbyBUaGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGJlIGNvbnZlcnRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIGN1cnJlbnQgbGFuZ3VhZ2UuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0uXG5cdCAqIEBtZW1iZXJvZiBUb2tlblxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobywgbGFuZ3VhZ2UpIHtcblx0XHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuXHRcdFx0dmFyIHMgPSAnJztcblx0XHRcdG8uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRzICs9IHN0cmluZ2lmeShlLCBsYW5ndWFnZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH1cblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHR0eXBlOiBvLnR5cGUsXG5cdFx0XHRjb250ZW50OiBzdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSksXG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHR9O1xuXG5cdFx0dmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuXHRcdGlmIChhbGlhc2VzKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCd3cmFwJywgZW52KTtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gJyc7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBlbnYuYXR0cmlidXRlcykge1xuXHRcdFx0YXR0cmlidXRlcyArPSAnICcgKyBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArICdcIic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+Jztcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcblx0ICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG5cdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuXHRcdGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG5cdFx0XHR2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG5cdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG5cdCAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuXHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVtYXRjaC5jYXVzZSA9PSB0b2tlbiArICcsJyArIGopIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuXHRcdFx0XHR2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG5cdFx0XHRcdHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG5cdFx0XHRcdHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuXHRcdFx0XHR2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm5PYmoucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuT2JqLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltc3V5XSokLylbMF07XG5cdFx0XHRcdFx0cGF0dGVybk9iai5wYXR0ZXJuID0gUmVnRXhwKHBhdHRlcm5PYmoucGF0dGVybi5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXHRcdFx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5PYmoucGF0dGVybiB8fCBwYXR0ZXJuT2JqO1xuXG5cdFx0XHRcdGZvciAoIC8vIGl0ZXJhdGUgdGhlIHRva2VuIGxpc3QgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgdG9rZW4vc3RyaW5nIHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlICE9PSB0b2tlbkxpc3QudGFpbDtcblx0XHRcdFx0XHRwb3MgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBwb3MgPj0gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRva2VuTGlzdC5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Ly8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXG5cdFx0XHRcdFx0aWYgKGdyZWVkeSkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggPj0gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdHZhciBwID0gcG9zO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG1hdGNoXG5cdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuXHRcdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBwb3MgKGFuZCBwKVxuXHRcdFx0XHRcdFx0cCAtPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRwb3MgPSBwO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBub2RlIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnROb2RlLnZhbHVlIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIGxhc3Qgbm9kZSB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIG1hdGNoXG5cdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHR2YXIgayA9IGN1cnJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHRrICE9PSB0b2tlbkxpc3QudGFpbCAmJiAocCA8IHRvIHx8IHR5cGVvZiBrLnZhbHVlID09PSAnc3RyaW5nJyk7XG5cdFx0XHRcdFx0XHRcdGsgPSBrLm5leHRcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRwICs9IGsudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQtLTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdHN0ciA9IHRleHQuc2xpY2UocG9zLCBwKTtcblx0XHRcdFx0XHRcdG1hdGNoLmluZGV4IC09IHBvcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgMCwgc3RyLCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0dmFyIG1hdGNoU3RyID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKTtcblx0XHRcdFx0XHR2YXIgYWZ0ZXIgPSBzdHIuc2xpY2UoZnJvbSArIG1hdGNoU3RyLmxlbmd0aCk7XG5cblx0XHRcdFx0XHR2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVGcm9tID0gY3VycmVudE5vZGUucHJldjtcblxuXHRcdFx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUZyb20gPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIGJlZm9yZSk7XG5cdFx0XHRcdFx0XHRwb3MgKz0gYmVmb3JlLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcblxuXHRcdFx0XHRcdHZhciB3cmFwcGVkID0gbmV3IFRva2VuKHRva2VuLCBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoU3RyLCBpbnNpZGUpIDogbWF0Y2hTdHIsIGFsaWFzLCBtYXRjaFN0cik7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHdyYXBwZWQpO1xuXG5cdFx0XHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIGN1cnJlbnROb2RlLCBhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHJlbW92ZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG5cdFx0XHRcdFx0XHR2YXIgbmVzdGVkUmVtYXRjaCA9IHtcblx0XHRcdFx0XHRcdFx0Y2F1c2U6IHRva2VuICsgJywnICsgaixcblx0XHRcdFx0XHRcdFx0cmVhY2g6IHJlYWNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcblx0ICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIGhlYWQgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsIH07XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgdGFpbCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IGhlYWQsIG5leHQ6IG51bGwgfTtcblx0XHRoZWFkLm5leHQgPSB0YWlsO1xuXG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLmhlYWQgPSBoZWFkO1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy50YWlsID0gdGFpbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge1R9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMaW5rZWRMaXN0Tm9kZTxUPn0gVGhlIGFkZGVkIG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRBZnRlcihsaXN0LCBub2RlLCB2YWx1ZSkge1xuXHRcdC8vIGFzc3VtZXMgdGhhdCBub2RlICE9IGxpc3QudGFpbCAmJiB2YWx1ZXMubGVuZ3RoID49IDBcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblxuXHRcdHZhciBuZXdOb2RlID0geyB2YWx1ZTogdmFsdWUsIHByZXY6IG5vZGUsIG5leHQ6IG5leHQgfTtcblx0XHRub2RlLm5leHQgPSBuZXdOb2RlO1xuXHRcdG5leHQucHJldiA9IG5ld05vZGU7XG5cdFx0bGlzdC5sZW5ndGgrKztcblxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBjb3VudGAgbm9kZXMgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUuIFRoZSBnaXZlbiBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlUmFuZ2UobGlzdCwgbm9kZSwgY291bnQpIHtcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmIG5leHQgIT09IGxpc3QudGFpbDsgaSsrKSB7XG5cdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdH1cblx0XHRub2RlLm5leHQgPSBuZXh0O1xuXHRcdG5leHQucHJldiA9IG5vZGU7XG5cdFx0bGlzdC5sZW5ndGggLT0gaTtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEByZXR1cm5zIHtUW119XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FycmF5KGxpc3QpIHtcblx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHR2YXIgbm9kZSA9IGxpc3QuaGVhZC5uZXh0O1xuXHRcdHdoaWxlIChub2RlICE9PSBsaXN0LnRhaWwpIHtcblx0XHRcdGFycmF5LnB1c2gobm9kZS52YWx1ZSk7XG5cdFx0XHRub2RlID0gbm9kZS5uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHRyZXR1cm4gXztcblxufSgpKTtcblxudmFyIHByaXNtID0gUHJpc207XG5QcmlzbS5kZWZhdWx0ID0gUHJpc207XG5cbi8qIFRoaXMgY29udGVudCBpcyBhdXRvLWdlbmVyYXRlZCB0byBpbmNsdWRlIHNvbWUgcHJpc21qcyBsYW5ndWFnZSBjb21wb25lbnRzOiAqL1xuXG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrdXBcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAncHJvbG9nJzoge1xuICAgIHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZG9jdHlwZSc6IHtcbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuICAgIHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcm5hbC1zdWJzZXQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcbiAgICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuICAgICAgJ2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG4gICAgICAnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG4gICAgfVxuICB9LFxuICAnY2RhdGEnOiB7XG4gICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAndGFnJzoge1xuICAgIHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0YWcnOiB7XG4gICAgICAgIHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3BlY2lhbC1hdHRyJzogW10sXG4gICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgcGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgcGF0dGVybjogL149LyxcbiAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgfSwgL1wifCcvXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLz8+LyxcbiAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdlbnRpdHknOiBbe1xuICAgIHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcbiAgICBhbGlhczogJ25hbWVkLWVudGl0eSdcbiAgfSwgLyYjeD9bXFxkYS1mXXsxLDh9Oy9pXVxufTtcbnByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcbnByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7IC8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5cbnByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZElubGluZWQnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYDxzdHlsZT5gIHRhZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgKiBjYXNlIGluc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmxpbmVkKHRhZ05hbWUsIGxhbmcpIHtcbiAgICB2YXIgaW5jbHVkZWRDZGF0YUluc2lkZSA9IHt9O1xuICAgIGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC8oXjwhXFxbQ0RBVEFcXFspW1xcc1xcU10rPyg/PVxcXVxcXT4kKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgfTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydjZGF0YSddID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG4gICAgdmFyIGluc2lkZSA9IHtcbiAgICAgICdpbmNsdWRlZC1jZGF0YSc6IHtcbiAgICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgICBpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgdmFyIGRlZiA9IHt9O1xuICAgIGRlZlt0YWdOYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWU7XG4gICAgICB9KSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVxuICAgIH07XG4gICAgcHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG4gIC8qKlxuICAgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcbiAgICBwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXCInXFxzXSkvLnNvdXJjZSArICcoPzonICsgYXR0ck5hbWUgKyAnKScgKyAvXFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcbiAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLz1bXFxzXFxTXSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3ZhbHVlJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcbiAgICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuICAgICAgICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IFt7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgIGFsaWFzOiAnYXR0ci1lcXVhbHMnXG4gICAgICAgICAgICB9LCAvXCJ8Jy9dXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwO1xucHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5wcmlzbS5sYW5ndWFnZXMuc3ZnID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbnByaXNtLmxhbmd1YWdlcy54bWwgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG5wcmlzbS5sYW5ndWFnZXMuc3NtbCA9IHByaXNtLmxhbmd1YWdlcy54bWw7XG5wcmlzbS5sYW5ndWFnZXMuYXRvbSA9IHByaXNtLmxhbmd1YWdlcy54bWw7XG5wcmlzbS5sYW5ndWFnZXMucnNzID0gcHJpc20ubGFuZ3VhZ2VzLnhtbDtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWJhc2hcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vICQgc2V0IHwgZ3JlcCAnXltBLVpdW15bOnNwYWNlOl1dKj0nIHwgY3V0IC1kPSAtZjEgfCB0ciAnXFxuJyAnfCdcbiAgLy8gKyBMQ19BTEwsIFJBTkRPTSwgUkVQTFksIFNFQ09ORFMuXG4gIC8vICsgbWFrZSBzdXJlIFBTMS4uNCBhcmUgaGVyZSBhcyB0aGV5IGFyZSBub3QgYWx3YXlzIHNldCxcbiAgLy8gLSBzb21lIHVzZWxlc3MgdGhpbmdzLlxuICB2YXIgZW52VmFycyA9ICdcXFxcYig/OkJBU0h8QkFTSE9QVFN8QkFTSF9BTElBU0VTfEJBU0hfQVJHQ3xCQVNIX0FSR1Z8QkFTSF9DTURTfEJBU0hfQ09NUExFVElPTl9DT01QQVRfRElSfEJBU0hfTElORU5PfEJBU0hfUkVNQVRDSHxCQVNIX1NPVVJDRXxCQVNIX1ZFUlNJTkZPfEJBU0hfVkVSU0lPTnxDT0xPUlRFUk18Q09MVU1OU3xDT01QX1dPUkRCUkVBS1N8REJVU19TRVNTSU9OX0JVU19BRERSRVNTfERFRkFVTFRTX1BBVEh8REVTS1RPUF9TRVNTSU9OfERJUlNUQUNLfERJU1BMQVl8RVVJRHxHRE1TRVNTSU9OfEdETV9MQU5HfEdOT01FX0tFWVJJTkdfQ09OVFJPTHxHTk9NRV9LRVlSSU5HX1BJRHxHUEdfQUdFTlRfSU5GT3xHUk9VUFN8SElTVENPTlRST0x8SElTVEZJTEV8SElTVEZJTEVTSVpFfEhJU1RTSVpFfEhPTUV8SE9TVE5BTUV8SE9TVFRZUEV8SUZTfElOU1RBTkNFfEpPQnxMQU5HfExBTkdVQUdFfExDX0FERFJFU1N8TENfQUxMfExDX0lERU5USUZJQ0FUSU9OfExDX01FQVNVUkVNRU5UfExDX01PTkVUQVJZfExDX05BTUV8TENfTlVNRVJJQ3xMQ19QQVBFUnxMQ19URUxFUEhPTkV8TENfVElNRXxMRVNTQ0xPU0V8TEVTU09QRU58TElORVN8TE9HTkFNRXxMU19DT0xPUlN8TUFDSFRZUEV8TUFJTENIRUNLfE1BTkRBVE9SWV9QQVRIfE5PX0FUX0JSSURHRXxPTERQV0R8T1BURVJSfE9QVElORHxPUkJJVF9TT0NLRVRESVJ8T1NUWVBFfFBBUEVSU0laRXxQQVRIfFBJUEVTVEFUVVN8UFBJRHxQUzF8UFMyfFBTM3xQUzR8UFdEfFJBTkRPTXxSRVBMWXxTRUNPTkRTfFNFTElOVVhfSU5JVHxTRVNTSU9OfFNFU1NJT05UWVBFfFNFU1NJT05fTUFOQUdFUnxTSEVMTHxTSEVMTE9QVFN8U0hMVkx8U1NIX0FVVEhfU09DS3xURVJNfFVJRHxVUFNUQVJUX0VWRU5UU3xVUFNUQVJUX0lOU1RBTkNFfFVQU1RBUlRfSk9CfFVQU1RBUlRfU0VTU0lPTnxVU0VSfFdJTkRPV0lEfFhBVVRIT1JJVFl8WERHX0NPTkZJR19ESVJTfFhER19DVVJSRU5UX0RFU0tUT1B8WERHX0RBVEFfRElSU3xYREdfR1JFRVRFUl9EQVRBX0RJUnxYREdfTUVOVV9QUkVGSVh8WERHX1JVTlRJTUVfRElSfFhER19TRUFUfFhER19TRUFUX1BBVEh8WERHX1NFU1NJT05fREVTS1RPUHxYREdfU0VTU0lPTl9JRHxYREdfU0VTU0lPTl9QQVRIfFhER19TRVNTSU9OX1RZUEV8WERHX1ZUTlJ8WE1PRElGSUVSUylcXFxcYic7XG4gIHZhciBjb21tYW5kQWZ0ZXJIZXJlZG9jID0ge1xuICAgIHBhdHRlcm46IC8oXihbXCInXT8pXFx3K1xcMilbIFxcdF0rXFxTLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdwdW5jdHVhdGlvbicsXG4gICAgLy8gdGhpcyBsb29rcyByZWFzb25hYmx5IHdlbGwgaW4gYWxsIHRoZW1lc1xuICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblxuICB9O1xuICB2YXIgaW5zaWRlU3RyaW5nID0ge1xuICAgICdiYXNoJzogY29tbWFuZEFmdGVySGVyZWRvYyxcbiAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFwkJyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IFsvLyBbMF06IEFyaXRobWV0aWMgRW52aXJvbm1lbnRcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvXFwkP1xcKFxcKFtcXHNcXFNdKz9cXClcXCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgJCBzaWduIGF0IHRoZSBiZWdpbm5pbmcgaGlnaGxpZ2h0ICQoKCBhbmQgKSkgYXMgdmFyaWFibGVcbiAgICAgICAgJ3ZhcmlhYmxlJzogW3tcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXCRcXChcXChbXFxzXFxTXSspXFwpXFwpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sIC9eXFwkXFwoXFwoL10sXG4gICAgICAgICdudW1iZXInOiAvXFxiMHhbXFxkQS1GYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OltFZV0tP1xcZCspPy8sXG4gICAgICAgIC8vIE9wZXJhdG9ycyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNocmVmLmh0bWwjU2hlbGwtQXJpdGhtZXRpY1xuICAgICAgICAnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fDw8PT98Pj49P3wmJnxcXHxcXHx8Wz0hK1xcLSovJTw+XiZ8XT0/fFs/fjpdLyxcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gJCBzaWduIGF0IHRoZSBiZWdpbm5pbmcgaGlnaGxpZ2h0ICgoIGFuZCApKSBhcyBwdW5jdHVhdGlvblxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwoXFwoP3xcXClcXCk/fCx8Oy9cbiAgICAgIH1cbiAgICB9LCAvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxcKCg/OlxcKFteKV0rXFwpfFteKCldKStcXCl8YFteYF0rYC8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzogL15cXCRcXCh8XmB8XFwpJHxgJC9cbiAgICAgIH1cbiAgICB9LCAvLyBbMl06IEJyYWNlIGV4cGFuc2lvblxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXCRcXHtbXn1dK1xcfS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ29wZXJhdG9yJzogLzpbLT0/K10/fFshXFwvXXwjIz98JSU/fFxcXlxcXj98LCw/LyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1tcXFtcXF1dLyxcbiAgICAgICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKFxcXFx7KScgKyBlbnZWYXJzKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCAvXFwkKD86XFx3K3xbIz8qIUAkXSkvXSxcbiAgICAvLyBFc2NhcGUgc2VxdWVuY2VzIGZyb20gZWNobyBhbmQgcHJpbnRmJ3MgbWFudWFscywgYW5kIGVzY2FwZWQgcXVvdGVzLlxuICAgICdlbnRpdHknOiAvXFxcXCg/OlthYmNlRWZucnR2XFxcXFwiXXxPP1swLTddezEsM318VVswLTlhLWZBLUZdezh9fHVbMC05YS1mQS1GXXs0fXx4WzAtOWEtZkEtRl17MSwyfSkvXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5iYXNoID0ge1xuICAgICdzaGViYW5nJzoge1xuICAgICAgcGF0dGVybjogL14jIVxccypcXC8uKi8sXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteXCJ7XFxcXCRdKSMuKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZnVuY3Rpb24tbmFtZSc6IFsvLyBhKSBmdW5jdGlvbiBmb28ge1xuICAgIC8vIGIpIGZvbygpIHtcbiAgICAvLyBjKSBmdW5jdGlvbiBmb28oKSB7XG4gICAgLy8gYnV0IG5vdCDigJxmb28ge+KAnVxuICAgIHtcbiAgICAgIC8vIGEpIGFuZCBjKVxuICAgICAgcGF0dGVybjogLyhcXGJmdW5jdGlvblxccyspW1xcdy1dKyg/PSg/OlxccypcXCg/OlxccypcXCkpP1xccypcXHspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH0sIHtcbiAgICAgIC8vIGIpXG4gICAgICBwYXR0ZXJuOiAvXFxiW1xcdy1dKyg/PVxccypcXChcXHMqXFwpXFxzKlxceykvLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9XSxcbiAgICAvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIGZvciBhbmQgc2VsZWN0IGJlZ2lubmluZ3MuXG4gICAgJ2Zvci1vci1zZWxlY3QnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmZvcnxzZWxlY3QpXFxzKylcXHcrKD89XFxzK2luXFxzKS8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gdGhlIGxlZnQtaGFuZCBwYXJ0XG4gICAgLy8gb2YgYXNzaWdubWVudHMgKOKAnD3igJ0gYW5kIOKAnCs94oCdKS5cbiAgICAnYXNzaWduLWxlZnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKClcXHcrKD89XFwrPz0pLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCcoXnxbXFxcXHM7fCZdfFs8Pl1cXFxcKCknICsgZW52VmFycyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ2NvbnN0YW50J1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZScsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnc3RyaW5nJzogWy8vIFN1cHBvcnQgZm9yIEhlcmUtZG9jdW1lbnRzIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcmVfZG9jdW1lbnRcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoXFx3KylcXHNbXFxzXFxTXSo/KD86XFxyP1xcbnxcXHIpXFwyLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVN0cmluZ1xuICAgIH0sIC8vIEhlcmUtZG9jdW1lbnQgd2l0aCBxdW90ZXMgYXJvdW5kIHRoZSB0YWdcbiAgICAvLyDihpIgTm8gZXhwYW5zaW9uIChzbyBubyDigJxpbnNpZGXigJ0pLlxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShbXCInXSkoXFx3KylcXDJcXHNbXFxzXFxTXSo/KD86XFxyP1xcbnxcXHIpXFwzLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Jhc2gnOiBjb21tYW5kQWZ0ZXJIZXJlZG9jXG4gICAgICB9XG4gICAgfSwgLy8g4oCcTm9ybWFs4oCdIHN0cmluZ1xuICAgIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0oPzpcXFxcXFxcXCkqKVwiKD86XFxcXFtcXHNcXFNdfFxcJFxcKFteKV0rXFwpfFxcJCg/IVxcKCl8YFteYF0rYHxbXlwiXFxcXGAkXSkqXCIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2luZ2xlLVF1b3Rlcy5odG1sXG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcbiAgICAgIHBhdHRlcm46IC9cXCQnKD86W14nXFxcXF18XFxcXFtcXHNcXFNdKSonLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZW50aXR5JzogaW5zaWRlU3RyaW5nLmVudGl0eVxuICAgICAgfVxuICAgIH1dLFxuICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICB9LFxuICAgICd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGpvYnN8am9pbnxraWxsfGtpbGxhbGx8bGVzc3xsaW5rfGxufGxvY2F0ZXxsb2duYW1lfGxvZ3JvdGF0ZXxsb29rfGxwY3xscHJ8bHByaW50fGxwcmludGR8bHByaW50cXxscHJtfGxzfGxzb2Z8bHlueHxtYWtlfG1hbnxtY3xtZGFkbXxta2NvbmZpZ3xta2Rpcnxta2UyZnN8bWtmaWZvfG1rZnN8bWtpc29mc3xta25vZHxta3N3YXB8bW12fG1vcmV8bW9zdHxtb3VudHxtdG9vbHN8bXRyfG11dHR8bXZ8bmFub3xuY3xuZXRzdGF0fG5pY2V8bmx8bm9kZXxub2h1cHxub3RpZnktc2VuZHxucG18bnNsb29rdXB8b3B8b3BlbnxwYXJ0ZWR8cGFzc3dkfHBhc3RlfHBhdGhjaGt8cGluZ3xwa2lsbHxwbnBtfHBvZG1hbnxwb2RtYW4tY29tcG9zZXxwb3BkfHByfHByaW50Y2FwfHByaW50ZW52fHBzfHB1c2hkfHB2fHF1b3RhfHF1b3RhY2hlY2t8cXVvdGFjdGx8cmFtfHJhcnxyY3B8cmVib290fHJlbXN5bmN8cmVuYW1lfHJlbmljZXxyZXZ8cm18cm1kaXJ8cnBtfHJzeW5jfHNjcHxzY3JlZW58c2RpZmZ8c2VkfHNlbmRtYWlsfHNlcXxzZXJ2aWNlfHNmdHB8c2h8c2hlbGxjaGVja3xzaHVmfHNodXRkb3dufHNsZWVwfHNsb2NhdGV8c29ydHxzcGxpdHxzc2h8c3RhdHxzdHJhY2V8c3V8c3Vkb3xzdW18c3VzcGVuZHxzd2Fwb258c3luY3x0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2tleXdvcmQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcbiAgICAnYnVpbHRpbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgLy8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZmlsZS1kZXNjcmlwdG9yJzoge1xuICAgICAgcGF0dGVybjogL1xcQiZcXGRcXGIvLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICAvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cbiAgICAgIHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmaWxlLWRlc2NyaXB0b3InOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXGQvLFxuICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfVxuICB9O1xuICBjb21tYW5kQWZ0ZXJIZXJlZG9jLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5iYXNoO1xuICAvKiBQYXR0ZXJucyBpbiBjb21tYW5kIHN1YnN0aXR1dGlvbi4gKi9cblxuICB2YXIgdG9CZUNvcGllZCA9IFsnY29tbWVudCcsICdmdW5jdGlvbi1uYW1lJywgJ2Zvci1vci1zZWxlY3QnLCAnYXNzaWduLWxlZnQnLCAnc3RyaW5nJywgJ2Vudmlyb25tZW50JywgJ2Z1bmN0aW9uJywgJ2tleXdvcmQnLCAnYnVpbHRpbicsICdib29sZWFuJywgJ2ZpbGUtZGVzY3JpcHRvcicsICdvcGVyYXRvcicsICdwdW5jdHVhdGlvbicsICdudW1iZXInXTtcbiAgdmFyIGluc2lkZSA9IGluc2lkZVN0cmluZy52YXJpYWJsZVsxXS5pbnNpZGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0JlQ29waWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zaWRlW3RvQmVDb3BpZWRbaV1dID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2hbdG9CZUNvcGllZFtpXV07XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMuc2hlbGwgPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNsaWtlXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gICdjb21tZW50JzogW3tcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHJhaXQpXFxzK3xcXGJjYXRjaFxccytcXCgpW1xcdy5cXFxcXSsvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG4gICAgfVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fG51bGx8cmV0dXJufHRocm93fHRyeXx3aGlsZSlcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJcXHcrKD89XFwoKS8sXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLFxuICAnb3BlcmF0b3InOiAvWzw+XT0/fFshPV09Pz0/fC0tP3xcXCtcXCs/fCYmP3xcXHxcXHw/fFs/Ki9+XiVdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMuYyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwvXFwvKD86W15cXHJcXG5cXFxcXXxcXFxcKD86XFxyXFxuP3xcXG58KD8hW1xcclxcbl0pKSkqfFxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2MvbGFuZ3VhZ2Uvc3RyaW5nX2xpdGVyYWxcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzplbnVtfHN0cnVjdClcXHMrKD86X19hdHRyaWJ1dGVfX1xccypcXChcXChbXFxzXFxTXSo/XFwpXFwpXFxzKik/KVxcdyt8XFxiW2Etel1cXHcqX3RcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86X0FsaWduYXN8X0FsaWdub2Z8X0F0b21pY3xfQm9vbHxfQ29tcGxleHxfR2VuZXJpY3xfSW1hZ2luYXJ5fF9Ob3JldHVybnxfU3RhdGljX2Fzc2VydHxfVGhyZWFkX2xvY2FsfF9fYXR0cmlidXRlX198YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdHJ1Y3R8c3dpdGNofHR5cGVkZWZ8dHlwZW9mfHVuaW9ufHVuc2lnbmVkfHZvaWR8dm9sYXRpbGV8d2hpbGUpXFxiLyxcbiAgJ2Z1bmN0aW9uJzogL1xcYlthLXpfXVxcdyooPz1cXHMqXFwoKS9pLFxuICAnbnVtYmVyJzogLyg/OlxcYjB4KD86W1xcZGEtZl0rKD86XFwuW1xcZGEtZl0qKT98XFwuW1xcZGEtZl0rKSg/OnBbKy1dP1xcZCspP3woPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/KVtmdWxdezAsNH0vaSxcbiAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3wtPnwoWy0rJnw6XSlcXDF8Wz86fl18Wy0rKi8lJnxeIT08Pl09Py9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdzdHJpbmcnLCB7XG4gICdjaGFyJzoge1xuICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2MvbGFuZ3VhZ2UvY2hhcmFjdGVyX2NvbnN0YW50XG4gICAgcGF0dGVybjogLycoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSl7MCwzMn0nLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ3N0cmluZycsIHtcbiAgJ21hY3JvJzoge1xuICAgIC8vIGFsbG93IGZvciBtdWx0aWxpbmUgbWFjcm8gZGVmaW5pdGlvbnNcbiAgICAvLyBzcGFjZXMgYWZ0ZXIgdGhlICMgY2hhcmFjdGVyIGNvbXBpbGUgZmluZSB3aXRoIGdjY1xuICAgIHBhdHRlcm46IC8oXltcXHQgXSopI1xccypbYS16XSg/OlteXFxyXFxuXFxcXC9dfFxcLyg/IVxcKil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKi9pbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5JyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdzdHJpbmcnOiBbe1xuICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHBhdGggb2YgdGhlIGluY2x1ZGUgc3RhdGVtZW50IGFzIGEgc3RyaW5nXG4gICAgICAgIHBhdHRlcm46IC9eKCNcXHMqaW5jbHVkZVxccyopPFtePl0rPi8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH0sIHByaXNtLmxhbmd1YWdlcy5jWydzdHJpbmcnXV0sXG4gICAgICAnY2hhcic6IHByaXNtLmxhbmd1YWdlcy5jWydjaGFyJ10sXG4gICAgICAnY29tbWVudCc6IHByaXNtLmxhbmd1YWdlcy5jWydjb21tZW50J10sXG4gICAgICAnbWFjcm8tbmFtZSc6IFt7XG4gICAgICAgIHBhdHRlcm46IC8oXiNcXHMqZGVmaW5lXFxzKylcXHcrXFxiKD8hXFwoKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHBhdHRlcm46IC8oXiNcXHMqZGVmaW5lXFxzKylcXHcrXFxiKD89XFwoKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgICAgfV0sXG4gICAgICAvLyBoaWdobGlnaHQgbWFjcm8gZGlyZWN0aXZlcyBhcyBrZXl3b3Jkc1xuICAgICAgJ2RpcmVjdGl2ZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oI1xccyopW2Etel0rLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgICAgfSxcbiAgICAgICdkaXJlY3RpdmUtaGFzaCc6IC9eIy8sXG4gICAgICAncHVuY3R1YXRpb24nOiAvIyN8XFxcXCg/PVtcXHJcXG5dKS8sXG4gICAgICAnZXhwcmVzc2lvbic6IHtcbiAgICAgICAgcGF0dGVybjogL1xcU1tcXHNcXFNdKi8sXG4gICAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdmdW5jdGlvbicsIHtcbiAgLy8gaGlnaGxpZ2h0IHByZWRlZmluZWQgbWFjcm9zIGFzIGNvbnN0YW50c1xuICAnY29uc3RhbnQnOiAvXFxiKD86RU9GfE5VTEx8U0VFS19DVVJ8U0VFS19FTkR8U0VFS19TRVR8X19EQVRFX198X19GSUxFX198X19MSU5FX198X19USU1FU1RBTVBfX3xfX1RJTUVfX3xfX2Z1bmNfX3xzdGRlcnJ8c3RkaW58c3Rkb3V0KVxcYi9cbn0pO1xuZGVsZXRlIHByaXNtLmxhbmd1YWdlcy5jWydib29sZWFuJ107XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHBcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBrZXl3b3JkID0gL1xcYig/OmFsaWduYXN8YWxpZ25vZnxhc218YXV0b3xib29sfGJyZWFrfGNhc2V8Y2F0Y2h8Y2hhcnxjaGFyMTZfdHxjaGFyMzJfdHxjaGFyOF90fGNsYXNzfGNvX2F3YWl0fGNvX3JldHVybnxjb195aWVsZHxjb21wbHxjb25jZXB0fGNvbnN0fGNvbnN0X2Nhc3R8Y29uc3RldmFsfGNvbnN0ZXhwcnxjb25zdGluaXR8Y29udGludWV8ZGVjbHR5cGV8ZGVmYXVsdHxkZWxldGV8ZG98ZG91YmxlfGR5bmFtaWNfY2FzdHxlbHNlfGVudW18ZXhwbGljaXR8ZXhwb3J0fGV4dGVybnxmaW5hbHxmbG9hdHxmb3J8ZnJpZW5kfGdvdG98aWZ8aW1wb3J0fGlubGluZXxpbnR8aW50MTZfdHxpbnQzMl90fGludDY0X3R8aW50OF90fGxvbmd8bW9kdWxlfG11dGFibGV8bmFtZXNwYWNlfG5ld3xub2V4Y2VwdHxudWxscHRyfG9wZXJhdG9yfG92ZXJyaWRlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWdpc3RlcnxyZWludGVycHJldF9jYXN0fHJlcXVpcmVzfHJldHVybnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdGF0aWNfYXNzZXJ0fHN0YXRpY19jYXN0fHN0cnVjdHxzd2l0Y2h8dGVtcGxhdGV8dGhpc3x0aHJlYWRfbG9jYWx8dGhyb3d8dHJ5fHR5cGVkZWZ8dHlwZWlkfHR5cGVuYW1lfHVpbnQxNl90fHVpbnQzMl90fHVpbnQ2NF90fHVpbnQ4X3R8dW5pb258dW5zaWduZWR8dXNpbmd8dmlydHVhbHx2b2lkfHZvbGF0aWxlfHdjaGFyX3R8d2hpbGUpXFxiLztcbiAgdmFyIG1vZE5hbWUgPSAvXFxiKD8hPGtleXdvcmQ+KVxcdysoPzpcXHMqXFwuXFxzKlxcdyspKlxcYi8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGtleXdvcmQuc291cmNlO1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNwcCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG4gICAgJ2NsYXNzLW5hbWUnOiBbe1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86Y2xhc3N8Y29uY2VwdHxlbnVtfHN0cnVjdHx0eXBlbmFtZSlcXHMrKSg/ITxrZXl3b3JkPilcXHcrLy5zb3VyY2UucmVwbGFjZSgvPGtleXdvcmQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGtleXdvcmQuc291cmNlO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIC8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBvZiBtZXRob2QgaW1wbGVtZW50YXRpb25zIGxpa2U6XG4gICAgLy8gICB2b2lkIGZvbzo6YmFyKCkgY29uc3Qge31cbiAgICAvLyBIb3dldmVyISBUaGUgYGZvb2AgaW4gdGhlIGFib3ZlIGV4YW1wbGUgY291bGQgYWxzbyBiZSBhIG5hbWVzcGFjZSwgc28gd2Ugb25seSBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIGlmXG4gICAgLy8gaXQgc3RhcnRzIHdpdGggYW4gdXBwZXJjYXNlIGxldHRlci4gVGhpcyBhcHByb3hpbWF0aW9uIHNob3VsZCBnaXZlIGRlY2VudCByZXN1bHRzLlxuICAgIC9cXGJbQS1aXVxcdyooPz1cXHMqOjpcXHMqXFx3K1xccypcXCgpLywgLy8gVGhpcyB3aWxsIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgYmVmb3JlIGRlc3RydWN0b3JzIGxpa2U6XG4gICAgLy8gICBGb286On5Gb28oKSB7fVxuICAgIC9cXGJbQS1aX11cXHcqKD89XFxzKjo6XFxzKn5cXHcrXFxzKlxcKCkvaSwgLy8gVGhpcyBhbHNvIGludGVuZHMgdG8gY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBvZiBtZXRob2QgaW1wbGVtZW50YXRpb25zIGJ1dCBoZXJlIHRoZSBjbGFzcyBoYXMgdGVtcGxhdGVcbiAgICAvLyBwYXJhbWV0ZXJzLCBzbyBpdCBjYW4ndCBiZSBhIG5hbWVzcGFjZSAodW50aWwgQysrIGFkZHMgZ2VuZXJpYyBuYW1lc3BhY2VzKS5cbiAgICAvXFxiXFx3Kyg/PVxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+XFxzKjo6XFxzKlxcdytcXHMqXFwoKS9dLFxuICAgICdrZXl3b3JkJzoga2V5d29yZCxcbiAgICAnbnVtYmVyJzoge1xuICAgICAgcGF0dGVybjogLyg/OlxcYjBiWzAxJ10rfFxcYjB4KD86W1xcZGEtZiddKyg/OlxcLltcXGRhLWYnXSopP3xcXC5bXFxkYS1mJ10rKSg/OnBbKy1dP1tcXGQnXSspP3woPzpcXGJbXFxkJ10rKD86XFwuW1xcZCddKik/fFxcQlxcLltcXGQnXSspKD86ZVsrLV0/W1xcZCddKyk/KVtmdWxdezAsNH0vaSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ29wZXJhdG9yJzogLz4+PT98PDw9P3wtPnwtLXxcXCtcXCt8JiZ8XFx8XFx8fFs/On5dfDw9PnxbLSsqLyUmfF4hPTw+XT0/fFxcYig/OmFuZHxhbmRfZXF8Yml0YW5kfGJpdG9yfG5vdHxub3RfZXF8b3J8b3JfZXF8eG9yfHhvcl9lcSlcXGIvLFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiL1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ3N0cmluZycsIHtcbiAgICAnbW9kdWxlJzoge1xuICAgICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL21vZHVsZXNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmltcG9ydHxtb2R1bGUpXFxzKykvLnNvdXJjZSArICcoPzonICsgLy8gaGVhZGVyLW5hbWVcbiAgICAgIC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8PFtePD5cXHJcXG5dKj4vLnNvdXJjZSArICd8JyArIC8vIG1vZHVsZSBuYW1lIG9yIHBhcnRpdGlvbiBvciBib3RoXG4gICAgICAvPG1vZC1uYW1lPig/Olxccyo6XFxzKjxtb2QtbmFtZT4pP3w6XFxzKjxtb2QtbmFtZT4vLnNvdXJjZS5yZXBsYWNlKC88bW9kLW5hbWU+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1vZE5hbWU7XG4gICAgICB9KSArICcpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdzdHJpbmcnOiAvXls8XCJdW1xcc1xcU10rLyxcbiAgICAgICAgJ29wZXJhdG9yJzogLzovLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3Jhdy1zdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvUlwiKFteKClcXFxcIF17MCwxNn0pXFwoW1xcc1xcU10qP1xcKVxcMVwiLyxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdrZXl3b3JkJywge1xuICAgICdnZW5lcmljLWZ1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogL1xcYig/IW9wZXJhdG9yXFxiKVthLXpfXVxcdypcXHMqPCg/OltePD5dfDxbXjw+XSo+KSo+KD89XFxzKlxcKCkvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXlxcdysvLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jcHBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdvcGVyYXRvcicsIHtcbiAgICAnZG91YmxlLWNvbG9uJzoge1xuICAgICAgcGF0dGVybjogLzo6LyxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ2NsYXNzLW5hbWUnLCB7XG4gICAgLy8gdGhlIGJhc2UgY2xhdXNlIGlzIGFuIG9wdGlvbmFsIGxpc3Qgb2YgcGFyZW50IGNsYXNzZXNcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvY2xhc3NcbiAgICAnYmFzZS1jbGF1c2UnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfHN0cnVjdClcXHMrXFx3K1xccyo6XFxzKilbXjt7fVwiJ1xcc10rKD86XFxzK1teO3t9XCInXFxzXSspKig/PVxccypbO3tdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjcHAnLCB7fSlcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnZG91YmxlLWNvbG9uJywge1xuICAgIC8vIEFsbCB1bnRva2VuaXplZCB3b3JkcyB0aGF0IGFyZSBub3QgbmFtZXNwYWNlcyBzaG91bGQgYmUgY2xhc3MgbmFtZXNcbiAgICAnY2xhc3MtbmFtZSc6IC9cXGJbYS16X11cXHcqXFxiKD8hXFxzKjo6KS9pXG4gIH0sIFByaXNtLmxhbmd1YWdlcy5jcHBbJ2Jhc2UtY2xhdXNlJ10pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBzdHJpbmcgPSAvKD86XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifCcoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSkqJykvO1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuICAgICdjb21tZW50JzogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuICAgICdhdHJ1bGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlteO3tcXHNdfFxccysoPyFbXFxze10pKSooPzo7fCg/PVxccypcXHspKS8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3J1bGUnOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgJ3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gICAgICAgIH0sXG4gICAgICAgICdrZXl3b3JkJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0gLy8gU2VlIHJlc3QgYmVsb3dcblxuICAgICAgfVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXGJ1cmxcXFxcKCg/OicgKyBzdHJpbmcuc291cmNlICsgJ3wnICsgLyg/OlteXFxcXFxcclxcbigpXCInXXxcXFxcW1xcc1xcU10pKi8uc291cmNlICsgJylcXFxcKScsICdpJyksXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL151cmwvaSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15cXCh8XFwpJC8sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHN0cmluZy5zb3VyY2UgKyAnJCcpLFxuICAgICAgICAgIGFsaWFzOiAndXJsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIlxcJ1xcXFxzXXxcXFxccysoPyFbXFxcXHN7XSl8JyArIHN0cmluZy5zb3VyY2UgKyAnKSooPz1cXFxccypcXFxceyknKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmcsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnaW1wb3J0YW50JzogLyFpbXBvcnRhbnRcXGIvaSxcbiAgICAnZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tYS16MC05XSlbLWEtejAtOV0rKD89XFwoKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1soKXt9OzosXS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuICB2YXIgbWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuICBpZiAobWFya3VwKSB7XG4gICAgbWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcbiAgICBtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gIH1cbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcy1leHRyYXNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHN0cmluZyA9IC8oXCJ8JykoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLztcbiAgdmFyIHNlbGVjdG9ySW5zaWRlO1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzLnNlbGVjdG9yID0ge1xuICAgIHBhdHRlcm46IFByaXNtLmxhbmd1YWdlcy5jc3Muc2VsZWN0b3IucGF0dGVybixcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogc2VsZWN0b3JJbnNpZGUgPSB7XG4gICAgICAncHNldWRvLWVsZW1lbnQnOiAvOig/OmFmdGVyfGJlZm9yZXxmaXJzdC1sZXR0ZXJ8Zmlyc3QtbGluZXxzZWxlY3Rpb24pfDo6Wy1cXHddKy8sXG4gICAgICAncHNldWRvLWNsYXNzJzogLzpbLVxcd10rLyxcbiAgICAgICdjbGFzcyc6IC9cXC5bLVxcd10rLyxcbiAgICAgICdpZCc6IC8jWy1cXHddKy8sXG4gICAgICAnYXR0cmlidXRlJzoge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxbKD86W15bXFxcXF1cIlxcJ118JyArIHN0cmluZy5zb3VyY2UgKyAnKSpcXFxcXScpLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFxbfFxcXSQvLFxuICAgICAgICAgICdjYXNlLXNlbnNpdGl2aXR5Jzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyhcXHMpW3NpXSQvaSxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbmFtZXNwYWNlJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKikoPzooPyFcXHMpWy0qXFx3XFx4QTAtXFx1RkZGRl0pKlxcfCg/IT0pLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfCQvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnYXR0ci1uYW1lJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKikoPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkrLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdhdHRyLXZhbHVlJzogW3N0cmluZywge1xuICAgICAgICAgICAgcGF0dGVybjogLyg9XFxzKikoPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkrKD89XFxzKiQpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICAnb3BlcmF0b3InOiAvW3x+Kl4kXT89L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ24tdGgnOiBbe1xuICAgICAgICBwYXR0ZXJuOiAvKFxcKFxccyopWystXT9cXGQqW1xcZG5dKD86XFxzKlsrLV1cXHMqXFxkKyk/KD89XFxzKlxcKSkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnbnVtYmVyJzogL1tcXGRuXSsvLFxuICAgICAgICAgICdvcGVyYXRvcic6IC9bKy1dL1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPzpldmVufG9kZCkoPz1cXHMqXFwpKS9pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9XSxcbiAgICAgICdjb21iaW5hdG9yJzogLz58XFwrfH58XFx8XFx8LyxcbiAgICAgIC8vIHRoZSBgdGFnYCB0b2tlbiBoYXMgYmVlbiBleGlzdGVkIGFuZCByZW1vdmVkLlxuICAgICAgLy8gYmVjYXVzZSB3ZSBjYW4ndCBmaW5kIGEgcGVyZmVjdCB0b2tlbml6ZSB0byBtYXRjaCBpdC5cbiAgICAgIC8vIGlmIHlvdSB3YW50IHRvIGFkZCBpdCwgcGxlYXNlIHJlYWQgaHR0cHM6Ly9naXRodWIuY29tL1ByaXNtSlMvcHJpc20vcHVsbC8yMzczIGZpcnN0LlxuICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgIH1cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlWydzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCddLmluc2lkZSA9IHNlbGVjdG9ySW5zaWRlO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc3MnLCAncHJvcGVydHknLCB7XG4gICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgcGF0dGVybjogLyhefFteLVxcd1xceEEwLVxcdUZGRkZdKS0tKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKi9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIHZhciB1bml0ID0ge1xuICAgIHBhdHRlcm46IC8oXFxiXFxkKykoPzolfFthLXpdKyg/IVtcXHctXSkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07IC8vIDEyMyAtMTIzIC4xMjMgLS4xMjMgMTIuMyAtMTIuM1xuXG4gIHZhciBudW1iZXIgPSB7XG4gICAgcGF0dGVybjogLyhefFteXFx3Li1dKS0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjc3MnLCAnZnVuY3Rpb24nLCB7XG4gICAgJ29wZXJhdG9yJzoge1xuICAgICAgcGF0dGVybjogLyhcXHMpWytcXC0qXFwvXSg/PVxccykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gQ0FSRUZVTCFcbiAgICAvLyBQcmV2aWV3ZXJzIGFuZCBJbmxpbmUgY29sb3IgdXNlIGhleGNvZGUgYW5kIGNvbG9yLlxuICAgICdoZXhjb2RlJzoge1xuICAgICAgcGF0dGVybjogL1xcQiNbXFxkYS1mXXszLDh9XFxiL2ksXG4gICAgICBhbGlhczogJ2NvbG9yJ1xuICAgIH0sXG4gICAgJ2NvbG9yJzogW3tcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OkFsaWNlQmx1ZXxBbnRpcXVlV2hpdGV8QXF1YXxBcXVhbWFyaW5lfEF6dXJlfEJlaWdlfEJpc3F1ZXxCbGFja3xCbGFuY2hlZEFsbW9uZHxCbHVlfEJsdWVWaW9sZXR8QnJvd258QnVybHlXb29kfENhZGV0Qmx1ZXxDaGFydHJldXNlfENob2NvbGF0ZXxDb3JhbHxDb3JuZmxvd2VyQmx1ZXxDb3Juc2lsa3xDcmltc29ufEN5YW58RGFya0JsdWV8RGFya0N5YW58RGFya0dvbGRlblJvZHxEYXJrR3JbYWVdeXxEYXJrR3JlZW58RGFya0toYWtpfERhcmtNYWdlbnRhfERhcmtPbGl2ZUdyZWVufERhcmtPcmFuZ2V8RGFya09yY2hpZHxEYXJrUmVkfERhcmtTYWxtb258RGFya1NlYUdyZWVufERhcmtTbGF0ZUJsdWV8RGFya1NsYXRlR3JbYWVdeXxEYXJrVHVycXVvaXNlfERhcmtWaW9sZXR8RGVlcFBpbmt8RGVlcFNreUJsdWV8RGltR3JbYWVdeXxEb2RnZXJCbHVlfEZpcmVCcmlja3xGbG9yYWxXaGl0ZXxGb3Jlc3RHcmVlbnxGdWNoc2lhfEdhaW5zYm9yb3xHaG9zdFdoaXRlfEdvbGR8R29sZGVuUm9kfEdyW2FlXXl8R3JlZW58R3JlZW5ZZWxsb3d8SG9uZXlEZXd8SG90UGlua3xJbmRpYW5SZWR8SW5kaWdvfEl2b3J5fEtoYWtpfExhdmVuZGVyfExhdmVuZGVyQmx1c2h8TGF3bkdyZWVufExlbW9uQ2hpZmZvbnxMaWdodEJsdWV8TGlnaHRDb3JhbHxMaWdodEN5YW58TGlnaHRHb2xkZW5Sb2RZZWxsb3d8TGlnaHRHclthZV15fExpZ2h0R3JlZW58TGlnaHRQaW5rfExpZ2h0U2FsbW9ufExpZ2h0U2VhR3JlZW58TGlnaHRTa3lCbHVlfExpZ2h0U2xhdGVHclthZV15fExpZ2h0U3RlZWxCbHVlfExpZ2h0WWVsbG93fExpbWV8TGltZUdyZWVufExpbmVufE1hZ2VudGF8TWFyb29ufE1lZGl1bUFxdWFNYXJpbmV8TWVkaXVtQmx1ZXxNZWRpdW1PcmNoaWR8TWVkaXVtUHVycGxlfE1lZGl1bVNlYUdyZWVufE1lZGl1bVNsYXRlQmx1ZXxNZWRpdW1TcHJpbmdHcmVlbnxNZWRpdW1UdXJxdW9pc2V8TWVkaXVtVmlvbGV0UmVkfE1pZG5pZ2h0Qmx1ZXxNaW50Q3JlYW18TWlzdHlSb3NlfE1vY2Nhc2lufE5hdmFqb1doaXRlfE5hdnl8T2xkTGFjZXxPbGl2ZXxPbGl2ZURyYWJ8T3JhbmdlfE9yYW5nZVJlZHxPcmNoaWR8UGFsZUdvbGRlblJvZHxQYWxlR3JlZW58UGFsZVR1cnF1b2lzZXxQYWxlVmlvbGV0UmVkfFBhcGF5YVdoaXB8UGVhY2hQdWZmfFBlcnV8UGlua3xQbHVtfFBvd2RlckJsdWV8UHVycGxlfFJlZHxSb3N5QnJvd258Um95YWxCbHVlfFNhZGRsZUJyb3dufFNhbG1vbnxTYW5keUJyb3dufFNlYUdyZWVufFNlYVNoZWxsfFNpZW5uYXxTaWx2ZXJ8U2t5Qmx1ZXxTbGF0ZUJsdWV8U2xhdGVHclthZV15fFNub3d8U3ByaW5nR3JlZW58U3RlZWxCbHVlfFRhbnxUZWFsfFRoaXN0bGV8VG9tYXRvfFRyYW5zcGFyZW50fFR1cnF1b2lzZXxWaW9sZXR8V2hlYXR8V2hpdGV8V2hpdGVTbW9rZXxZZWxsb3d8WWVsbG93R3JlZW4pKD8hW1xcdy1dKS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzpoc2x8cmdiKVxcKFxccypcXGR7MSwzfVxccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccypcXGR7MSwzfSU/XFxzKlxcKVxcQnxcXGIoPzpoc2x8cmdiKWFcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKig/OjB8MD9cXC5cXGQrfDEpXFxzKlxcKVxcQi9pLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd1bml0JzogdW5pdCxcbiAgICAgICAgJ251bWJlcic6IG51bWJlcixcbiAgICAgICAgJ2Z1bmN0aW9uJzogL1tcXHctXSsoPz1cXCgpLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgICAgfVxuICAgIH1dLFxuICAgIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhlcmUgaXMgbm8gYm91bmRhcnkgYXNzZXJ0aW9uIGFmdGVyIHRoZSBoZXggZGlnaXRzXG4gICAgJ2VudGl0eSc6IC9cXFxcW1xcZGEtZl17MSw4fS9pLFxuICAgICd1bml0JzogdW5pdCxcbiAgICAnbnVtYmVyJzogbnVtYmVyXG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YXNjcmlwdFwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NsYXNzLW5hbWUnOiBbcHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAna2V5d29yZCc6IFt7XG4gICAgcGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgLy8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG4gICdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcbiAgJ251bWJlcic6IHtcbiAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFteXFx3JF0pLy5zb3VyY2UgKyAnKD86JyArICggLy8gY29uc3RhbnRcbiAgICAvTmFOfEluZmluaXR5Ly5zb3VyY2UgKyAnfCcgKyAvLyBiaW5hcnkgaW50ZWdlclxuICAgIC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICsgJ3wnICsgLy8gb2N0YWwgaW50ZWdlclxuICAgIC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgKyAnfCcgKyAvLyBoZXhhZGVjaW1hbCBpbnRlZ2VyXG4gICAgLzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArICd8JyArIC8vIGRlY2ltYWwgYmlnaW50XG4gICAgL1xcZCsoPzpfXFxkKykqbi8uc291cmNlICsgJ3wnICsgLy8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcbiAgICAvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlKSArICcpJyArIC8oPyFbXFx3JF0pLy5zb3VyY2UpLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydjbGFzcy1uYW1lJ11bMF0ucGF0dGVybiA9IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ldylcXHMrKVtcXHcuXFxcXF0rLztcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgJ3JlZ2V4Jzoge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuICAgIHBhdHRlcm46IC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKilcXC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9KD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdyZWdleC1zb3VyY2UnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKFxcLylbXFxzXFxTXSsoPz1cXC9bYS16XSokKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5yZWdleFxuICAgICAgfSxcbiAgICAgICdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcbiAgICAgICdyZWdleC1mbGFncyc6IC9eW2Etel0rJC9cbiAgICB9XG4gIH0sXG4gIC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcbiAgJ2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuICAgIHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdwYXJhbWV0ZXInOiBbe1xuICAgIHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyopXFwoXFxzKnxcXF1cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKlxceykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9XSxcbiAgJ2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuICAnaGFzaGJhbmcnOiB7XG4gICAgcGF0dGVybjogL14jIS4qLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdjb21tZW50J1xuICB9LFxuICAndGVtcGxhdGUtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfXwoPyFcXCRcXHspW15cXFxcYF0pKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH0sXG4gICdzdHJpbmctcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMig/PVxccyo6KS9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcbiAgJ2xpdGVyYWwtcHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9XG59KTtcblxuaWYgKHByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTsgLy8gYWRkIGF0dHJpYnV0ZSBzdXBwb3J0IGZvciBhbGwgRE9NIGV2ZW50cy5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzI1N0YW5kYXJkX2V2ZW50c1xuXG4gIHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLCAnamF2YXNjcmlwdCcpO1xufVxuXG5wcmlzbS5sYW5ndWFnZXMuanMgPSBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNvZmZlZXNjcmlwdFwiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gSWdub3JlIGNvbW1lbnRzIHN0YXJ0aW5nIHdpdGggeyB0byBwcml2aWxlZ2Ugc3RyaW5nIGludGVycG9sYXRpb24gaGlnaGxpZ2h0aW5nXG4gIHZhciBjb21tZW50ID0gLyMoPyFcXHspLisvO1xuICB2YXIgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICBwYXR0ZXJuOiAvI1xce1tefV0rXFx9LyxcbiAgICBhbGlhczogJ3ZhcmlhYmxlJ1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuY29mZmVlc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcbiAgICAnY29tbWVudCc6IGNvbW1lbnQsXG4gICAgJ3N0cmluZyc6IFsvLyBTdHJpbmdzIGFyZSBtdWx0aWxpbmVcbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvJyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJy8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAvLyBTdHJpbmdzIGFyZSBtdWx0aWxpbmVcbiAgICAgIHBhdHRlcm46IC9cIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwiLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGludGVycG9sYXRpb25cbiAgICAgIH1cbiAgICB9XSxcbiAgICAna2V5d29yZCc6IC9cXGIoPzphbmR8YnJlYWt8Ynl8Y2F0Y2h8Y2xhc3N8Y29udGludWV8ZGVidWdnZXJ8ZGVsZXRlfGRvfGVhY2h8ZWxzZXxleHRlbmR8ZXh0ZW5kc3xmYWxzZXxmaW5hbGx5fGZvcnxpZnxpbnxpbnN0YW5jZW9mfGlzfGlzbnR8bGV0fGxvb3B8bmFtZXNwYWNlfG5ld3xub3xub3R8bnVsbHxvZnxvZmZ8b258b3J8b3dufHJldHVybnxzdXBlcnxzd2l0Y2h8dGhlbnx0aGlzfHRocm93fHRydWV8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dW5sZXNzfHVudGlsfHdoZW58d2hpbGV8d2luZG93fHdpdGh8eWVzfHlpZWxkKVxcYi8sXG4gICAgJ2NsYXNzLW1lbWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC9AKD8hXFxkKVxcdysvLFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZSdcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjb2ZmZWVzY3JpcHQnLCAnY29tbWVudCcsIHtcbiAgICAnbXVsdGlsaW5lLWNvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvIyMjW1xcc1xcU10rPyMjIy8sXG4gICAgICBhbGlhczogJ2NvbW1lbnQnXG4gICAgfSxcbiAgICAvLyBCbG9jayByZWdleHAgY2FuIGNvbnRhaW4gY29tbWVudHMgYW5kIGludGVycG9sYXRpb25cbiAgICAnYmxvY2stcmVnZXgnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFwvezN9W1xcc1xcU10qP1xcL3szfS8sXG4gICAgICBhbGlhczogJ3JlZ2V4JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29tbWVudCc6IGNvbW1lbnQsXG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvblxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NvZmZlZXNjcmlwdCcsICdzdHJpbmcnLCB7XG4gICAgJ2lubGluZS1qYXZhc2NyaXB0Jzoge1xuICAgICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118W15cXFxcYF0pKmAvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICAnc2NyaXB0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCcsXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBCbG9jayBzdHJpbmdzXG4gICAgJ211bHRpbGluZS1zdHJpbmcnOiBbe1xuICAgICAgcGF0dGVybjogLycnJ1tcXHNcXFNdKj8nJycvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogL1wiXCJcIltcXHNcXFNdKj9cIlwiXCIvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIGludGVycG9sYXRpb246IGludGVycG9sYXRpb25cbiAgICAgIH1cbiAgICB9XVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY29mZmVlc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICAgLy8gT2JqZWN0IHByb3BlcnR5XG4gICAgJ3Byb3BlcnR5JzogLyg/IVxcZClcXHcrKD89XFxzKjooPyE6KSkvXG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmNvZmZlZXNjcmlwdFsndGVtcGxhdGUtc3RyaW5nJ107XG4gIFByaXNtLmxhbmd1YWdlcy5jb2ZmZWUgPSBQcmlzbS5sYW5ndWFnZXMuY29mZmVlc2NyaXB0O1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20teWFtbFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFuY2hvci1wcm9wZXJ0eVxuICAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLWFsaWFzLW5vZGVcbiAgdmFyIGFuY2hvck9yQWxpYXMgPSAvWyomXVteXFxzW1xcXXt9LF0rLzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy10YWctcHJvcGVydHlcblxuICB2YXIgdGFnID0gLyEoPzo8W1xcd1xcLSUjOy8/OkAmPSskLC4hfionKClbXFxdXSs+fCg/OlthLXpBLVpcXGQtXSohKT9bXFx3XFwtJSM7Lz86QCY9KyQufionKCldKyk/LzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1wcm9wZXJ0aWVzKG4sYylcblxuICB2YXIgcHJvcGVydGllcyA9ICcoPzonICsgdGFnLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIGFuY2hvck9yQWxpYXMuc291cmNlICsgJyk/fCcgKyBhbmNob3JPckFsaWFzLnNvdXJjZSArICcoPzpbIFxcdF0rJyArIHRhZy5zb3VyY2UgKyAnKT8pJzsgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjbnMtcGxhaW4obixjKVxuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIHRoYXQgZG9lc24ndCBzdXBwb3J0IFwiI1wiIGFuZCBtdWx0aWxpbmUga2V5c1xuICAvLyBBbGwgdGhlc2UgbG9uZyBzY2FycnkgY2hhcmFjdGVyIGNsYXNzZXMgYXJlIHNpbXBsaWZpZWQgdmVyc2lvbnMgb2YgWUFNTCdzIGNoYXJhY3RlcnNcblxuICB2YXIgcGxhaW5LZXkgPSAvKD86W15cXHNcXHgwMC1cXHgwOFxceDBlLVxceDFmIVwiIyUmJyosXFwtOj4/QFtcXF1ge3x9XFx4N2YtXFx4ODRcXHg4Ni1cXHg5ZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXXxbPzotXTxQTEFJTj4pKD86WyBcXHRdKig/Oig/IVsjOl0pPFBMQUlOPnw6PFBMQUlOPikpKi8uc291cmNlLnJlcGxhY2UoLzxQTEFJTj4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvW15cXHNcXHgwMC1cXHgwOFxceDBlLVxceDFmLFtcXF17fVxceDdmLVxceDg0XFx4ODYtXFx4OWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZl0vLnNvdXJjZTtcbiAgfSk7XG4gIHZhciBzdHJpbmcgPSAvXCIoPzpbXlwiXFxcXFxcclxcbl18XFxcXC4pKlwifCcoPzpbXidcXFxcXFxyXFxuXXxcXFxcLikqJy8uc291cmNlO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlUGF0dGVybih2YWx1ZSwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IChmbGFncyB8fCAnJykucmVwbGFjZSgvbS9nLCAnJykgKyAnbSc7IC8vIGFkZCBtIGZsYWdcblxuICAgIHZhciBwYXR0ZXJuID0gLyhbOlxcLSxbe11cXHMqKD86XFxzPDxwcm9wPj5bIFxcdF0rKT8pKD86PDx2YWx1ZT4+KSg/PVsgXFx0XSooPzokfCx8XFxdfFxcfXwoPzpbXFxyXFxuXVxccyopPyMpKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0pLnJlcGxhY2UoLzw8dmFsdWU+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMueWFtbCA9IHtcbiAgICAnc2NhbGFyJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oW1xcLTpdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/W3w+XSlbIFxcdF0qKD86KCg/Olxccj9cXG58XFxyKVsgXFx0XSspXFxTW15cXHJcXG5dKig/OlxcMlteXFxyXFxuXSspKikvLnNvdXJjZS5yZXBsYWNlKC88PHByb3A+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAvIy4qLyxcbiAgICAna2V5Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oKD86XnxbOlxcLSxbe1xcclxcbj9dKVsgXFx0XSooPzo8PHByb3A+PlsgXFx0XSspPyk8PGtleT4+KD89XFxzKjpcXHMpLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICAgIH0pLnJlcGxhY2UoLzw8a2V5Pj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJyg/OicgKyBwbGFpbktleSArICd8JyArIHN0cmluZyArICcpJztcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogJ2F0cnVsZSdcbiAgICB9LFxuICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSUuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2RhdGV0aW1lJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9cXGR7NH0tXFxkXFxkPy1cXGRcXGQ/KD86W3RUXXxbIFxcdF0rKVxcZFxcZD86XFxkezJ9OlxcZHsyfSg/OlxcLlxcZCopPyg/OlsgXFx0XSooPzpafFstK11cXGRcXGQ/KD86OlxcZHsyfSk/KSk/fFxcZHs0fS1cXGR7Mn0tXFxkezJ9fFxcZFxcZD86XFxkezJ9KD86OlxcZHsyfSg/OlxcLlxcZCopPyk/Ly5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnbnVtYmVyJ1xuICAgIH0sXG4gICAgJ2Jvb2xlYW4nOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL2ZhbHNlfHRydWUvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdudWxsJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9udWxsfH4vLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oc3RyaW5nKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL1srLV0/KD86MHhbXFxkYS1mXSt8MG9bMC03XSt8KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspP3xcXC5pbmZ8XFwubmFuKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3RhZyc6IHRhZyxcbiAgICAnaW1wb3J0YW50JzogYW5jaG9yT3JBbGlhcyxcbiAgICAncHVuY3R1YXRpb24nOiAvLS0tfFs6W1xcXXt9XFwtLHw+P118XFwuXFwuXFwuL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMueW1sID0gUHJpc20ubGFuZ3VhZ2VzLnlhbWw7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93blwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBBbGxvdyBvbmx5IG9uZSBsaW5lIGJyZWFrXG4gIHZhciBpbm5lciA9IC8oPzpcXFxcLnxbXlxcXFxcXG5cXHJdfCg/OlxcbnxcXHJcXG4/KSg/IVtcXHJcXG5dKSkvLnNvdXJjZTtcbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiB0aGUgYm9sZCBvciBpdGFsaWMgcGF0dGVybi5cbiAgICpcbiAgICogVGhpcyBhbHNvIGFkZHMgYSBsb29rYmVoaW5kIGdyb3VwIHRvIHRoZSBnaXZlbiBwYXR0ZXJuIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXR0ZXJuIGlzIG5vdCBiYWNrc2xhc2gtZXNjYXBlZC5cbiAgICpcbiAgICogX05vdGU6XyBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIGFkZHMgYSBjYXB0dXJpbmcgZ3JvdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlubGluZShwYXR0ZXJuKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvPGlubmVyPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaW5uZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cCgvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopLy5zb3VyY2UgKyAnKD86JyArIHBhdHRlcm4gKyAnKScpO1xuICB9XG5cbiAgdmFyIHRhYmxlQ2VsbCA9IC8oPzpcXFxcLnxgYCg/OlteYFxcclxcbl18YCg/IWApKStgYHxgW15gXFxyXFxuXStgfFteXFxcXHxcXHJcXG5gXSkrLy5zb3VyY2U7XG4gIHZhciB0YWJsZVJvdyA9IC9cXHw/X18oPzpcXHxfXykrXFx8Pyg/Oig/OlxcbnxcXHJcXG4/KXwoPyFbXFxzXFxTXSkpLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0YWJsZUNlbGw7XG4gIH0pO1xuICB2YXIgdGFibGVMaW5lID0gL1xcfD9bIFxcdF0qOj8tezMsfTo/WyBcXHRdKig/OlxcfFsgXFx0XSo6Py17Myx9Oj9bIFxcdF0qKStcXHw/KD86XFxufFxcclxcbj8pLy5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5tYXJrZG93biA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya2Rvd24nLCAncHJvbG9nJywge1xuICAgICdmcm9udC1tYXR0ZXItYmxvY2snOiB7XG4gICAgICBwYXR0ZXJuOiAvKF4oPzpcXHMqW1xcclxcbl0pPyktLS0oPyEuKVtcXHNcXFNdKj9bXFxyXFxuXS0tLSg/IS4pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL14tLS18LS0tJC8sXG4gICAgICAgICdmcm9udC1tYXR0ZXInOiB7XG4gICAgICAgICAgcGF0dGVybjogL1xcUysoPzpcXHMrXFxTKykqLyxcbiAgICAgICAgICBhbGlhczogWyd5YW1sJywgJ2xhbmd1YWdlLXlhbWwnXSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy55YW1sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdibG9ja3F1b3RlJzoge1xuICAgICAgLy8gPiAuLi5cbiAgICAgIHBhdHRlcm46IC9ePig/OltcXHQgXSo+KSovbSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndGFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKD86JyArIHRhYmxlUm93ICsgJykqJywgJ20nKSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGFibGUtZGF0YS1yb3dzJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXignICsgdGFibGVSb3cgKyB0YWJsZUxpbmUgKyAnKSg/OicgKyB0YWJsZVJvdyArICcpKiQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWRhdGEnOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0YWJsZUNlbGwpLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHwvXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtbGluZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oJyArIHRhYmxlUm93ICsgJyknICsgdGFibGVMaW5lICsgJyQnKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfHw6Py17Myx9Oj8vXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndGFibGUtaGVhZGVyLXJvdyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgdGFibGVSb3cgKyAnJCcpLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ3RhYmxlLWhlYWRlcic6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogUmVnRXhwKHRhYmxlQ2VsbCksXG4gICAgICAgICAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8L1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUnOiBbe1xuICAgICAgLy8gUHJlZml4ZWQgYnkgNCBzcGFjZXMgb3IgMSB0YWIgYW5kIHByZWNlZGVkIGJ5IGFuIGVtcHR5IGxpbmVcbiAgICAgIHBhdHRlcm46IC8oKD86XnxcXG4pWyBcXHRdKlxcbnwoPzpefFxcclxcbj8pWyBcXHRdKlxcclxcbj8pKD86IHs0fXxcXHQpLisoPzooPzpcXG58XFxyXFxuPykoPzogezR9fFxcdCkuKykqLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgfSwge1xuICAgICAgLy8gYGBgb3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICAgIC8vIGNvZGUgYmxvY2tcbiAgICAgIC8vIGBgYFxuICAgICAgcGF0dGVybjogL15gYGBbXFxzXFxTXSo/XmBgYCQvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29kZS1ibG9jayc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGAuKig/OlxcbnxcXHJcXG4/KSlbXFxzXFxTXSs/KD89KD86XFxufFxcclxcbj8pXmBgYCQpL20sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnY29kZS1sYW5ndWFnZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXihgYGApLisvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL2BgYC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAndGl0bGUnOiBbe1xuICAgICAgLy8gdGl0bGUgMVxuICAgICAgLy8gPT09PT09PVxuICAgICAgLy8gdGl0bGUgMlxuICAgICAgLy8gLS0tLS0tLVxuICAgICAgcGF0dGVybjogL1xcUy4qKD86XFxufFxcclxcbj8pKD86PT0rfC0tKykoPz1bIFxcdF0qJCkvbSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogLz09KyR8LS0rJC9cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyAjIHRpdGxlIDFcbiAgICAgIC8vICMjIyMjIyB0aXRsZSA2XG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSMuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL14jK3wjKyQvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2hyJzoge1xuICAgICAgLy8gKioqXG4gICAgICAvLyAtLS1cbiAgICAgIC8vICogKiAqXG4gICAgICAvLyAtLS0tLS0tLS0tLVxuICAgICAgcGF0dGVybjogLyheXFxzKikoWyotXSkoPzpbXFx0IF0qXFwyKXsyLH0oPz1cXHMqJCkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ2xpc3QnOiB7XG4gICAgICAvLyAqIGl0ZW1cbiAgICAgIC8vICsgaXRlbVxuICAgICAgLy8gLSBpdGVtXG4gICAgICAvLyAxLiBpdGVtXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKSg/OlsqKy1dfFxcZCtcXC4pKD89W1xcdCBdLikvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3VybC1yZWZlcmVuY2UnOiB7XG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiXG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gJ09wdGlvbmFsIHRpdGxlJ1xuICAgICAgLy8gW2lkXTogaHR0cDovL2V4YW1wbGUuY29tIChPcHRpb25hbCB0aXRsZSlcbiAgICAgIC8vIFtpZF06IDxodHRwOi8vZXhhbXBsZS5jb20+IFwiT3B0aW9uYWwgdGl0bGVcIlxuICAgICAgcGF0dGVybjogLyE/XFxbW15cXF1dK1xcXTpbXFx0IF0rKD86XFxTK3w8KD86XFxcXC58W14+XFxcXF0pKz4pKD86W1xcdCBdKyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkpPy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKCE/XFxbKVteXFxdXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IC8oPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpJC8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eW1xcW1xcXSE6XXxbPD5dL1xuICAgICAgfSxcbiAgICAgIGFsaWFzOiAndXJsJ1xuICAgIH0sXG4gICAgJ2JvbGQnOiB7XG4gICAgICAvLyAqKnN0cm9uZyoqXG4gICAgICAvLyBfX3N0cm9uZ19fXG4gICAgICAvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGl0YWxpYyB0ZXh0IHVzaW5nIHRoZSBzYW1lIGRlbGltaXRlclxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC9cXGJfXyg/Oig/IV8pPGlubmVyPnxfKD86KD8hXyk8aW5uZXI+KStfKStfX1xcYnxcXCpcXCooPzooPyFcXCopPGlubmVyPnxcXCooPzooPyFcXCopPGlubmVyPikrXFwqKStcXCpcXCovLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXi4uKVtcXHNcXFNdKyg/PS4uJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXFwqXFwqfF9fL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2l0YWxpYyc6IHtcbiAgICAgIC8vICplbSpcbiAgICAgIC8vIF9lbV9cbiAgICAgIC8vIGFsbG93IG9uZSBuZXN0ZWQgaW5zdGFuY2Ugb2YgYm9sZCB0ZXh0IHVzaW5nIHRoZSBzYW1lIGRlbGltaXRlclxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC9cXGJfKD86KD8hXyk8aW5uZXI+fF9fKD86KD8hXyk8aW5uZXI+KStfXykrX1xcYnxcXCooPzooPyFcXCopPGlubmVyPnxcXCpcXCooPzooPyFcXCopPGlubmVyPikrXFwqXFwqKStcXCovLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXi4pW1xcc1xcU10rKD89LiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1sqX10vXG4gICAgICB9XG4gICAgfSxcbiAgICAnc3RyaWtlJzoge1xuICAgICAgLy8gfn5zdHJpa2UgdGhyb3VnaH5+XG4gICAgICAvLyB+c3RyaWtlflxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9zdHJpY3RcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvKH5+PykoPzooPyF+KTxpbm5lcj4pK1xcMi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhefn4/KVtcXHNcXFNdKyg/PVxcMSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL35+Py9cbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlLXNuaXBwZXQnOiB7XG4gICAgICAvLyBgY29kZWBcbiAgICAgIC8vIGBgY29kZWBgXG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcYF0pKD86YGBbXmBcXHJcXG5dKyg/OmBbXmBcXHJcXG5dKykqYGAoPyFgKXxgW15gXFxyXFxuXStgKD8hYCkpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogWydjb2RlJywgJ2tleXdvcmQnXVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIC8vIFtleGFtcGxlXShodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiKVxuICAgICAgLy8gW2V4YW1wbGVdW2lkXVxuICAgICAgLy8gW2V4YW1wbGVdIFtpZF1cbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvIT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKD86XFwoW15cXHMpXSsoPzpbXFx0IF0rXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKT9cXCl8WyBcXHRdP1xcWyg/Oig/IVxcXSk8aW5uZXI+KStcXF0pLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvXiEvLFxuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXFspW15cXF1dKyg/PVxcXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAndmFyaWFibGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxdWyBcXHRdP1xcWylbXlxcXV0rKD89XFxdJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3VybCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXF1cXCgpW15cXHMpXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0rKVwiKD86XFxcXC58W15cIlxcXFxdKSpcIig/PVxcKSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnXS5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIFsndXJsJywgJ2JvbGQnLCAnaXRhbGljJywgJ3N0cmlrZScsICdjb2RlLXNuaXBwZXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChpbnNpZGUpIHtcbiAgICAgIGlmICh0b2tlbiAhPT0gaW5zaWRlKSB7XG4gICAgICAgIFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blt0b2tlbl0uaW5zaWRlLmNvbnRlbnQuaW5zaWRlW2luc2lkZV0gPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25baW5zaWRlXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gJ21hcmtkb3duJyAmJiBlbnYubGFuZ3VhZ2UgIT09ICdtZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWxrVG9rZW5zKHRva2Vucykge1xuICAgICAgaWYgKCF0b2tlbnMgfHwgdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEFkZCB0aGUgY29ycmVjdCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3MgdG8gdGhpcyBjb2RlIGJsb2NrLiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYGNvZGUtbGFuZ3VhZ2VgIHRva2VuXG4gICAgICAgICAqIGlzIG9wdGlvbmFsLiBCdXQgdGhlIGdyYW1tYXIgaXMgZGVmaW5lZCBzbyB0aGF0IHRoZXJlIGlzIG9ubHkgb25lIGNhc2Ugd2UgaGF2ZSB0byBoYW5kbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqIHRva2VuLmNvbnRlbnQgPSBbXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cInB1bmN0dWF0aW9uXCI+YGBgPC9zcGFuPixcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwiY29kZS1sYW5ndWFnZVwiPnh4eHg8L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyAoXFxyIG9yIFxcbiBvciBcXHJcXG4pXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtYmxvY2tcIj4uLi48L3NwYW4+LFxuICAgICAgICAgKiAgICAgJ1xcbicsIC8vIGV4YWN0bHkgb25lIG5ldyBsaW5lcyBhZ2FpblxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj5cbiAgICAgICAgICogXTtcbiAgICAgICAgICovXG5cblxuICAgICAgICB2YXIgY29kZUxhbmcgPSB0b2tlbi5jb250ZW50WzFdO1xuICAgICAgICB2YXIgY29kZUJsb2NrID0gdG9rZW4uY29udGVudFszXTtcblxuICAgICAgICBpZiAoY29kZUxhbmcgJiYgY29kZUJsb2NrICYmIGNvZGVMYW5nLnR5cGUgPT09ICdjb2RlLWxhbmd1YWdlJyAmJiBjb2RlQmxvY2sudHlwZSA9PT0gJ2NvZGUtYmxvY2snICYmIHR5cGVvZiBjb2RlTGFuZy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgYSBsYW5ndWFnZSB0aGF0IFByaXNtIGRvZXMgbm90IHN1cHBvcnRcbiAgICAgICAgICAvLyBkbyBzb21lIHJlcGxhY2VtZW50cyB0byBzdXBwb3J0IEMrKywgQyMsIGFuZCBGI1xuICAgICAgICAgIHZhciBsYW5nID0gY29kZUxhbmcuY29udGVudC5yZXBsYWNlKC9cXGIjL2csICdzaGFycCcpLnJlcGxhY2UoL1xcYlxcK1xcKy9nLCAncHAnKTsgLy8gb25seSB1c2UgdGhlIGZpcnN0IHdvcmRcblxuICAgICAgICAgIGxhbmcgPSAoL1thLXpdW1xcdy1dKi9pLmV4ZWMobGFuZykgfHwgWycnXSlbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYWxpYXMgPSAnbGFuZ3VhZ2UtJyArIGxhbmc7IC8vIGFkZCBhbGlhc1xuXG4gICAgICAgICAgaWYgKCFjb2RlQmxvY2suYWxpYXMpIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcyA9IFthbGlhc107XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZUJsb2NrLmFsaWFzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzID0gW2NvZGVCbG9jay5hbGlhcywgYWxpYXNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMucHVzaChhbGlhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcbiAgfSk7XG4gIFByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoZW52LnR5cGUgIT09ICdjb2RlLWJsb2NrJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb2RlTGFuZyA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbnYuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjbHMgPSBlbnYuY2xhc3Nlc1tpXTtcbiAgICAgIHZhciBtYXRjaCA9IC9sYW5ndWFnZS0oLispLy5leGVjKGNscyk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb2RlTGFuZyA9IG1hdGNoWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tjb2RlTGFuZ107XG5cbiAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlTGFuZyAhPT0gJ25vbmUnICYmIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlcikge1xuICAgICAgICB2YXIgaWQgPSAnbWQtJyArIG5ldyBEYXRlKCkudmFsdWVPZigpICsgJy0nICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWUxNik7XG4gICAgICAgIGVudi5hdHRyaWJ1dGVzWydpZCddID0gaWQ7XG4gICAgICAgIFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGNvZGVMYW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5pbm5lckhUTUwgPSBQcmlzbS5oaWdobGlnaHQoZWxlLnRleHRDb250ZW50LCBQcmlzbS5sYW5ndWFnZXNbY29kZUxhbmddLCBjb2RlTGFuZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW52LmNvbnRlbnQgPSBQcmlzbS5oaWdobGlnaHQodGV4dENvbnRlbnQoZW52LmNvbnRlbnQpLCBncmFtbWFyLCBjb2RlTGFuZyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHRhZ1BhdHRlcm4gPSBSZWdFeHAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcucGF0dGVybi5zb3VyY2UsICdnaScpO1xuICAvKipcbiAgICogQSBsaXN0IG9mIGtub3duIGVudGl0eSBuYW1lcy5cbiAgICpcbiAgICogVGhpcyB3aWxsIGFsd2F5cyBiZSBpbmNvbXBsZXRlIHRvIHNhdmUgc3BhY2UuIFRoZSBjdXJyZW50IGxpc3QgaXMgdGhlIG9uZSB1c2VkIGJ5IGxvd2Rhc2gncyB1bmVzY2FwZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi8yZGEwMjRjM2I0Zjk5NDdhNDg1MTc2MzlkZTc1NjA0NTdjZDRlYzZjL3VuZXNjYXBlLmpzI0wyfVxuICAgKi9cblxuICB2YXIgS05PV05fRU5USVRZX05BTUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdndCc6ICc+JyxcbiAgICAncXVvdCc6ICdcIidcbiAgfTsgLy8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IGBTdHJpbmcuZnJvbUNvZGVQb2ludGBcblxuICB2YXIgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50IHx8IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBnaXZlbiBIVE1MIHNvdXJjZSBjb2RlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gdGV4dENvbnRlbnQoaHRtbCkge1xuICAgIC8vIHJlbW92ZSBhbGwgdGFnc1xuICAgIHZhciB0ZXh0ID0gaHRtbC5yZXBsYWNlKHRhZ1BhdHRlcm4sICcnKTsgLy8gZGVjb2RlIGtub3duIGVudGl0aWVzXG5cbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mKFxcd3sxLDh9fCN4P1tcXGRhLWZdezEsOH0pOy9naSwgZnVuY3Rpb24gKG0sIGNvZGUpIHtcbiAgICAgIGNvZGUgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChjb2RlWzBdID09PSAnIycpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChjb2RlWzFdID09PSAneCcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KGNvZGUuc2xpY2UoMiksIDE2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IE51bWJlcihjb2RlLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrbm93biA9IEtOT1dOX0VOVElUWV9OQU1FU1tjb2RlXTtcblxuICAgICAgICBpZiAoa25vd24pIHtcbiAgICAgICAgICByZXR1cm4ga25vd247XG4gICAgICAgIH0gLy8gdW5hYmxlIHRvIGRlY29kZVxuXG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMubWQgPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd247XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ncmFwaHFsXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuZ3JhcGhxbCA9IHtcbiAgJ2NvbW1lbnQnOiAvIy4qLyxcbiAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oPzpcIlwiXCIoPzpbXlwiXXwoPyFcIlwiXCIpXCIpKlwiXCJcInxcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIpKD89XFxzKlthLXpfXSkvaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdzdHJpbmcnLFxuICAgIGluc2lkZToge1xuICAgICAgJ2xhbmd1YWdlLW1hcmtkb3duJzoge1xuICAgICAgICBwYXR0ZXJuOiAvKF5cIig/OlwiXCIpPykoPyFcXDEpW1xcc1xcU10rKD89XFwxJCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvXCJcIlwiKD86W15cIl18KD8hXCJcIlwiKVwiKSpcIlwiXCJ8XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ251bWJlcic6IC8oPzpcXEItfFxcYilcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ3ZhcmlhYmxlJzogL1xcJFthLXpfXVxcdyovaSxcbiAgJ2RpcmVjdGl2ZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFthLXpfXVxcdyovaSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAnYXR0ci1uYW1lJzoge1xuICAgIHBhdHRlcm46IC9cXGJbYS16X11cXHcqKD89XFxzKig/OlxcKCg/OlteKClcIl18XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKSpcXCkpPzopL2ksXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdhdG9tLWlucHV0Jzoge1xuICAgIHBhdHRlcm46IC9cXGJbQS1aXVxcdypJbnB1dFxcYi8sXG4gICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICB9LFxuICAnc2NhbGFyJzogL1xcYig/OkJvb2xlYW58RmxvYXR8SUR8SW50fFN0cmluZylcXGIvLFxuICAnY29uc3RhbnQnOiAvXFxiW0EtWl1bQS1aX1xcZF0qXFxiLyxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzplbnVtfGltcGxlbWVudHN8aW50ZXJmYWNlfG9ufHNjYWxhcnx0eXBlfHVuaW9uKVxccyt8Jlxccyp8Olxccyp8XFxbKVtBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2ZyYWdtZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXFxiZnJhZ21lbnRcXHMrfFxcLnszfVxccyooPyFvblxcYikpW2EtekEtWl9dXFx3Ki8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAnZGVmaW5pdGlvbi1tdXRhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYm11dGF0aW9uXFxzKylbYS16QS1aX11cXHcqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdkZWZpbml0aW9uLXF1ZXJ5Jzoge1xuICAgIHBhdHRlcm46IC8oXFxicXVlcnlcXHMrKVthLXpBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86ZGlyZWN0aXZlfGVudW18ZXh0ZW5kfGZyYWdtZW50fGltcGxlbWVudHN8aW5wdXR8aW50ZXJmYWNlfG11dGF0aW9ufG9ufHF1ZXJ5fHJlcGVhdGFibGV8c2NhbGFyfHNjaGVtYXxzdWJzY3JpcHRpb258dHlwZXx1bmlvbilcXGIvLFxuICAnb3BlcmF0b3InOiAvWyE9fCZdfFxcLnszfS8sXG4gICdwcm9wZXJ0eS1xdWVyeSc6IC9cXHcrKD89XFxzKlxcKCkvLFxuICAnb2JqZWN0JzogL1xcdysoPz1cXHMqXFx7KS8sXG4gICdwdW5jdHVhdGlvbic6IC9bISgpe31cXFtcXF06PSxdLyxcbiAgJ3Byb3BlcnR5JzogL1xcdysvXG59O1xucHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIGFmdGVyVG9rZW5pemVHcmFwaHFsKGVudikge1xuICBpZiAoZW52Lmxhbmd1YWdlICE9PSAnZ3JhcGhxbCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgZ3JhcGhxbCB0b2tlbiBzdHJlYW0gdGhhdCB3ZSB3YW50IHRvIGN1c3RvbWl6ZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPGltcG9ydChcIi4vcHJpc20tY29yZVwiKVtcIlRva2VuXCJdPn0gVG9rZW5cbiAgICogQHR5cGUge1Rva2VuW119XG4gICAqL1xuXG5cbiAgdmFyIHZhbGlkVG9rZW5zID0gZW52LnRva2Vucy5maWx0ZXIoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycgJiYgdG9rZW4udHlwZSAhPT0gJ2NvbW1lbnQnICYmIHRva2VuLnR5cGUgIT09ICdzY2FsYXInO1xuICB9KTtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGluZGV4IGhhcyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJucyB7VG9rZW4gfCB1bmRlZmluZWR9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFRva2VuKG9mZnNldCkge1xuICAgIHJldHVybiB2YWxpZFRva2Vuc1tjdXJyZW50SW5kZXggKyBvZmZzZXRdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRva2VuIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGluZGV4IGhhcyB0aGUgZ2l2ZW4gdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtyZWFkb25seSBzdHJpbmdbXX0gdHlwZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF1cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNUb2tlblR5cGUodHlwZXMsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gZ2V0VG9rZW4oaSArIG9mZnNldCk7XG5cbiAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gdHlwZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2luZyBicmFja2V0IHRvIGFuIG9wZW5pbmcgYnJhY2tldC5cbiAgICpcbiAgICogSXQgaXMgYXNzdW1lZCB0aGF0IGB0b2tlbltjdXJyZW50SW5kZXggLSAxXWAgaXMgYW4gb3BlbmluZyBicmFja2V0LlxuICAgKlxuICAgKiBJZiBubyBjbG9zaW5nIGJyYWNrZXQgY291bGQgYmUgZm91bmQsIGAtMWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHB9IG9wZW5cbiAgICogQHBhcmFtIHtSZWdFeHB9IGNsb3NlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KG9wZW4sIGNsb3NlKSB7XG4gICAgdmFyIHN0YWNrSGVpZ2h0ID0gMTtcblxuICAgIGZvciAodmFyIGkgPSBjdXJyZW50SW5kZXg7IGkgPCB2YWxpZFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdmFsaWRUb2tlbnNbaV07XG4gICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3Blbi50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgc3RhY2tIZWlnaHQrKztcbiAgICAgICAgfSBlbHNlIGlmIChjbG9zZS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgc3RhY2tIZWlnaHQtLTtcblxuICAgICAgICAgIGlmIChzdGFja0hlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFsaWFzIHRvIHRoZSBnaXZlbiB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZEFsaWFzKHRva2VuLCBhbGlhcykge1xuICAgIHZhciBhbGlhc2VzID0gdG9rZW4uYWxpYXM7XG5cbiAgICBpZiAoIWFsaWFzZXMpIHtcbiAgICAgIHRva2VuLmFsaWFzID0gYWxpYXNlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcbiAgICAgIHRva2VuLmFsaWFzID0gYWxpYXNlcyA9IFthbGlhc2VzXTtcbiAgICB9XG5cbiAgICBhbGlhc2VzLnB1c2goYWxpYXMpO1xuICB9XG5cbiAgZm9yICg7IGN1cnJlbnRJbmRleCA8IHZhbGlkVG9rZW5zLmxlbmd0aDspIHtcbiAgICB2YXIgc3RhcnRUb2tlbiA9IHZhbGlkVG9rZW5zW2N1cnJlbnRJbmRleCsrXTsgLy8gYWRkIHNwZWNpYWwgYWxpYXNlcyBmb3IgbXV0YXRpb24gdG9rZW5zXG5cbiAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSAna2V5d29yZCcgJiYgc3RhcnRUb2tlbi5jb250ZW50ID09PSAnbXV0YXRpb24nKSB7XG4gICAgICAvLyBhbnkgYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBpbnB1dCB2YXJpYWJsZXMgKGlmIGFueSlcbiAgICAgIHZhciBpbnB1dFZhcmlhYmxlcyA9IFtdO1xuXG4gICAgICBpZiAoaXNUb2tlblR5cGUoWydkZWZpbml0aW9uLW11dGF0aW9uJywgJ3B1bmN0dWF0aW9uJ10pICYmIGdldFRva2VuKDEpLmNvbnRlbnQgPT09ICcoJykge1xuICAgICAgICAvLyBkZWZpbml0aW9uXG4gICAgICAgIGN1cnJlbnRJbmRleCArPSAyOyAvLyBza2lwICdkZWZpbml0aW9uLW11dGF0aW9uJyBhbmQgJ3B1bmN0dWF0aW9uJ1xuXG4gICAgICAgIHZhciBkZWZpbml0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFwoJC8sIC9eXFwpJC8pO1xuXG4gICAgICAgIGlmIChkZWZpbml0aW9uRW5kID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGZpbmQgYWxsIGlucHV0IHZhcmlhYmxlc1xuXG5cbiAgICAgICAgZm9yICg7IGN1cnJlbnRJbmRleCA8IGRlZmluaXRpb25FbmQ7IGN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHQgPSBnZXRUb2tlbigwKTtcblxuICAgICAgICAgIGlmICh0LnR5cGUgPT09ICd2YXJpYWJsZScpIHtcbiAgICAgICAgICAgIGFkZEFsaWFzKHQsICd2YXJpYWJsZS1pbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh0LmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGRlZmluaXRpb25FbmQgKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNUb2tlblR5cGUoWydwdW5jdHVhdGlvbicsICdwcm9wZXJ0eS1xdWVyeSddKSAmJiBnZXRUb2tlbigwKS5jb250ZW50ID09PSAneycpIHtcbiAgICAgICAgY3VycmVudEluZGV4Kys7IC8vIHNraXAgb3BlbmluZyBicmFja2V0XG5cbiAgICAgICAgYWRkQWxpYXMoZ2V0VG9rZW4oMCksICdwcm9wZXJ0eS1tdXRhdGlvbicpO1xuXG4gICAgICAgIGlmIChpbnB1dFZhcmlhYmxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIG11dGF0aW9uRW5kID0gZmluZENsb3NpbmdCcmFja2V0KC9eXFx7JC8sIC9eXFx9JC8pO1xuXG4gICAgICAgICAgaWYgKG11dGF0aW9uRW5kID09PSAtMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBnaXZlIHJlZmVyZW5jZXMgdG8gaW5wdXQgdmFyaWFibGVzIGEgc3BlY2lhbCBhbGlhc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gY3VycmVudEluZGV4OyBpIDwgbXV0YXRpb25FbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhclRva2VuID0gdmFsaWRUb2tlbnNbaV07XG5cbiAgICAgICAgICAgIGlmICh2YXJUb2tlbi50eXBlID09PSAndmFyaWFibGUnICYmIGlucHV0VmFyaWFibGVzLmluZGV4T2YodmFyVG9rZW4uY29udGVudCkgPj0gMCkge1xuICAgICAgICAgICAgICBhZGRBbGlhcyh2YXJUb2tlbiwgJ3ZhcmlhYmxlLWlucHV0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbFwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5zcWwgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98KD86LS18XFwvXFwvfCMpLiopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICd2YXJpYWJsZSc6IFt7XG4gICAgcGF0dGVybjogL0AoW1wiJ2BdKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDEpW15cXFxcXSkrXFwxLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwgL0BbXFx3LiRdKy9dLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXkBcXFxcXSkoXCJ8JykoPzpcXFxcW1xcc1xcU118KD8hXFwyKVteXFxcXF18XFwyXFwyKSpcXDIvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdpZGVudGlmaWVyJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXkBcXFxcXSlgKD86XFxcXFtcXHNcXFNdfFteYFxcXFxdfGBgKSpgLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9eYHxgJC9cbiAgICB9XG4gIH0sXG4gICdmdW5jdGlvbic6IC9cXGIoPzpBVkd8Q09VTlR8RklSU1R8Rk9STUFUfExBU1R8TENBU0V8TEVOfE1BWHxNSUR8TUlOfE1PRHxOT1d8Uk9VTkR8U1VNfFVDQVNFKSg/PVxccypcXCgpL2ksXG4gIC8vIFNob3VsZCB3ZSBoaWdobGlnaHQgdXNlciBkZWZpbmVkIGZ1bmN0aW9ucyB0b28/XG4gICdrZXl3b3JkJzogL1xcYig/OkFDVElPTnxBRER8QUZURVJ8QUxHT1JJVEhNfEFMTHxBTFRFUnxBTkFMWVpFfEFOWXxBUFBMWXxBU3xBU0N8QVVUSE9SSVpBVElPTnxBVVRPX0lOQ1JFTUVOVHxCQUNLVVB8QkRCfEJFR0lOfEJFUktFTEVZREJ8QklHSU5UfEJJTkFSWXxCSVR8QkxPQnxCT09MfEJPT0xFQU58QlJFQUt8QlJPV1NFfEJUUkVFfEJVTEt8Qll8Q0FMTHxDQVNDQURFRD98Q0FTRXxDSEFJTnxDSEFSKD86QUNURVJ8U0VUKT98Q0hFQ0soPzpQT0lOVCk/fENMT1NFfENMVVNURVJFRHxDT0FMRVNDRXxDT0xMQVRFfENPTFVNTlM/fENPTU1FTlR8Q09NTUlUKD86VEVEKT98Q09NUFVURXxDT05ORUNUfENPTlNJU1RFTlR8Q09OU1RSQUlOVHxDT05UQUlOUyg/OlRBQkxFKT98Q09OVElOVUV8Q09OVkVSVHxDUkVBVEV8Q1JPU1N8Q1VSUkVOVCg/Ol9EQVRFfF9USU1FfF9USU1FU1RBTVB8X1VTRVIpP3xDVVJTT1J8Q1lDTEV8REFUQSg/OkJBU0VTPyk/fERBVEUoPzpUSU1FKT98REFZfERCQ0N8REVBTExPQ0FURXxERUN8REVDSU1BTHxERUNMQVJFfERFRkFVTFR8REVGSU5FUnxERUxBWUVEfERFTEVURXxERUxJTUlURVJTP3xERU5ZfERFU0N8REVTQ1JJQkV8REVURVJNSU5JU1RJQ3xESVNBQkxFfERJU0NBUkR8RElTS3xESVNUSU5DVHxESVNUSU5DVFJPV3xESVNUUklCVVRFRHxET3xET1VCTEV8RFJPUHxEVU1NWXxEVU1QKD86RklMRSk/fERVUExJQ0FURXxFTFNFKD86SUYpP3xFTkFCTEV8RU5DTE9TRUR8RU5EfEVOR0lORXxFTlVNfEVSUkxWTHxFUlJPUlN8RVNDQVBFRD98RVhDRVBUfEVYRUMoPzpVVEUpP3xFWElTVFN8RVhJVHxFWFBMQUlOfEVYVEVOREVEfEZFVENIfEZJRUxEU3xGSUxFfEZJTExGQUNUT1J8RklSU1R8RklYRUR8RkxPQVR8Rk9MTE9XSU5HfEZPUig/OiBFQUNIIFJPVyk/fEZPUkNFfEZPUkVJR058RlJFRVRFWFQoPzpUQUJMRSk/fEZST018RlVMTHxGVU5DVElPTnxHRU9NRVRSWSg/OkNPTExFQ1RJT04pP3xHTE9CQUx8R09UT3xHUkFOVHxHUk9VUHxIQU5ETEVSfEhBU0h8SEFWSU5HfEhPTERMT0NLfEhPVVJ8SURFTlRJVFkoPzpDT0x8X0lOU0VSVCk/fElGfElHTk9SRXxJTVBPUlR8SU5ERVh8SU5GSUxFfElOTkVSfElOTk9EQnxJTk9VVHxJTlNFUlR8SU5UfElOVEVHRVJ8SU5URVJTRUNUfElOVEVSVkFMfElOVE98SU5WT0tFUnxJU09MQVRJT058SVRFUkFURXxKT0lOfEtFWVM/fEtJTEx8TEFOR1VBR0V8TEFTVHxMRUFWRXxMRUZUfExFVkVMfExJTUlUfExJTkVOT3xMSU5FU3xMSU5FU1RSSU5HfExPQUR8TE9DQUx8TE9DS3xMT05HKD86QkxPQnxURVhUKXxMT09QfE1BVENIKD86RUQpP3xNRURJVU0oPzpCTE9CfElOVHxURVhUKXxNRVJHRXxNSURETEVJTlR8TUlOVVRFfE1PREV8TU9ESUZJRVN8TU9ESUZZfE1PTlRIfE1VTFRJKD86TElORVNUUklOR3xQT0lOVHxQT0xZR09OKXxOQVRJT05BTHxOQVRVUkFMfE5DSEFSfE5FWFR8Tk98Tk9OQ0xVU1RFUkVEfE5VTExJRnxOVU1FUklDfE9GRj98T0ZGU0VUUz98T058T1BFTig/OkRBVEFTT1VSQ0V8UVVFUll8Uk9XU0VUKT98T1BUSU1JWkV8T1BUSU9OKD86QUxMWSk/fE9SREVSfE9VVCg/OkVSfEZJTEUpP3xPVkVSfFBBUlRJQUx8UEFSVElUSU9OfFBFUkNFTlR8UElWT1R8UExBTnxQT0lOVHxQT0xZR09OfFBSRUNFRElOR3xQUkVDSVNJT058UFJFUEFSRXxQUkVWfFBSSU1BUll8UFJJTlR8UFJJVklMRUdFU3xQUk9DKD86RURVUkUpP3xQVUJMSUN8UFVSR0V8UVVJQ0t8UkFJU0VSUk9SfFJFQURTP3xSRUFMfFJFQ09ORklHVVJFfFJFRkVSRU5DRVN8UkVMRUFTRXxSRU5BTUV8UkVQRUFUKD86QUJMRSk/fFJFUExBQ0V8UkVQTElDQVRJT058UkVRVUlSRXxSRVNJR05BTHxSRVNUT1JFfFJFU1RSSUNUfFJFVFVSTig/OklOR3xTKT98UkVWT0tFfFJJR0hUfFJPTExCQUNLfFJPVVRJTkV8Uk9XKD86Q09VTlR8R1VJRENPTHxTKT98UlRSRUV8UlVMRXxTQVZFKD86UE9JTlQpP3xTQ0hFTUF8U0VDT05EfFNFTEVDVHxTRVJJQUwoPzpJWkFCTEUpP3xTRVNTSU9OKD86X1VTRVIpP3xTRVQoPzpVU0VSKT98U0hBUkV8U0hPV3xTSFVURE9XTnxTSU1QTEV8U01BTExJTlR8U05BUFNIT1R8U09NRXxTT05BTUV8U1FMfFNUQVJUKD86SU5HKT98U1RBVElTVElDU3xTVEFUVVN8U1RSSVBFRHxTWVNURU1fVVNFUnxUQUJMRVM/fFRBQkxFU1BBQ0V8VEVNUCg/Ok9SQVJZfFRBQkxFKT98VEVSTUlOQVRFRHxURVhUKD86U0laRSk/fFRIRU58VElNRSg/OlNUQU1QKT98VElOWSg/OkJMT0J8SU5UfFRFWFQpfFRPUD98VFJBTig/OlNBQ1RJT05TPyk/fFRSSUdHRVJ8VFJVTkNBVEV8VFNFUVVBTHxUWVBFUz98VU5CT1VOREVEfFVOQ09NTUlUVEVEfFVOREVGSU5FRHxVTklPTnxVTklRVUV8VU5MT0NLfFVOUElWT1R8VU5TSUdORUR8VVBEQVRFKD86VEVYVCk/fFVTQUdFfFVTRXxVU0VSfFVTSU5HfFZBTFVFUz98VkFSKD86QklOQVJZfENIQVJ8Q0hBUkFDVEVSfFlJTkcpfFZJRVd8V0FJVEZPUnxXQVJOSU5HU3xXSEVOfFdIRVJFfFdISUxFfFdJVEgoPzogUk9MTFVQfElOKT98V09SS3xXUklURSg/OlRFWFQpP3xZRUFSKVxcYi9pLFxuICAnYm9vbGVhbic6IC9cXGIoPzpGQUxTRXxOVUxMfFRSVUUpXFxiL2ksXG4gICdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrXFxiL2ksXG4gICdvcGVyYXRvcic6IC9bLSsqXFwvPSVefl18JiY/fFxcfFxcfD98IT0/fDwoPzo9Pj98PHw+KT98Pls+PV0/fFxcYig/OkFORHxCRVRXRUVOfERJVnxJTElLRXxJTnxJU3xMSUtFfE5PVHxPUnxSRUdFWFB8UkxJS0V8U09VTkRTIExJS0V8WE9SKVxcYi9pLFxuICAncHVuY3R1YXRpb24nOiAvWztbXFxdKClgLC5dL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzLXRlbXBsYXRlc1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHRlbXBsYXRlU3RyaW5nID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ3RlbXBsYXRlLXN0cmluZyddOyAvLyBzZWUgdGhlIHBhdHRlcm4gaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuXG4gIHZhciB0ZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gdGVtcGxhdGVTdHJpbmcucGF0dGVybi5zb3VyY2U7XG4gIHZhciBpbnRlcnBvbGF0aW9uT2JqZWN0ID0gdGVtcGxhdGVTdHJpbmcuaW5zaWRlWydpbnRlcnBvbGF0aW9uJ107XG4gIHZhciBpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3QgPSBpbnRlcnBvbGF0aW9uT2JqZWN0Lmluc2lkZVsnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbiddO1xuICB2YXIgaW50ZXJwb2xhdGlvblBhdHRlcm4gPSBpbnRlcnBvbGF0aW9uT2JqZWN0LnBhdHRlcm4uc291cmNlO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwYXR0ZXJuIHRvIG1hdGNoIGEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYSBzcGVjaWFsIHRhZy5cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBncmFtbWFyIHdpdGggdGhlIGdpdmVuIGxhbmd1YWdlIGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkIG9mIHRoZSBlbWJlZGRlZCBsYW5ndWFnZS4gRS5nLiBgbWFya2Rvd25gLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSByZWdleCBwYXR0ZXJuIHRvIG1hdGNoIHRoZSB0YWcuXG4gICAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9XG4gICAqIEBleGFtcGxlXG4gICAqIGNyZWF0ZVRlbXBsYXRlKCdjc3MnLCAvXFxiY3NzLy5zb3VyY2UpO1xuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZShsYW5ndWFnZSwgdGFnKSB7XG4gICAgaWYgKCFQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJygoPzonICsgdGFnICsgJylcXFxccyopJyArIHRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL15gfGAkLyxcbiAgICAgICAgICBhbGlhczogJ3N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAgJ2VtYmVkZGVkLWNvZGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6IGxhbmd1YWdlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ3RlbXBsYXRlLXN0cmluZyddID0gWy8vIHN0eWxlZC1qc3g6XG4gIC8vICAgY3NzYGEgeyBjb2xvcjogIzI1RjsgfWBcbiAgLy8gc3R5bGVkLWNvbXBvbmVudHM6XG4gIC8vICAgc3R5bGVkLmgxYGNvbG9yOiByZWQ7YFxuICBjcmVhdGVUZW1wbGF0ZSgnY3NzJywgL1xcYig/OnN0eWxlZCg/OlxcKFteKV0qXFwpKT8oPzpcXHMqXFwuXFxzKlxcdysoPzpcXChbXildKlxcKSkqKSp8Y3NzKD86XFxzKlxcLlxccyooPzpnbG9iYWx8cmVzb2x2ZSkpP3xjcmVhdGVHbG9iYWxTdHlsZXxrZXlmcmFtZXMpLy5zb3VyY2UpLCAvLyBodG1sYDxwPjwvcD5gXG4gIC8vIGRpdi5pbm5lckhUTUwgPSBgPHA+PC9wPmBcbiAgY3JlYXRlVGVtcGxhdGUoJ2h0bWwnLCAvXFxiaHRtbHxcXC5cXHMqKD86aW5uZXJ8b3V0ZXIpSFRNTFxccypcXCs/PS8uc291cmNlKSwgLy8gc3ZnYDxwYXRoIGZpbGw9XCIjZmZmXCIgZD1cIk01NS4zNyAuLi5cIi8+YFxuICBjcmVhdGVUZW1wbGF0ZSgnc3ZnJywgL1xcYnN2Zy8uc291cmNlKSwgLy8gbWRgIyBoMWAsIG1hcmtkb3duYCMjIGgyYFxuICBjcmVhdGVUZW1wbGF0ZSgnbWFya2Rvd24nLCAvXFxiKD86bWFya2Rvd258bWQpLy5zb3VyY2UpLCAvLyBncWxgLi4uYCwgZ3JhcGhxbGAuLi5gLCBncmFwaHFsLmV4cGVyaW1lbnRhbGAuLi5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdncmFwaHFsJywgL1xcYig/OmdxbHxncmFwaHFsKD86XFxzKlxcLlxccypleHBlcmltZW50YWwpPykvLnNvdXJjZSksIC8vIHNxbGAuLi5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdzcWwnLCAvXFxic3FsLy5zb3VyY2UpLCAvLyB2YW5pbGxhIHRlbXBsYXRlIHN0cmluZ1xuICB0ZW1wbGF0ZVN0cmluZ10uZmlsdGVyKEJvb2xlYW4pO1xuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmljIHBsYWNlaG9sZGVyIGxpdGVyYWwgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyKGNvdW50ZXIsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuICdfX18nICsgbGFuZ3VhZ2UudG9VcHBlckNhc2UoKSArICdfJyArIGNvdW50ZXIgKyAnX19fJztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9rZW5zIG9mIGBQcmlzbS50b2tlbml6ZWAgYnV0IGFsc28gcnVucyB0aGUgYGJlZm9yZS10b2tlbml6ZWAgYW5kIGBhZnRlci10b2tlbml6ZWAgaG9va3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyB7KHN0cmluZ3xUb2tlbilbXX1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZVdpdGhIb29rcyhjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgIHZhciBlbnYgPSB7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZVxuICAgIH07XG4gICAgUHJpc20uaG9va3MucnVuKCdiZWZvcmUtdG9rZW5pemUnLCBlbnYpO1xuICAgIGVudi50b2tlbnMgPSBQcmlzbS50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuICAgIFByaXNtLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCBlbnYpO1xuICAgIHJldHVybiBlbnYudG9rZW5zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b2tlbiBvZiB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBjb2RlIG9mIHRoZSBleHByZXNzaW9uLiBFLmcuIGBcIiR7NDJ9XCJgXG4gICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgdGVtcEdyYW1tYXIgPSB7fTtcbiAgICB0ZW1wR3JhbW1hclsnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbiddID0gaW50ZXJwb2xhdGlvblB1bmN0dWF0aW9uT2JqZWN0O1xuICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG5cbiAgICB2YXIgdG9rZW5zID0gUHJpc20udG9rZW5pemUoZXhwcmVzc2lvbiwgdGVtcEdyYW1tYXIpO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRva2VuIGFycmF5IHdpbGwgbG9vayBsaWtlIHRoaXNcbiAgICAgICAqIFtcbiAgICAgICAqICAgICBbXCJpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uXCIsIFwiJHtcIl1cbiAgICAgICAqICAgICBcIi4uLlwiIC8vIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBvZiB0aGUgaW50ZXJwb2xhdGlvblxuICAgICAgICogICAgIFtcImludGVycG9sYXRpb24tcHVuY3R1YXRpb25cIiwgXCJ9XCJdXG4gICAgICAgKiBdXG4gICAgICAgKi9cbiAgICAgIHZhciBhcmdzID0gWzEsIDFdO1xuICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIHRva2VuaXplV2l0aEhvb2tzKHRva2Vuc1sxXSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsICdqYXZhc2NyaXB0JykpO1xuICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIGFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJpc20uVG9rZW4oJ2ludGVycG9sYXRpb24nLCB0b2tlbnMsIGludGVycG9sYXRpb25PYmplY3QuYWxpYXMsIGV4cHJlc3Npb24pO1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbml6ZXMgdGhlIGdpdmVuIGNvZGUgd2l0aCBzdXBwb3J0IGZvciBKYXZhU2NyaXB0IGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMgbWl4ZWQgaW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaGFzIDMgcGhhc2VzOlxuICAgKlxuICAgKiAxLiBSZXBsYWNlIGFsbCBKYXZhU2NyaXB0IGludGVycG9sYXRpb24gZXhwcmVzc2lvbiB3aXRoIGEgcGxhY2Vob2xkZXIuXG4gICAqICAgIFRoZSBwbGFjZWhvbGRlciB3aWxsIGhhdmUgdGhlIHN5bnRheCBvZiBhIGlkZW50aWZ5IG9mIHRoZSB0YXJnZXQgbGFuZ3VhZ2UuXG4gICAqIDIuIFRva2VuaXplIHRoZSBjb2RlIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgKiAzLiBUb2tlbml6ZSB0aGUgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucyBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgdG9rZW5pemUgY29kZS5cbiAgICogICAgVGhlIGluc2VydGlvbiBvbmx5IHdvcmtzIGlmIGEgcGxhY2Vob2xkZXIgaGFzbid0IGJlZW4gXCJyaXBwZWQgYXBhcnRcIiBtZWFuaW5nIHRoYXQgdGhlIHBsYWNlaG9sZGVyIGhhcyBiZWVuXG4gICAqICAgIHRva2VuaXplZCBhcyB0d28gdG9rZW5zIGJ5IHRoZSBncmFtbWFyIG9mIHRoZSBlbWJlZGRlZCBsYW5ndWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGdyYW1tYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiB0b2tlbml6ZUVtYmVkZGVkKGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgLy8gMS4gRmlyc3QgZmlsdGVyIG91dCBhbGwgaW50ZXJwb2xhdGlvbnNcbiAgICAvLyBiZWNhdXNlIHRoZXkgbWlnaHQgYmUgZXNjYXBlZCwgd2UgbmVlZCBhIGxvb2tiZWhpbmQsIHNvIHdlIHVzZSBQcmlzbVxuXG4gICAgLyoqIEB0eXBlIHsoVG9rZW58c3RyaW5nKVtdfSAqL1xuICAgIHZhciBfdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cChpbnRlcnBvbGF0aW9uUGF0dGVybiksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gcmVwbGFjZSBhbGwgaW50ZXJwb2xhdGlvbnMgd2l0aCBhIHBsYWNlaG9sZGVyIHdoaWNoIGlzIG5vdCBpbiB0aGUgY29kZSBhbHJlYWR5XG5cblxuICAgIHZhciBwbGFjZWhvbGRlckNvdW50ZXIgPSAwO1xuICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cblxuICAgIHZhciBwbGFjZWhvbGRlck1hcCA9IHt9O1xuXG4gICAgdmFyIGVtYmVkZGVkQ29kZSA9IF90b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb25FeHByZXNzaW9uID0gdG9rZW4uY29udGVudDtcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyO1xuXG4gICAgICAgIHdoaWxlIChjb2RlLmluZGV4T2YocGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlckNvdW50ZXIrKywgbGFuZ3VhZ2UpKSAhPT0gLTEpIHtcbiAgICAgICAgICAvKiBub29wICovXG4gICAgICAgIH1cblxuICAgICAgICBwbGFjZWhvbGRlck1hcFtwbGFjZWhvbGRlcl0gPSBpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbjtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpOyAvLyAyLiBUb2tlbml6ZSB0aGUgZW1iZWRkZWQgY29kZVxuXG5cbiAgICB2YXIgZW1iZWRkZWRUb2tlbnMgPSB0b2tlbml6ZVdpdGhIb29rcyhlbWJlZGRlZENvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKTsgLy8gMy4gUmUtaW5zZXJ0IHRoZSBpbnRlcnBvbGF0aW9uXG5cbiAgICB2YXIgcGxhY2Vob2xkZXJzID0gT2JqZWN0LmtleXMocGxhY2Vob2xkZXJNYXApO1xuICAgIHBsYWNlaG9sZGVyQ291bnRlciA9IDA7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhUb2tlbnxzdHJpbmcpW119IHRva2Vuc1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gd2Fsa1Rva2Vucyh0b2tlbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwbGFjZWhvbGRlckNvdW50ZXIgPj0gcGxhY2Vob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcnNbcGxhY2Vob2xkZXJDb3VudGVyXTtcbiAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6XG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICAgICAgdG9rZW4uY29udGVudDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBzLmluZGV4T2YocGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgKytwbGFjZWhvbGRlckNvdW50ZXI7XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gcy5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IHRva2VuaXplSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24ocGxhY2Vob2xkZXJNYXBbcGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyVG9rZW5zID0gW2FmdGVyXTtcbiAgICAgICAgICAgICAgd2Fsa1Rva2VucyhhZnRlclRva2Vucyk7XG4gICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIGFmdGVyVG9rZW5zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIFtpLCAxXS5jb25jYXQocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgICAgICAgaSArPSByZXBsYWNlbWVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICAgICAgd2Fsa1Rva2Vucyhjb250ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Fsa1Rva2VucyhbY29udGVudF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdhbGtUb2tlbnMoZW1iZWRkZWRUb2tlbnMpO1xuICAgIHJldHVybiBuZXcgUHJpc20uVG9rZW4obGFuZ3VhZ2UsIGVtYmVkZGVkVG9rZW5zLCAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlLCBjb2RlKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGxhbmd1YWdlcyBmb3Igd2hpY2ggSlMgdGVtcGxhdGluZyB3aWxsIGhhbmRsZSB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEpTIHRlbXBsYXRpbmcgaXNuJ3QgYWN0aXZlIGZvciBvbmx5IEphdmFTY3JpcHQgYnV0IGFsc28gcmVsYXRlZCBsYW5ndWFnZXMgbGlrZSBUeXBlU2NyaXB0LCBKU1gsIGFuZCBUU1guXG4gICAqL1xuXG5cbiAgdmFyIHN1cHBvcnRlZExhbmd1YWdlcyA9IHtcbiAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgJ2pzJzogdHJ1ZSxcbiAgICAndHlwZXNjcmlwdCc6IHRydWUsXG4gICAgJ3RzJzogdHJ1ZSxcbiAgICAnanN4JzogdHJ1ZSxcbiAgICAndHN4JzogdHJ1ZVxuICB9O1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmICghKGVudi5sYW5ndWFnZSBpbiBzdXBwb3J0ZWRMYW5ndWFnZXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFuZCB0b2tlbml6ZXMgYWxsIHRlbXBsYXRlIHN0cmluZ3Mgd2l0aCBhbiBlbWJlZGRlZCBsYW5ndWFnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhUb2tlbiB8IHN0cmluZylbXX0gdG9rZW5zXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGZpbmRUZW1wbGF0ZVN0cmluZ3ModG9rZW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmluZFRlbXBsYXRlU3RyaW5ncyhbY29udGVudF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZW1wbGF0ZS1zdHJpbmcnKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQSBKYXZhU2NyaXB0IHRlbXBsYXRlLXN0cmluZyB0b2tlbiB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogW1widGVtcGxhdGUtc3RyaW5nXCIsIFtcbiAgICAgICAgICAgKiAgICAgW1widGVtcGxhdGUtcHVuY3R1YXRpb25cIiwgXCJgXCJdLFxuICAgICAgICAgICAqICAgICAoXG4gICAgICAgICAgICogICAgICAgICBBbiBhcnJheSBvZiBcInN0cmluZ1wiIGFuZCBcImludGVycG9sYXRpb25cIiB0b2tlbnMuIFRoaXMgaXMgdGhlIHNpbXBsZSBzdHJpbmcgY2FzZS5cbiAgICAgICAgICAgKiAgICAgICAgIG9yXG4gICAgICAgICAgICogICAgICAgICBbXCJlbWJlZGRlZC1jb2RlXCIsIFwiLi4uXCJdIFRoaXMgaXMgdGhlIHRva2VuIGNvbnRhaW5pbmcgdGhlIGVtYmVkZGVkIGNvZGUuXG4gICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSXQgYWxzbyBoYXMgYW4gYWxpYXMgd2hpY2ggaXMgdGhlIGxhbmd1YWdlIG9mIHRoZSBlbWJlZGRlZCBjb2RlLlxuICAgICAgICAgICAqICAgICApLFxuICAgICAgICAgICAqICAgICBbXCJ0ZW1wbGF0ZS1wdW5jdHVhdGlvblwiLCBcImBcIl1cbiAgICAgICAgICAgKiBdXVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBlbWJlZGRlZCA9IGNvbnRlbnRbMV07XG5cbiAgICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGVtYmVkZGVkICE9PSAnc3RyaW5nJyAmJiBlbWJlZGRlZC50eXBlID09PSAnZW1iZWRkZWQtY29kZScpIHtcbiAgICAgICAgICAgIC8vIGdldCBzdHJpbmcgY29udGVudFxuICAgICAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmdDb250ZW50KGVtYmVkZGVkKTtcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IGVtYmVkZGVkLmFsaWFzO1xuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gQXJyYXkuaXNBcnJheShhbGlhcykgPyBhbGlhc1swXSA6IGFsaWFzO1xuICAgICAgICAgICAgdmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXG4gICAgICAgICAgICBpZiAoIWdyYW1tYXIpIHtcbiAgICAgICAgICAgICAgLy8gdGhlIGVtYmVkZGVkIGxhbmd1YWdlIGlzbid0IHJlZ2lzdGVyZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50WzFdID0gdG9rZW5pemVFbWJlZGRlZChjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbmRUZW1wbGF0ZVN0cmluZ3MoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5kVGVtcGxhdGVTdHJpbmdzKGVudi50b2tlbnMpO1xuICB9KTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyBjb250ZW50IG9mIGEgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgKHN0cmluZyB8IFRva2VuKVtdfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiBzdHJpbmdDb250ZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKHN0cmluZ0NvbnRlbnQpLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyaW5nQ29udGVudCh2YWx1ZS5jb250ZW50KTtcbiAgICB9XG4gIH1cbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHRcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqYXZhc2NyaXB0Jywge1xuICAgICdjbGFzcy1uYW1lJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHR5cGUpXFxzKykoPyFrZXlvZlxcYikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD86XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4pPy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXG4gICAgfSxcbiAgICAnYnVpbHRpbic6IC9cXGIoPzpBcnJheXxGdW5jdGlvbnxQcm9taXNlfGFueXxib29sZWFufGNvbnNvbGV8bmV2ZXJ8bnVtYmVyfHN0cmluZ3xzeW1ib2x8dW5rbm93bilcXGIvXG4gIH0pOyAvLyBUaGUga2V5d29yZHMgVHlwZVNjcmlwdCBhZGRzIHRvIEphdmFTY3JpcHRcblxuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goL1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLCAvLyBrZXl3b3JkcyB0aGF0IGhhdmUgdG8gYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllclxuICAvXFxiKD86YXNzZXJ0c3xpbmZlcnxpbnRlcmZhY2V8bW9kdWxlfG5hbWVzcGFjZXx0eXBlKVxcYig/PVxccyooPzpbe18kYS16QS1aXFx4QTAtXFx1RkZGRl18JCkpLywgLy8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuICAvXFxidHlwZVxcYig/PVxccyooPzpbXFx7Kl18JCkpLyk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIFRTIGJlY2F1c2UgVFMgaXMgdG9vIGNvbXBsZXhcblxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTsgLy8gYSB2ZXJzaW9uIG9mIHR5cGVzY3JpcHQgc3BlY2lmaWNhbGx5IGZvciBoaWdobGlnaHRpbmcgdHlwZXNcblxuICB2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG4gIGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydjbGFzcy1uYW1lJ10uaW5zaWRlID0gdHlwZUluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgndHlwZXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAnZGVjb3JhdG9yJzoge1xuICAgICAgcGF0dGVybjogL0BbJFxcd1xceEEwLVxcdUZGRkZdKy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eQC8sXG4gICAgICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIC8vIGUuZy4gZm9vPFQgZXh0ZW5kcyBcImJhclwiIHwgXCJiYXpcIj4oIC4uLlxuICAgICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KD89XFxzKlxcKCkvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9eIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IDxcbiAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgIGluc2lkZTogdHlwZUluc2lkZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnRzID0gUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qcy1leHRyYXNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdmdW5jdGlvbi12YXJpYWJsZScsIHtcbiAgICAnbWV0aG9kLXZhcmlhYmxlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXC5cXFxccyopJyArIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydmdW5jdGlvbi12YXJpYWJsZSddLnBhdHRlcm4uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogWydmdW5jdGlvbi12YXJpYWJsZScsICdtZXRob2QnLCAnZnVuY3Rpb24nLCAncHJvcGVydHktYWNjZXNzJ11cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2Z1bmN0aW9uJywge1xuICAgICdtZXRob2QnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhcXFxcLlxcXFxzKiknICsgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2Z1bmN0aW9uJ10uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogWydmdW5jdGlvbicsICdwcm9wZXJ0eS1hY2Nlc3MnXVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnY29uc3RhbnQnLCB7XG4gICAgJ2tub3duLWNsYXNzLW5hbWUnOiBbe1xuICAgICAgLy8gc3RhbmRhcmQgYnVpbHQtaW5zXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0c1xuICAgICAgcGF0dGVybjogL1xcYig/Oig/OkZsb2F0KD86MzJ8NjQpfCg/OkludHxVaW50KSg/Ojh8MTZ8MzIpfFVpbnQ4Q2xhbXBlZCk/QXJyYXl8QXJyYXlCdWZmZXJ8QmlnSW50fEJvb2xlYW58RGF0YVZpZXd8RGF0ZXxFcnJvcnxGdW5jdGlvbnxJbnRsfEpTT058KD86V2Vhayk/KD86TWFwfFNldCl8TWF0aHxOdW1iZXJ8T2JqZWN0fFByb21pc2V8UHJveHl8UmVmbGVjdHxSZWdFeHB8U3RyaW5nfFN5bWJvbHxXZWJBc3NlbWJseSlcXGIvLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH0sIHtcbiAgICAgIC8vIGVycm9yc1xuICAgICAgcGF0dGVybjogL1xcYig/OltBLVpdXFx3KilFcnJvclxcYi8sXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfV1cbiAgfSk7XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgYDxJRD5gIHBsYWNlaG9sZGVyIGluIHRoZSBnaXZlbiBwYXR0ZXJuIHdpdGggYSBwYXR0ZXJuIGZvciBnZW5lcmFsIEpTIGlkZW50aWZpZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHdpdGhJZChzb3VyY2UsIGZsYWdzKSB7XG4gICAgcmV0dXJuIFJlZ0V4cChzb3VyY2UucmVwbGFjZSgvPElEPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSovLnNvdXJjZTtcbiAgICB9KSwgZmxhZ3MpO1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAgICdpbXBvcnRzJzoge1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pbXBvcnRzXG4gICAgICBwYXR0ZXJuOiB3aXRoSWQoLyhcXGJpbXBvcnRcXGJcXHMqKSg/OjxJRD4oPzpcXHMqLFxccyooPzpcXCpcXHMqYXNcXHMrPElEPnxcXHtbXnt9XSpcXH0pKT98XFwqXFxzKmFzXFxzKzxJRD58XFx7W157fV0qXFx9KSg/PVxccypcXGJmcm9tXFxiKS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgfSxcbiAgICAnZXhwb3J0cyc6IHtcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZXhwb3J0c1xuICAgICAgcGF0dGVybjogd2l0aElkKC8oXFxiZXhwb3J0XFxiXFxzKikoPzpcXCooPzpcXHMqYXNcXHMrPElEPik/KD89XFxzKlxcYmZyb21cXGIpfFxce1tee31dKlxcfSkvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydrZXl3b3JkJ10udW5zaGlmdCh7XG4gICAgcGF0dGVybjogL1xcYig/OmFzfGRlZmF1bHR8ZXhwb3J0fGZyb218aW1wb3J0KVxcYi8sXG4gICAgYWxpYXM6ICdtb2R1bGUnXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXdhaXR8YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxpZnxyZXR1cm58c3dpdGNofHRocm93fHRyeXx3aGlsZXx5aWVsZClcXGIvLFxuICAgIGFsaWFzOiAnY29udHJvbC1mbG93J1xuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiBbJ251bGwnLCAnbmlsJ11cbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXGJ1bmRlZmluZWRcXGIvLFxuICAgIGFsaWFzOiAnbmlsJ1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdvcGVyYXRvcicsIHtcbiAgICAnc3ByZWFkJzoge1xuICAgICAgcGF0dGVybjogL1xcLnszfS8sXG4gICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgIH0sXG4gICAgJ2Fycm93Jzoge1xuICAgICAgcGF0dGVybjogLz0+LyxcbiAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdwdW5jdHVhdGlvbicsIHtcbiAgICAncHJvcGVydHktYWNjZXNzJzoge1xuICAgICAgcGF0dGVybjogd2l0aElkKC8oXFwuXFxzKikjPzxJRD4vLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnbWF5YmUtY2xhc3MtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSlbQS1aXVskXFx3XFx4QTAtXFx1RkZGRl0rLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdkb20nOiB7XG4gICAgICAvLyB0aGlzIGNvbnRhaW5zIG9ubHkgYSBmZXcgY29tbW9ubHkgdXNlZCBET00gdmFyaWFibGVzXG4gICAgICBwYXR0ZXJuOiAvXFxiKD86ZG9jdW1lbnR8KD86bG9jYWx8c2Vzc2lvbilTdG9yYWdlfGxvY2F0aW9ufG5hdmlnYXRvcnxwZXJmb3JtYW5jZXx3aW5kb3cpXFxiLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnXG4gICAgfSxcbiAgICAnY29uc29sZSc6IHtcbiAgICAgIHBhdHRlcm46IC9cXGJjb25zb2xlKD89XFxzKlxcLikvLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH1cbiAgfSk7IC8vIGFkZCAnbWF5YmUtY2xhc3MtbmFtZScgdG8gdG9rZW5zIHdoaWNoIG1pZ2h0IGJlIGEgY2xhc3MgbmFtZVxuXG4gIHZhciBtYXliZUNsYXNzTmFtZVRva2VucyA9IFsnZnVuY3Rpb24nLCAnZnVuY3Rpb24tdmFyaWFibGUnLCAnbWV0aG9kJywgJ21ldGhvZC12YXJpYWJsZScsICdwcm9wZXJ0eS1hY2Nlc3MnXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heWJlQ2xhc3NOYW1lVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gbWF5YmVDbGFzc05hbWVUb2tlbnNbaV07XG4gICAgdmFyIHZhbHVlID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbdG9rZW5dOyAvLyBjb252ZXJ0IHJlZ2V4IHRvIG9iamVjdFxuXG4gICAgaWYgKFByaXNtLnV0aWwudHlwZSh2YWx1ZSkgPT09ICdSZWdFeHAnKSB7XG4gICAgICB2YWx1ZSA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0W3Rva2VuXSA9IHtcbiAgICAgICAgcGF0dGVybjogdmFsdWVcbiAgICAgIH07XG4gICAgfSAvLyBrZWVwIGluIG1pbmQgdGhhdCB3ZSBkb24ndCBzdXBwb3J0IGFycmF5c1xuXG5cbiAgICB2YXIgaW5zaWRlID0gdmFsdWUuaW5zaWRlIHx8IHt9O1xuICAgIHZhbHVlLmluc2lkZSA9IGluc2lkZTtcbiAgICBpbnNpZGVbJ21heWJlLWNsYXNzLW5hbWUnXSA9IC9eW0EtWl1bXFxzXFxTXSovO1xuICB9XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qc3hcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGphdmFzY3JpcHQgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcbiAgdmFyIHNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKig/IS4pfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSlcXCpcXC8pLy5zb3VyY2U7XG4gIHZhciBicmFjZXMgPSAvKD86XFx7KD86XFx7KD86XFx7W157fV0qXFx9fFtee31dKSpcXH18W157fV0pKlxcfSkvLnNvdXJjZTtcbiAgdmFyIHNwcmVhZCA9IC8oPzpcXHs8Uz4qXFwuezN9KD86W157fV18PEJSQUNFUz4pKlxcfSkvLnNvdXJjZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmUoc291cmNlLCBmbGFncykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKC88Uz4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwYWNlO1xuICAgIH0pLnJlcGxhY2UoLzxCUkFDRVM+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBicmFjZXM7XG4gICAgfSkucmVwbGFjZSgvPFNQUkVBRD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNwcmVhZDtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKHNvdXJjZSwgZmxhZ3MpO1xuICB9XG5cbiAgc3ByZWFkID0gcmUoc3ByZWFkKS5zb3VyY2U7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCBqYXZhc2NyaXB0KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcucGF0dGVybiA9IHJlKC88XFwvPyg/OltcXHcuOi1dKyg/OjxTPisoPzpbXFx3LjokLV0rKD86PSg/OlwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCJ8Jyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJ3xbXlxcc3snXCIvPj1dK3w8QlJBQ0VTPikpP3w8U1BSRUFEPikpKjxTPipcXC8/KT8+Ly5zb3VyY2UpO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ3RhZyddLnBhdHRlcm4gPSAvXjxcXC8/W15cXHM+XFwvXSovO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2F0dHItdmFsdWUnXS5wYXR0ZXJuID0gLz0oPyFcXHspKD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzJ1wiPl0rKS87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10uaW5zaWRlWydjbGFzcy1uYW1lJ10gPSAvXltBLVpdXFx3Kig/OlxcLltBLVpdXFx3KikqJC87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnY29tbWVudCddID0gamF2YXNjcmlwdFsnY29tbWVudCddO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnYXR0ci1uYW1lJywge1xuICAgICdzcHJlYWQnOiB7XG4gICAgICBwYXR0ZXJuOiByZSgvPFNQUkVBRD4vLnNvdXJjZSksXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qc3hcbiAgICB9XG4gIH0sIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnKTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ3NwZWNpYWwtYXR0cicsIHtcbiAgICAnc2NyaXB0Jzoge1xuICAgICAgLy8gQWxsb3cgZm9yIHR3byBsZXZlbHMgb2YgbmVzdGluZ1xuICAgICAgcGF0dGVybjogcmUoLz08QlJBQ0VTPi8uc291cmNlKSxcbiAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCcsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3NjcmlwdC1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXj0oPz1cXHspLyxcbiAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuanN4XG4gICAgICB9XG4gICAgfVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7IC8vIFRoZSBmb2xsb3dpbmcgd2lsbCBoYW5kbGUgcGxhaW4gdGV4dCBpbnNpZGUgdGFnc1xuXG4gIHZhciBzdHJpbmdpZnlUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGlmICghdG9rZW4pIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0b2tlbi5jb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbi5jb250ZW50Lm1hcChzdHJpbmdpZnlUb2tlbikuam9pbignJyk7XG4gIH07XG5cbiAgdmFyIHdhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gICAgdmFyIG9wZW5lZFRhZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICB2YXIgbm90VGFnTm9yQnJhY2UgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICd0YWcnICYmIHRva2VuLmNvbnRlbnRbMF0gJiYgdG9rZW4uY29udGVudFswXS50eXBlID09PSAndGFnJykge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgdGFnLCBub3cgZmluZCBpdHMga2luZFxuICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMF0uY29udGVudCA9PT0gJzwvJykge1xuICAgICAgICAgICAgLy8gQ2xvc2luZyB0YWdcbiAgICAgICAgICAgIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLnRhZ05hbWUgPT09IHN0cmluZ2lmeVRva2VuKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFsxXSkpIHtcbiAgICAgICAgICAgICAgLy8gUG9wIG1hdGNoaW5nIG9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgIG9wZW5lZFRhZ3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5jb250ZW50W3Rva2VuLmNvbnRlbnQubGVuZ3RoIC0gMV0uY29udGVudCA9PT0gJy8+JykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgb3BlbmVkVGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pLFxuICAgICAgICAgICAgICAgIG9wZW5lZEJyYWNlczogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ3snKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGVudGVyZWQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzKys7XG4gICAgICAgIH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ30nKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBtaWdodCBoYXZlIGxlZnQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcbiAgICAgICAgICBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90VGFnTm9yQnJhY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub3RUYWdOb3JCcmFjZSB8fCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgIC8vIEhlcmUgd2UgYXJlIGluc2lkZSBhIHRhZywgYW5kIG5vdCBpbnNpZGUgYSBKU1ggY29udGV4dC5cbiAgICAgICAgICAvLyBUaGF0J3MgcGxhaW4gdGV4dDogZHJvcCBhbnkgdG9rZW5zIG1hdGNoZWQuXG4gICAgICAgICAgdmFyIHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2VuKTsgLy8gQW5kIG1lcmdlIHRleHQgd2l0aCBhZGphY2VudCB0ZXh0XG5cbiAgICAgICAgICBpZiAoaSA8IHRva2Vucy5sZW5ndGggLSAxICYmICh0eXBlb2YgdG9rZW5zW2kgKyAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgKyAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG4gICAgICAgICAgICBwbGFpblRleHQgKz0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgKyAxXSk7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA+IDAgJiYgKHR5cGVvZiB0b2tlbnNbaSAtIDFdID09PSAnc3RyaW5nJyB8fCB0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICdwbGFpbi10ZXh0JykpIHtcbiAgICAgICAgICAgIHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2Vuc1tpIC0gMV0pICsgcGxhaW5UZXh0O1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zW2ldID0gbmV3IFByaXNtLlRva2VuKCdwbGFpbi10ZXh0JywgcGxhaW5UZXh0LCBudWxsLCBwbGFpblRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5jb250ZW50ICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdqc3gnICYmIGVudi5sYW5ndWFnZSAhPT0gJ3RzeCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YWxrVG9rZW5zKGVudi50b2tlbnMpO1xuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWRpZmZcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmRpZmYgPSB7XG4gICAgJ2Nvb3JkJzogWy8vIE1hdGNoIGFsbCBraW5kcyBvZiBjb29yZCBsaW5lcyAocHJlZml4ZWQgYnkgXCIrKytcIiwgXCItLS1cIiBvciBcIioqKlwiKS5cbiAgICAvXig/OlxcKnszfXwtezN9fFxcK3szfSkuKiQvbSwgLy8gTWF0Y2ggXCJAQCAuLi4gQEBcIiBjb29yZCBsaW5lcyBpbiB1bmlmaWVkIGRpZmYuXG4gICAgL15AQC4qQEAkL20sIC8vIE1hdGNoIGNvb3JkIGxpbmVzIGluIG5vcm1hbCBkaWZmIChzdGFydHMgd2l0aCBhIG51bWJlcikuXG4gICAgL15cXGQuKiQvbV0gLy8gZGVsZXRlZCwgaW5zZXJ0ZWQsIHVuY2hhbmdlZCwgZGlmZlxuXG4gIH07XG4gIC8qKlxuICAgKiBBIG1hcCBmcm9tIHRoZSBuYW1lIG9mIGEgYmxvY2sgdG8gaXRzIGxpbmUgcHJlZml4LlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG5cbiAgdmFyIFBSRUZJWEVTID0ge1xuICAgICdkZWxldGVkLXNpZ24nOiAnLScsXG4gICAgJ2RlbGV0ZWQtYXJyb3cnOiAnPCcsXG4gICAgJ2luc2VydGVkLXNpZ24nOiAnKycsXG4gICAgJ2luc2VydGVkLWFycm93JzogJz4nLFxuICAgICd1bmNoYW5nZWQnOiAnICcsXG4gICAgJ2RpZmYnOiAnISdcbiAgfTsgLy8gYWRkIGEgdG9rZW4gZm9yIGVhY2ggcHJlZml4XG5cbiAgT2JqZWN0LmtleXMoUFJFRklYRVMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcHJlZml4ID0gUFJFRklYRVNbbmFtZV07XG4gICAgdmFyIGFsaWFzID0gW107XG5cbiAgICBpZiAoIS9eXFx3KyQvLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIFwiZGVsZXRlZC1zaWduXCIgLT4gXCJkZWxldGVkXCJcbiAgICAgIGFsaWFzLnB1c2goL1xcdysvLmV4ZWMobmFtZSlbMF0pO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnZGlmZicpIHtcbiAgICAgIGFsaWFzLnB1c2goJ2JvbGQnKTtcbiAgICB9XG5cbiAgICBQcmlzbS5sYW5ndWFnZXMuZGlmZltuYW1lXSA9IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXig/OlsnICsgcHJlZml4ICsgJ10uKig/Olxcclxcbj98XFxufCg/IVtcXFxcc1xcXFxTXSkpKSsnLCAnbScpLFxuICAgICAgYWxpYXM6IGFsaWFzLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdsaW5lJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oLikoPz1bXFxzXFxTXSkuKig/Olxcclxcbj98XFxuKT8vLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByZWZpeCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvW1xcc1xcU10vLFxuICAgICAgICAgIGFsaWFzOiAvXFx3Ky8uZXhlYyhuYW1lKVswXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSk7IC8vIG1ha2UgcHJlZml4ZXMgYXZhaWxhYmxlIHRvIERpZmYgcGx1Z2luXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5kaWZmLCAnUFJFRklYRVMnLCB7XG4gICAgdmFsdWU6IFBSRUZJWEVTXG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ2l0XCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuZ2l0ID0ge1xuICAvKlxuICAgKiBBIHNpbXBsZSBvbmUgbGluZSBjb21tZW50IGxpa2UgaW4gYSBnaXQgc3RhdHVzIGNvbW1hbmRcbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBzdGF0dXNcbiAgICogIyBPbiBicmFuY2ggaW5maW5pdGUtc2Nyb2xsXG4gICAqICMgWW91ciBicmFuY2ggYW5kICdvcmlnaW4vc2hhcmVkQnJhbmNoZXMvZnJvbnRlbmRUZWFtL2luZmluaXRlLXNjcm9sbCcgaGF2ZSBkaXZlcmdlZCxcbiAgICogIyBhbmQgaGF2ZSAxIGFuZCAyIGRpZmZlcmVudCBjb21taXRzIGVhY2gsIHJlc3BlY3RpdmVseS5cbiAgICogbm90aGluZyB0byBjb21taXQgKHdvcmtpbmcgZGlyZWN0b3J5IGNsZWFuKVxuICAgKi9cbiAgJ2NvbW1lbnQnOiAvXiMuKi9tLFxuXG4gIC8qXG4gICAqIFJlZ2V4cCB0byBtYXRjaCB0aGUgY2hhbmdlZCBsaW5lcyBpbiBhIGdpdCBkaWZmIG91dHB1dC4gQ2hlY2sgdGhlIGV4YW1wbGUgYmVsb3cuXG4gICAqL1xuICAnZGVsZXRlZCc6IC9eWy3igJNdLiovbSxcbiAgJ2luc2VydGVkJzogL15cXCsuKi9tLFxuXG4gIC8qXG4gICAqIGEgc3RyaW5nIChkb3VibGUgYW5kIHNpbXBsZSBxdW90ZSlcbiAgICovXG4gICdzdHJpbmcnOiAvKFwifCcpKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG5cbiAgLypcbiAgICogYSBnaXQgY29tbWFuZC4gSXQgc3RhcnRzIHdpdGggYSByYW5kb20gcHJvbXB0IGZpbmlzaGluZyBieSBhICQsIHRoZW4gXCJnaXRcIiB0aGVuIHNvbWUgb3RoZXIgcGFyYW1ldGVyc1xuICAgKiBGb3IgaW5zdGFuY2U6XG4gICAqICQgZ2l0IGFkZCBmaWxlLnR4dFxuICAgKi9cbiAgJ2NvbW1hbmQnOiB7XG4gICAgcGF0dGVybjogL14uKlxcJCBnaXQgLiokL20sXG4gICAgaW5zaWRlOiB7XG4gICAgICAvKlxuICAgICAgICogQSBnaXQgY29tbWFuZCBjYW4gY29udGFpbiBhIHBhcmFtZXRlciBzdGFydGluZyBieSBhIHNpbmdsZSBvciBhIGRvdWJsZSBkYXNoIGZvbGxvd2VkIGJ5IGEgc3RyaW5nXG4gICAgICAgKiBGb3IgaW5zdGFuY2U6XG4gICAgICAgKiAkIGdpdCBkaWZmIC0tY2FjaGVkXG4gICAgICAgKiAkIGdpdCBsb2cgLXBcbiAgICAgICAqL1xuICAgICAgJ3BhcmFtZXRlcic6IC9cXHMtLT9cXHcrL1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBDb29yZGluYXRlcyBkaXNwbGF5ZWQgaW4gYSBnaXQgZGlmZiBjb21tYW5kXG4gICAqIEZvciBpbnN0YW5jZTpcbiAgICogJCBnaXQgZGlmZlxuICAgKiBkaWZmIC0tZ2l0IGZpbGUudHh0IGZpbGUudHh0XG4gICAqIGluZGV4IDYyMTQ5NTMuLjFkNTRhNTIgMTAwNjQ0XG4gICAqIC0tLSBmaWxlLnR4dFxuICAgKiArKysgZmlsZS50eHRcbiAgICogQEAgLTEgKzEsMiBAQFxuICAgKiAtSGVyZSdzIG15IHRldHggZmlsZVxuICAgKiArSGVyZSdzIG15IHRleHQgZmlsZVxuICAgKiArQW5kIHRoaXMgaXMgdGhlIHNlY29uZCBsaW5lXG4gICAqL1xuICAnY29vcmQnOiAvXkBALipAQCQvbSxcblxuICAvKlxuICAgKiBNYXRjaCBhIFwiY29tbWl0IFtTSEExXVwiIGxpbmUgaW4gYSBnaXQgbG9nIG91dHB1dC5cbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBsb2dcbiAgICogY29tbWl0IGExMWExNGVmN2UyNmYyY2E2MmQ0YjM1ZWFjNDU1Y2U2MzZkMGRjMDlcbiAgICogQXV0aG9yOiBsZ2lyYXVkZWxcbiAgICogRGF0ZTogICBNb24gRmViIDE3IDExOjE4OjM0IDIwMTQgKzAxMDBcbiAgICpcbiAgICogICAgIEFkZCBvZiBhIG5ldyBsaW5lXG4gICAqL1xuICAnY29tbWl0LXNoYTEnOiAvXmNvbW1pdCBcXHd7NDB9JC9tXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ29cIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMuZ28gPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXCJcXFxcXFxyXFxuXSkqXCJ8YFteYF0qYC8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2FzZXxjaGFufGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZGVmZXJ8ZWxzZXxmYWxsdGhyb3VnaHxmb3J8ZnVuY3xnbyg/OnRvKT98aWZ8aW1wb3J0fGludGVyZmFjZXxtYXB8cGFja2FnZXxyYW5nZXxyZXR1cm58c2VsZWN0fHN0cnVjdHxzd2l0Y2h8dHlwZXx2YXIpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86X3xmYWxzZXxpb3RhfG5pbHx0cnVlKVxcYi8sXG4gICdudW1iZXInOiBbLy8gYmluYXJ5IGFuZCBvY3RhbCBpbnRlZ2Vyc1xuICAvXFxiMCg/OmJbMDFfXSt8b1swLTdfXSspaT9cXGIvaSwgLy8gaGV4YWRlY2ltYWwgaW50ZWdlcnMgYW5kIGZsb2F0c1xuICAvXFxiMHgoPzpbYS1mXFxkX10rKD86XFwuW2EtZlxcZF9dKik/fFxcLlthLWZcXGRfXSspKD86cFsrLV0/XFxkKyg/Ol9cXGQrKSopP2k/KD8hXFx3KS9pLCAvLyBkZWNpbWFsIGludGVnZXJzIGFuZCBmbG9hdHNcbiAgLyg/OlxcYlxcZFtcXGRfXSooPzpcXC5bXFxkX10qKT98XFxCXFwuXFxkW1xcZF9dKikoPzplWystXT9bXFxkX10rKT9pPyg/IVxcdykvaV0sXG4gICdvcGVyYXRvcic6IC9bKlxcLyVeIT1dPT98XFwrWz0rXT98LVs9LV0/fFxcfFs9fF0/fCYoPzo9fCZ8XFxePT8pP3w+KD86Pj0/fD0pP3w8KD86PD0/fD18LSk/fDo9fFxcLlxcLlxcLi8sXG4gICdidWlsdGluJzogL1xcYig/OmFwcGVuZHxib29sfGJ5dGV8Y2FwfGNsb3NlfGNvbXBsZXh8Y29tcGxleCg/OjY0fDEyOCl8Y29weXxkZWxldGV8ZXJyb3J8ZmxvYXQoPzozMnw2NCl8dT9pbnQoPzo4fDE2fDMyfDY0KT98aW1hZ3xsZW58bWFrZXxuZXd8cGFuaWN8cHJpbnQoPzpsbik/fHJlYWx8cmVjb3ZlcnxydW5lfHN0cmluZ3x1aW50cHRyKVxcYi9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnZ28nLCAnc3RyaW5nJywge1xuICAnY2hhcic6IHtcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFwufFteJ1xcXFxcXHJcXG5dKXswLDEwfScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XG59KTtcbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMuZ29bJ2NsYXNzLW5hbWUnXTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC10ZW1wbGF0aW5nXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBpZCBhbmQgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gJ19fXycgKyBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpICsgaW5kZXggKyAnX19fJztcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXSA9IHt9LCB7XG4gICAgYnVpbGRQbGFjZWhvbGRlcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9rZW5pemUgYWxsIGlubGluZSB0ZW1wbGF0aW5nIGV4cHJlc3Npb25zIG1hdGNoaW5nIGBwbGFjZWhvbGRlclBhdHRlcm5gLlxuICAgICAgICpcbiAgICAgICAqIElmIGByZXBsYWNlRmlsdGVyYCBpcyBwcm92aWRlZCwgb25seSBtYXRjaGVzIG9mIGBwbGFjZWhvbGRlclBhdHRlcm5gIGZvciB3aGljaCBgcmVwbGFjZUZpbHRlcmAgcmV0dXJuc1xuICAgICAgICogYHRydWVgIHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBiZWZvcmUtdG9rZW5pemVgIGhvb2suXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkLlxuICAgICAgICogQHBhcmFtIHtSZWdFeHB9IHBsYWNlaG9sZGVyUGF0dGVybiBUaGUgbWF0Y2hlcyBvZiB0aGlzIHBhdHRlcm4gd2lsbCBiZSByZXBsYWNlZCBieSBwbGFjZWhvbGRlcnMuXG4gICAgICAgKiBAcGFyYW0geyhtYXRjaDogc3RyaW5nKSA9PiBib29sZWFufSBbcmVwbGFjZUZpbHRlcl1cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbnYsIGxhbmd1YWdlLCBwbGFjZWhvbGRlclBhdHRlcm4sIHJlcGxhY2VGaWx0ZXIpIHtcbiAgICAgICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW5TdGFjayA9IGVudi50b2tlblN0YWNrID0gW107XG4gICAgICAgIGVudi5jb2RlID0gZW52LmNvZGUucmVwbGFjZShwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZUZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhcmVwbGFjZUZpbHRlcihtYXRjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaSA9IHRva2VuU3RhY2subGVuZ3RoO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcjsgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIHN0cmluZ3NcblxuICAgICAgICAgIHdoaWxlIChlbnYuY29kZS5pbmRleE9mKHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGkpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9IC8vIENyZWF0ZSBhIHNwYXJzZSBhcnJheVxuXG5cbiAgICAgICAgICB0b2tlblN0YWNrW2ldID0gbWF0Y2g7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgICB9KTsgLy8gU3dpdGNoIHRoZSBncmFtbWFyIHRvIG1hcmt1cFxuXG4gICAgICAgIGVudi5ncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRva2VuaXplUGxhY2Vob2xkZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgcGxhY2Vob2xkZXJzIHdpdGggcHJvcGVyIHRva2VucyBhZnRlciB0b2tlbml6aW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYWZ0ZXItdG9rZW5pemVgIGhvb2suXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIGxhbmd1YWdlIGlkLlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGVudiwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UgfHwgIWVudi50b2tlblN0YWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN3aXRjaCB0aGUgZ3JhbW1hciBiYWNrXG5cblxuICAgICAgICBlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnYudG9rZW5TdGFjayk7XG5cbiAgICAgICAgZnVuY3Rpb24gd2Fsa1Rva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gYWxsIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKGogPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgdG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICB2YXIgdCA9IGVudi50b2tlblN0YWNrW2tdO1xuICAgICAgICAgICAgICB2YXIgcyA9IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgPyB0b2tlbiA6IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBrKTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcy5pbmRleE9mKHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgICAgICB2YXIgYmVmb3JlID0gcy5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhciBtaWRkbGUgPSBuZXcgUHJpc20uVG9rZW4obGFuZ3VhZ2UsIFByaXNtLnRva2VuaXplKHQsIGVudi5ncmFtbWFyKSwgJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSwgdCk7XG4gICAgICAgICAgICAgICAgdmFyIGFmdGVyID0gcy5zdWJzdHJpbmcoaW5kZXggKyBwbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgd2Fsa1Rva2VucyhbYmVmb3JlXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2gobWlkZGxlKTtcblxuICAgICAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgd2Fsa1Rva2VucyhbYWZ0ZXJdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLCBbaSwgMV0uY29uY2F0KHJlcGxhY2VtZW50KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4uY29udGVudFxuICAgICAgICAgICAgLyogJiYgdHlwZW9mIHRva2VuLmNvbnRlbnQgIT09ICdzdHJpbmcnICovXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuXG4gICAgICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWhhbmRsZWJhcnNcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmhhbmRsZWJhcnMgPSB7XG4gICAgJ2NvbW1lbnQnOiAvXFx7XFx7IVtcXHNcXFNdKj9cXH1cXH0vLFxuICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvXlxce1xce1xcez98XFx9XFx9XFx9PyQvLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICdzdHJpbmcnOiAvKFtcIiddKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgICdudW1iZXInOiAvXFxiMHhbXFxkQS1GYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OltFZV1bKy1dP1xcZCspPy8sXG4gICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAgICdibG9jayc6IHtcbiAgICAgIHBhdHRlcm46IC9eKFxccyooPzp+XFxzKik/KVsjXFwvXVxcUys/KD89XFxzKig/On5cXHMqKT8kfFxccykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICB9LFxuICAgICdicmFja2V0cyc6IHtcbiAgICAgIHBhdHRlcm46IC9cXFtbXlxcXV0rXFxdLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL1xcW3xcXF0vLFxuICAgICAgICB2YXJpYWJsZTogL1tcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IC9bIVwiIyUmJzooKSorLC5cXC87PD0+QFxcW1xcXFxcXF1eYHt8fX5dLyxcbiAgICAndmFyaWFibGUnOiAvW14hXCIjJSYnKCkqKyxcXC87PD0+QFxcW1xcXFxcXF1eYHt8fX5cXHNdKy9cbiAgfTtcbiAgUHJpc20uaG9va3MuYWRkKCdiZWZvcmUtdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgdmFyIGhhbmRsZWJhcnNQYXR0ZXJuID0gL1xce1xce1xce1tcXHNcXFNdKz9cXH1cXH1cXH18XFx7XFx7W1xcc1xcU10rP1xcfVxcfS9nO1xuICAgIFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXS5idWlsZFBsYWNlaG9sZGVycyhlbnYsICdoYW5kbGViYXJzJywgaGFuZGxlYmFyc1BhdHRlcm4pO1xuICB9KTtcbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10udG9rZW5pemVQbGFjZWhvbGRlcnMoZW52LCAnaGFuZGxlYmFycycpO1xuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmhicyA9IFByaXNtLmxhbmd1YWdlcy5oYW5kbGViYXJzO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanNvblwiICovXG4vLyBodHRwczovL3d3dy5qc29uLm9yZy9qc29uLWVuLmh0bWxcblxuXG5wcmlzbS5sYW5ndWFnZXMuanNvbiA9IHtcbiAgJ3Byb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/PVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIoPyFcXHMqOikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXC9cXC8uKnxcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ251bWJlcic6IC8tP1xcYlxcZCsoPzpcXC5cXGQrKT8oPzplWystXT9cXGQrKT9cXGIvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF0sXS8sXG4gICdvcGVyYXRvcic6IC86LyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnbnVsbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9XG59O1xucHJpc20ubGFuZ3VhZ2VzLndlYm1hbmlmZXN0ID0gcHJpc20ubGFuZ3VhZ2VzLmpzb247XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1sZXNzXCIgKi9cblxuLyogRklYTUUgOlxuIDpleHRlbmQoKSBpcyBub3QgaGFuZGxlZCBzcGVjaWZpY2FsbHkgOiBpdHMgaGlnaGxpZ2h0aW5nIGlzIGJ1Z2d5LlxuIE1peGluIHVzYWdlIG11c3QgYmUgaW5zaWRlIGEgcnVsZXNldCB0byBiZSBoaWdobGlnaHRlZC5cbiBBdC1ydWxlcyAoZS5nLiBpbXBvcnQpIGNvbnRhaW5pbmcgaW50ZXJwb2xhdGlvbnMgYXJlIGJ1Z2d5LlxuIERldGFjaGVkIHJ1bGVzZXRzIGFyZSBoaWdobGlnaHRlZCBhcyBhdC1ydWxlcy5cbiBBIGNvbW1lbnQgYmVmb3JlIGEgbWl4aW4gdXNhZ2UgcHJldmVudHMgdGhlIGxhdHRlciB0byBiZSBwcm9wZXJseSBoaWdobGlnaHRlZC5cbiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubGVzcyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgJ2NvbW1lbnQnOiBbL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLCB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwvLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gICdhdHJ1bGUnOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0oPzpcXCgoPzpbXigpe31dfFxcKFteKCl7fV0qXFwpKSpcXCl8W14oKXt9O1xcc118XFxzKyg/IVxccykpKj8oPz1cXHMqXFx7KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvWzooKV0vXG4gICAgfVxuICB9LFxuICAvLyBzZWxlY3RvcnMgYW5kIG1peGlucyBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICAnc2VsZWN0b3InOiB7XG4gICAgcGF0dGVybjogLyg/OkBcXHtbXFx3LV0rXFx9fFtee307XFxzQF0pKD86QFxce1tcXHctXStcXH18XFwoKD86W14oKXt9XXxcXChbXigpe31dKlxcKSkqXFwpfFteKCl7fTtAXFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccypcXHspLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgIC8vIG1peGluIHBhcmFtZXRlcnNcbiAgICAgICd2YXJpYWJsZSc6IC9AK1tcXHctXSsvXG4gICAgfVxuICB9LFxuICAncHJvcGVydHknOiAvKD86QFxce1tcXHctXStcXH18W1xcdy1dKSsoPzpcXCtfPyk/KD89XFxzKjopLyxcbiAgJ29wZXJhdG9yJzogL1srXFwtKlxcL10vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2xlc3MnLCAncHJvcGVydHknLCB7XG4gICd2YXJpYWJsZSc6IFsvLyBWYXJpYWJsZSBkZWNsYXJhdGlvbiAodGhlIGNvbG9uIG11c3QgYmUgY29uc3VtZWQhKVxuICB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0rXFxzKjovLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogLzovXG4gICAgfVxuICB9LCAvLyBWYXJpYWJsZSB1c2FnZVxuICAvQEA/W1xcdy1dKy9dLFxuICAnbWl4aW4tdXNhZ2UnOiB7XG4gICAgcGF0dGVybjogLyhbeztdXFxzKilbLiNdKD8hXFxkKVtcXHctXS4qPyg/PVsoO10pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH1cbn0pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFrZWZpbGVcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMubWFrZWZpbGUgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSMoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxcXHJcXG5dKSovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnYnVpbHRpbi10YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL1xcLltBLVpdW146Iz1cXHNdKyg/PVxccyo6KD8hPSkpLyxcbiAgICBhbGlhczogJ2J1aWx0aW4nXG4gIH0sXG4gICd0YXJnZXQnOiB7XG4gICAgcGF0dGVybjogL14oPzpbXjo9XFxzXXxbIFxcdF0rKD8hW1xcczpdKSkrKD89XFxzKjooPyE9KSkvbSxcbiAgICBhbGlhczogJ3N5bWJvbCcsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3woPz1bKHtdKSkvXG4gICAgfVxuICB9LFxuICAndmFyaWFibGUnOiAvXFwkKyg/Oig/IVxcJClbXigpe306Iz1cXHNdK3xcXChbQColPF4rP11bREZdXFwpfCg/PVsoe10pKS8sXG4gIC8vIERpcmVjdGl2ZXNcbiAgJ2tleXdvcmQnOiAvLWluY2x1ZGVcXGJ8XFxiKD86ZGVmaW5lfGVsc2V8ZW5kZWZ8ZW5kaWZ8ZXhwb3J0fGlmbj9kZWZ8aWZuP2VxfGluY2x1ZGV8b3ZlcnJpZGV8cHJpdmF0ZXxzaW5jbHVkZXx1bmRlZmluZXx1bmV4cG9ydHx2cGF0aClcXGIvLFxuICAnZnVuY3Rpb24nOiB7XG4gICAgcGF0dGVybjogLyhcXCgpKD86YWJzcGF0aHxhZGRzdWZmaXh8YW5kfGJhc2VuYW1lfGNhbGx8ZGlyfGVycm9yfGV2YWx8ZmlsZXxmaWx0ZXIoPzotb3V0KT98ZmluZHN0cmluZ3xmaXJzdHdvcmR8Zmxhdm9yfGZvcmVhY2h8Z3VpbGV8aWZ8aW5mb3xqb2lufGxhc3R3b3JkfGxvYWR8bm90ZGlyfG9yfG9yaWdpbnxwYXRzdWJzdHxyZWFscGF0aHxzaGVsbHxzb3J0fHN0cmlwfHN1YnN0fHN1ZmZpeHx2YWx1ZXx3YXJuaW5nfHdpbGRjYXJkfHdvcmQoPzpsaXN0fHMpPykoPz1bIFxcdF0pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8oPzo6OnxbPzorIV0pPz18W3xAXS8sXG4gICdwdW5jdHVhdGlvbic6IC9bOjsoKXt9XS9cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLm9iamVjdGl2ZWMgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9AP1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmFzbXxhdXRvfGJyZWFrfGNhc2V8Y2hhcnxjb25zdHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGVudW18ZXh0ZXJufGZsb2F0fGZvcnxnb3RvfGlmfGlufGlubGluZXxpbnR8bG9uZ3xyZWdpc3RlcnxyZXR1cm58c2VsZnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdHJ1Y3R8c3VwZXJ8c3dpdGNofHR5cGVkZWZ8dHlwZW9mfHVuaW9ufHVuc2lnbmVkfHZvaWR8dm9sYXRpbGV8d2hpbGUpXFxifCg/OkBpbnRlcmZhY2V8QGVuZHxAaW1wbGVtZW50YXRpb258QHByb3RvY29sfEBjbGFzc3xAcHVibGljfEBwcm90ZWN0ZWR8QHByaXZhdGV8QHByb3BlcnR5fEB0cnl8QGNhdGNofEBmaW5hbGx5fEB0aHJvd3xAc3ludGhlc2l6ZXxAZHluYW1pY3xAc2VsZWN0b3IpXFxiLyxcbiAgJ29wZXJhdG9yJzogLy1bLT5dP3xcXCtcXCs/fCE9P3w8PD89P3w+Pj89P3w9PT98JiY/fFxcfFxcfD98W35eJT8qXFwvQF0vXG59KTtcbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlY1snY2xhc3MtbmFtZSddO1xucHJpc20ubGFuZ3VhZ2VzLm9iamMgPSBwcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYztcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW9jYW1sXCIgKi9cbi8vIGh0dHBzOi8vb2NhbWwub3JnL21hbnVhbC9sZXguaHRtbFxuXG5wcmlzbS5sYW5ndWFnZXMub2NhbWwgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXChcXCpbXFxzXFxTXSo/XFwqXFwpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NoYXInOiB7XG4gICAgcGF0dGVybjogLycoPzpbXlxcXFxcXHJcXG4nXXxcXFxcKD86Lnxbb3hdP1swLTlhLWZdezEsM30pKScvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IFt7XG4gICAgcGF0dGVybjogL1wiKD86XFxcXCg/OltcXHNcXFNdfFxcclxcbil8W15cXFxcXFxyXFxuXCJdKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFx7KFthLXpfXSopXFx8W1xcc1xcU10qP1xcfFxcMVxcfS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1dLFxuICAnbnVtYmVyJzogWy8vIGJpbmFyeSBhbmQgb2N0YWxcbiAgL1xcYig/OjBiWzAxXVswMV9dKnwwb1swLTddWzAtN19dKilcXGIvaSwgLy8gaGV4YWRlY2ltYWxcbiAgL1xcYjB4W2EtZjAtOV1bYS1mMC05X10qKD86XFwuW2EtZjAtOV9dKik/KD86cFsrLV0/XFxkW1xcZF9dKik/KD8hXFx3KS9pLCAvLyBkZWNpbWFsXG4gIC9cXGJcXGRbXFxkX10qKD86XFwuW1xcZF9dKik/KD86ZVsrLV0/XFxkW1xcZF9dKik/KD8hXFx3KS9pXSxcbiAgJ2RpcmVjdGl2ZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCI1xcdysvLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH0sXG4gICdsYWJlbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCflxcdysvLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH0sXG4gICd0eXBlLXZhcmlhYmxlJzoge1xuICAgIHBhdHRlcm46IC9cXEInXFx3Ky8sXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ3ZhcmlhbnQnOiB7XG4gICAgcGF0dGVybjogL2BcXHcrLyxcbiAgICBhbGlhczogJ3N5bWJvbCdcbiAgfSxcbiAgLy8gRm9yIHRoZSBsaXN0IG9mIGtleXdvcmRzIGFuZCBvcGVyYXRvcnMsXG4gIC8vIHNlZTogaHR0cDovL2NhbWwuaW5yaWEuZnIvcHViL2RvY3MvbWFudWFsLW9jYW1sL2xleC5odG1sI3NlYzg0XG4gICdrZXl3b3JkJzogL1xcYig/OmFzfGFzc2VydHxiZWdpbnxjbGFzc3xjb25zdHJhaW50fGRvfGRvbmV8ZG93bnRvfGVsc2V8ZW5kfGV4Y2VwdGlvbnxleHRlcm5hbHxmb3J8ZnVufGZ1bmN0aW9ufGZ1bmN0b3J8aWZ8aW58aW5jbHVkZXxpbmhlcml0fGluaXRpYWxpemVyfGxhenl8bGV0fG1hdGNofG1ldGhvZHxtb2R1bGV8bXV0YWJsZXxuZXd8bm9ucmVjfG9iamVjdHxvZnxvcGVufHByaXZhdGV8cmVjfHNpZ3xzdHJ1Y3R8dGhlbnx0b3x0cnl8dHlwZXx2YWx8dmFsdWV8dmlydHVhbHx3aGVufHdoZXJlfHdoaWxlfHdpdGgpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnb3BlcmF0b3ItbGlrZS1wdW5jdHVhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvXFxbWzw+fF18Wz58XVxcXXxcXHs8fD5cXH0vLFxuICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gIH0sXG4gIC8vIEN1c3RvbSBvcGVyYXRvcnMgYXJlIGFsbG93ZWRcbiAgJ29wZXJhdG9yJzogL1xcLlsufl18Ols9Pl18Wz08PkBefCYrXFwtKlxcLyQlIT9+XVshJCUmKitcXC0uXFwvOjw9Pj9AXnx+XSp8XFxiKD86YW5kfGFzcnxsYW5kfGxvcnxsc2x8bHNyfGx4b3J8bW9kfG9yKVxcYi8sXG4gICdwdW5jdHVhdGlvbic6IC87O3w6OnxbKCl7fVxcW1xcXS4sOjsjXXxcXGJfXFxiL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvblwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5weXRob24gPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSMuKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZy1pbnRlcnBvbGF0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oPzpmfGZyfHJmKSg/OihcIlwiXCJ8JycnKVtcXHNcXFNdKj9cXDF8KFwifCcpKD86XFxcXC58KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMikvaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgLy8gXCJ7XCIgPGV4cHJlc3Npb24+IDxvcHRpb25hbCBcIiFzXCIsIFwiIXJcIiwgb3IgXCIhYVwiPiA8b3B0aW9uYWwgXCI6XCIgZm9ybWF0IHNwZWNpZmllcj4gXCJ9XCJcbiAgICAgICAgcGF0dGVybjogLygoPzpefFtee10pKD86XFx7XFx7KSopXFx7KD8hXFx7KSg/Oltee31dfFxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV0pK1xcfSkrXFx9KStcXH0vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnZm9ybWF0LXNwZWMnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvKDopW146KCl7fV0rKD89XFx9JCkvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2NvbnZlcnNpb24tb3B0aW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyFbc3JhXSg/PVs6fV0kKS8sXG4gICAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzdDogbnVsbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgfVxuICB9LFxuICAndHJpcGxlLXF1b3RlZC1zdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyg/OltydWJdfGJyfHJiKT8oXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAnc3RyaW5nJ1xuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwifCcpKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnZnVuY3Rpb24nOiB7XG4gICAgcGF0dGVybjogLygoPzpefFxccylkZWZbIFxcdF0rKVthLXpBLVpfXVxcdyooPz1cXHMqXFwoKS9nLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGJjbGFzc1xccyspXFx3Ky9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2RlY29yYXRvcic6IHtcbiAgICBwYXR0ZXJuOiAvKF5bXFx0IF0qKUBcXHcrKD86XFwuXFx3KykqL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogWydhbm5vdGF0aW9uJywgJ3B1bmN0dWF0aW9uJ10sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgIH1cbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86Xyg/PVxccyo6KXxhbmR8YXN8YXNzZXJ0fGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29udGludWV8ZGVmfGRlbHxlbGlmfGVsc2V8ZXhjZXB0fGV4ZWN8ZmluYWxseXxmb3J8ZnJvbXxnbG9iYWx8aWZ8aW1wb3J0fGlufGlzfGxhbWJkYXxtYXRjaHxub25sb2NhbHxub3R8b3J8cGFzc3xwcmludHxyYWlzZXxyZXR1cm58dHJ5fHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgJ2J1aWx0aW4nOiAvXFxiKD86X19pbXBvcnRfX3xhYnN8YWxsfGFueXxhcHBseXxhc2NpaXxiYXNlc3RyaW5nfGJpbnxib29sfGJ1ZmZlcnxieXRlYXJyYXl8Ynl0ZXN8Y2FsbGFibGV8Y2hyfGNsYXNzbWV0aG9kfGNtcHxjb2VyY2V8Y29tcGlsZXxjb21wbGV4fGRlbGF0dHJ8ZGljdHxkaXJ8ZGl2bW9kfGVudW1lcmF0ZXxldmFsfGV4ZWNmaWxlfGZpbGV8ZmlsdGVyfGZsb2F0fGZvcm1hdHxmcm96ZW5zZXR8Z2V0YXR0cnxnbG9iYWxzfGhhc2F0dHJ8aGFzaHxoZWxwfGhleHxpZHxpbnB1dHxpbnR8aW50ZXJufGlzaW5zdGFuY2V8aXNzdWJjbGFzc3xpdGVyfGxlbnxsaXN0fGxvY2Fsc3xsb25nfG1hcHxtYXh8bWVtb3J5dmlld3xtaW58bmV4dHxvYmplY3R8b2N0fG9wZW58b3JkfHBvd3xwcm9wZXJ0eXxyYW5nZXxyYXdfaW5wdXR8cmVkdWNlfHJlbG9hZHxyZXByfHJldmVyc2VkfHJvdW5kfHNldHxzZXRhdHRyfHNsaWNlfHNvcnRlZHxzdGF0aWNtZXRob2R8c3RyfHN1bXxzdXBlcnx0dXBsZXx0eXBlfHVuaWNocnx1bmljb2RlfHZhcnN8eHJhbmdlfHppcClcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpGYWxzZXxOb25lfFRydWUpXFxiLyxcbiAgJ251bWJlcic6IC9cXGIwKD86Yig/Ol8/WzAxXSkrfG8oPzpfP1swLTddKSt8eCg/Ol8/W2EtZjAtOV0pKylcXGJ8KD86XFxiXFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFxCXFwuXFxkKyg/Ol9cXGQrKSopKD86ZVsrLV0/XFxkKyg/Ol9cXGQrKSopP2o/KD8hXFx3KS9pLFxuICAnb3BlcmF0b3InOiAvWy0rJT1dPT98IT18Oj18XFwqXFwqPz0/fFxcL1xcLz89P3w8Wzw9Pl0/fD5bPT5dP3xbJnxefl0vLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xucHJpc20ubGFuZ3VhZ2VzLnB5dGhvblsnc3RyaW5nLWludGVycG9sYXRpb24nXS5pbnNpZGVbJ2ludGVycG9sYXRpb24nXS5pbnNpZGUucmVzdCA9IHByaXNtLmxhbmd1YWdlcy5weXRob247XG5wcmlzbS5sYW5ndWFnZXMucHkgPSBwcmlzbS5sYW5ndWFnZXMucHl0aG9uO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcmVhc29uXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLnJlYXNvbiA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXFxcXFxcclxcblwiXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAvLyAnY2xhc3MtbmFtZScgbXVzdCBiZSBtYXRjaGVkICphZnRlciogJ2NvbnN0cnVjdG9yJyBkZWZpbmVkIGJlbG93XG4gICdjbGFzcy1uYW1lJzogL1xcYltBLVpdXFx3Ki8sXG4gICdrZXl3b3JkJzogL1xcYig/OmFuZHxhc3xhc3NlcnR8YmVnaW58Y2xhc3N8Y29uc3RyYWludHxkb3xkb25lfGRvd250b3xlbHNlfGVuZHxleGNlcHRpb258ZXh0ZXJuYWx8Zm9yfGZ1bnxmdW5jdGlvbnxmdW5jdG9yfGlmfGlufGluY2x1ZGV8aW5oZXJpdHxpbml0aWFsaXplcnxsYXp5fGxldHxtZXRob2R8bW9kdWxlfG11dGFibGV8bmV3fG5vbnJlY3xvYmplY3R8b2Z8b3Blbnxvcnxwcml2YXRlfHJlY3xzaWd8c3RydWN0fHN3aXRjaHx0aGVufHRvfHRyeXx0eXBlfHZhbHx2aXJ0dWFsfHdoZW58d2hpbGV8d2l0aClcXGIvLFxuICAnb3BlcmF0b3InOiAvXFwuezN9fDpbOj1dfFxcfD58LT58PSg/Oj09P3w+KT98PD0/fD49P3xbfF4/JyMhfmBdfFsrXFwtKlxcL11cXC4/fFxcYig/OmFzcnxsYW5kfGxvcnxsc2x8bHNyfGx4b3J8bW9kKVxcYi9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgncmVhc29uJywgJ2NsYXNzLW5hbWUnLCB7XG4gICdjaGFyJzoge1xuICAgIHBhdHRlcm46IC8nKD86XFxcXHhbXFxkYS1mXXsyfXxcXFxcb1swLTNdWzAtN11bMC03XXxcXFxcXFxkezN9fFxcXFwufFteJ1xcXFxcXHJcXG5dKScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAvLyBOZWdhdGl2ZSBsb29rLWFoZWFkIHByZXZlbnRzIGZyb20gbWF0Y2hpbmcgdGhpbmdzIGxpa2UgU3RyaW5nLmNhcGl0YWxpemVcbiAgJ2NvbnN0cnVjdG9yJzogL1xcYltBLVpdXFx3KlxcYig/IVxccypcXC4pLyxcbiAgJ2xhYmVsJzoge1xuICAgIHBhdHRlcm46IC9cXGJbYS16XVxcdyooPz06OikvLFxuICAgIGFsaWFzOiAnc3ltYm9sJ1xuICB9XG59KTsgLy8gV2UgY2FuJ3QgbWF0Y2ggZnVuY3Rpb25zIHByb3BlcnR5LCBzbyBsZXQncyBub3QgZXZlbiB0cnkuXG5cbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMucmVhc29uLmZ1bmN0aW9uO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc2Fzc1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLnNhc3MgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICAgLy8gU2FzcyBjb21tZW50cyBkb24ndCBuZWVkIHRvIGJlIGNsb3NlZCwgb25seSBpbmRlbnRlZFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogL14oWyBcXHRdKilcXC9bXFwvKl0uKig/Oig/Olxccj9cXG58XFxyKVxcMVsgXFx0XS4rKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ2F0cnVsZScsIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAnYXRydWxlLWxpbmUnOiB7XG4gICAgICAvLyBJbmNsdWRlcyBzdXBwb3J0IGZvciA9IGFuZCArIHNob3J0Y3V0c1xuICAgICAgcGF0dGVybjogL14oPzpbIFxcdF0qKVtAKz1dLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXRydWxlJzogLyg/OkBbXFx3LV0rfFsrPV0pL1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5hdHJ1bGU7XG4gIHZhciB2YXJpYWJsZSA9IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9LztcbiAgdmFyIG9wZXJhdG9yID0gWy9bKypcXC8lXXxbPSFdPXw8PT98Pj0/fFxcYig/OmFuZHxub3R8b3IpXFxiLywge1xuICAgIHBhdHRlcm46IC8oXFxzKS0oPz1cXHMpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3Byb3BlcnR5Jywge1xuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICd2YXJpYWJsZS1saW5lJzoge1xuICAgICAgcGF0dGVybjogL15bIFxcdF0qXFwkLisvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvOi8sXG4gICAgICAgICd2YXJpYWJsZSc6IHZhcmlhYmxlLFxuICAgICAgICAnb3BlcmF0b3InOiBvcGVyYXRvclxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ3Byb3BlcnR5LWxpbmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXlsgXFx0XSooPzpbXjpcXHNdKyAqOi4qfDpbXjpcXHNdLiopL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3Byb3BlcnR5JzogWy9bXjpcXHNdKyg/PVxccyo6KS8sIHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKDopW146XFxzXSsvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86LyxcbiAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGUsXG4gICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yLFxuICAgICAgICAnaW1wb3J0YW50JzogUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLnByb3BlcnR5O1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MuaW1wb3J0YW50OyAvLyBOb3cgdGhhdCB3aG9sZSBsaW5lcyBmb3Igb3RoZXIgcGF0dGVybnMgYXJlIGNvbnN1bWVkLFxuICAvLyB3aGF0J3MgbGVmdCBzaG91bGQgYmUgc2VsZWN0b3JzXG5cbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdwdW5jdHVhdGlvbicsIHtcbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvXihbIFxcdF0qKVxcUyg/OixbXixcXHJcXG5dK3xbXixcXHJcXG5dKikoPzosW14sXFxyXFxuXSspKig/OiwoPzpcXHI/XFxufFxccilcXDFbIFxcdF0rXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKSovbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc2Nzc1wiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLnNjc3MgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdhdHJ1bGUnOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0oPzpcXChbXigpXStcXCl8W14oKVxcc118XFxzKyg/IVxccykpKj8oPz1cXHMrW3s7XSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3J1bGUnOiAvQFtcXHctXSsvIC8vIFNlZSByZXN0IGJlbG93XG5cbiAgICB9XG4gIH0sXG4gIC8vIHVybCwgY29tcGFzc2lmaWVkXG4gICd1cmwnOiAvKD86Wy1hLXpdKy0pP3VybCg/PVxcKCkvaSxcbiAgLy8gQ1NTIHNlbGVjdG9yIHJlZ2V4IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgU2Fzc1xuICAvLyBzaW5jZSB0aGVyZSBjYW4gYmUgbG90IG1vcmUgdGhpbmdzICh2YXIsIEAgZGlyZWN0aXZlLCBuZXN0aW5nLi4pXG4gIC8vIGEgc2VsZWN0b3IgbXVzdCBzdGFydCBhdCB0aGUgZW5kIG9mIGEgcHJvcGVydHkgb3IgYWZ0ZXIgYSBicmFjZSAoZW5kIG9mIG90aGVyIHJ1bGVzIG9yIG5lc3RpbmcpXG4gIC8vIGl0IGNhbiBjb250YWluIHNvbWUgY2hhcmFjdGVycyB0aGF0IGFyZW4ndCB1c2VkIGZvciBkZWZpbmluZyBydWxlcyBvciBlbmQgb2Ygc2VsZWN0b3IsICYgKHBhcmVudCBzZWxlY3RvciksIG9yIGludGVycG9sYXRlZCB2YXJpYWJsZVxuICAvLyB0aGUgZW5kIG9mIGEgc2VsZWN0b3IgaXMgZm91bmQgd2hlbiB0aGVyZSBpcyBubyBydWxlcyBpbiBpdCAoIHt9IG9yIHtcXHN9KSBvciBpZiB0aGVyZSBpcyBhIHByb3BlcnR5IChiZWNhdXNlIGFuIGludGVycG9sYXRlZCB2YXJcbiAgLy8gY2FuIFwicGFzc1wiIGFzIGEgc2VsZWN0b3ItIGUuZzogcHJvcGVyI3skZXJ0eX0pXG4gIC8vIHRoaXMgb25lIHdhcyBoYXJkIHRvIGRvLCBzbyBwbGVhc2UgYmUgY2FyZWZ1bCBpZiB5b3UgZWRpdCB0aGlzIG9uZSA6KVxuICAnc2VsZWN0b3InOiB7XG4gICAgLy8gSW5pdGlhbCBsb29rLWFoZWFkIGlzIHVzZWQgdG8gcHJldmVudCBtYXRjaGluZyBvZiBibGFuayBzZWxlY3RvcnNcbiAgICBwYXR0ZXJuOiAvKD89XFxTKVteQDt7fSgpXT8oPzpbXkA7e30oKVxcc118XFxzKyg/IVxccyl8I1xce1xcJFstXFx3XStcXH0pKyg/PVxccypcXHsoPzpcXH18XFxzfFtefV1bXjp7fV0qWzp7XVtefV0pKS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncGFyZW50Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvJi8sXG4gICAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgICAgfSxcbiAgICAgICdwbGFjZWhvbGRlcic6IC8lWy1cXHddKy8sXG4gICAgICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbiAgICB9XG4gIH0sXG4gICdwcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKD86Wy1cXHddfFxcJFstXFx3XXwjXFx7XFwkWy1cXHddK1xcfSkrKD89XFxzKjopLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd2YXJpYWJsZSc6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9L1xuICAgIH1cbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2F0cnVsZScsIHtcbiAgJ2tleXdvcmQnOiBbL0AoPzpjb250ZW50fGRlYnVnfGVhY2h8ZWxzZSg/OiBpZik/fGV4dGVuZHxmb3J8Zm9yd2FyZHxmdW5jdGlvbnxpZnxpbXBvcnR8aW5jbHVkZXxtaXhpbnxyZXR1cm58dXNlfHdhcm58d2hpbGUpXFxiL2ksIHtcbiAgICBwYXR0ZXJuOiAvKCApKD86ZnJvbXx0aHJvdWdoKSg/PSApLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Njc3MnLCAnaW1wb3J0YW50Jywge1xuICAvLyB2YXIgYW5kIGludGVycG9sYXRlZCB2YXJzXG4gICd2YXJpYWJsZSc6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9L1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2Z1bmN0aW9uJywge1xuICAnbW9kdWxlLW1vZGlmaWVyJzoge1xuICAgIHBhdHRlcm46IC9cXGIoPzphc3xoaWRlfHNob3d8d2l0aClcXGIvaSxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdwbGFjZWhvbGRlcic6IHtcbiAgICBwYXR0ZXJuOiAvJVstXFx3XSsvLFxuICAgIGFsaWFzOiAnc2VsZWN0b3InXG4gIH0sXG4gICdzdGF0ZW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcQiEoPzpkZWZhdWx0fG9wdGlvbmFsKVxcYi9pLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnbnVsbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAnb3BlcmF0b3InOiB7XG4gICAgcGF0dGVybjogLyhcXHMpKD86Wy0rKlxcLyVdfFs9IV09fDw9P3w+PT98YW5kfG5vdHxvcikoPz1cXHMpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLnNjc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gcHJpc20ubGFuZ3VhZ2VzLnNjc3M7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zdHlsdXNcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB1bml0ID0ge1xuICAgIHBhdHRlcm46IC8oXFxiXFxkKykoPzolfFthLXpdKykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfTsgLy8gMTIzIC0xMjMgLjEyMyAtLjEyMyAxMi4zIC0xMi4zXG5cbiAgdmFyIG51bWJlciA9IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXHcuLV0pLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07XG4gIHZhciBpbnNpZGUgPSB7XG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkoPzpcXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAndXJsJzoge1xuICAgICAgcGF0dGVybjogL1xcYnVybFxcKChbXCInXT8pLio/XFwxXFwpL2ksXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFwifCcpKD86KD8hXFwxKVteXFxcXFxcclxcbl18XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKlxcMS8sXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdpbnRlcnBvbGF0aW9uJzogbnVsbCxcbiAgICAvLyBTZWUgYmVsb3dcbiAgICAnZnVuYyc6IG51bGwsXG4gICAgLy8gU2VlIGJlbG93XG4gICAgJ2ltcG9ydGFudCc6IC9cXEIhKD86aW1wb3J0YW50fG9wdGlvbmFsKVxcYi9pLFxuICAgICdrZXl3b3JkJzoge1xuICAgICAgcGF0dGVybjogLyhefFxccyspKD86KD86ZWxzZXxmb3J8aWZ8cmV0dXJufHVubGVzcykoPz1cXHN8JCl8QFtcXHctXSspLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdoZXhjb2RlJzogLyNbXFxkYS1mXXszLDZ9L2ksXG4gICAgJ2NvbG9yJzogWy9cXGIoPzpBbGljZUJsdWV8QW50aXF1ZVdoaXRlfEFxdWF8QXF1YW1hcmluZXxBenVyZXxCZWlnZXxCaXNxdWV8QmxhY2t8QmxhbmNoZWRBbG1vbmR8Qmx1ZXxCbHVlVmlvbGV0fEJyb3dufEJ1cmx5V29vZHxDYWRldEJsdWV8Q2hhcnRyZXVzZXxDaG9jb2xhdGV8Q29yYWx8Q29ybmZsb3dlckJsdWV8Q29ybnNpbGt8Q3JpbXNvbnxDeWFufERhcmtCbHVlfERhcmtDeWFufERhcmtHb2xkZW5Sb2R8RGFya0dyW2FlXXl8RGFya0dyZWVufERhcmtLaGFraXxEYXJrTWFnZW50YXxEYXJrT2xpdmVHcmVlbnxEYXJrT3JhbmdlfERhcmtPcmNoaWR8RGFya1JlZHxEYXJrU2FsbW9ufERhcmtTZWFHcmVlbnxEYXJrU2xhdGVCbHVlfERhcmtTbGF0ZUdyW2FlXXl8RGFya1R1cnF1b2lzZXxEYXJrVmlvbGV0fERlZXBQaW5rfERlZXBTa3lCbHVlfERpbUdyW2FlXXl8RG9kZ2VyQmx1ZXxGaXJlQnJpY2t8RmxvcmFsV2hpdGV8Rm9yZXN0R3JlZW58RnVjaHNpYXxHYWluc2Jvcm98R2hvc3RXaGl0ZXxHb2xkfEdvbGRlblJvZHxHclthZV15fEdyZWVufEdyZWVuWWVsbG93fEhvbmV5RGV3fEhvdFBpbmt8SW5kaWFuUmVkfEluZGlnb3xJdm9yeXxLaGFraXxMYXZlbmRlcnxMYXZlbmRlckJsdXNofExhd25HcmVlbnxMZW1vbkNoaWZmb258TGlnaHRCbHVlfExpZ2h0Q29yYWx8TGlnaHRDeWFufExpZ2h0R29sZGVuUm9kWWVsbG93fExpZ2h0R3JbYWVdeXxMaWdodEdyZWVufExpZ2h0UGlua3xMaWdodFNhbG1vbnxMaWdodFNlYUdyZWVufExpZ2h0U2t5Qmx1ZXxMaWdodFNsYXRlR3JbYWVdeXxMaWdodFN0ZWVsQmx1ZXxMaWdodFllbGxvd3xMaW1lfExpbWVHcmVlbnxMaW5lbnxNYWdlbnRhfE1hcm9vbnxNZWRpdW1BcXVhTWFyaW5lfE1lZGl1bUJsdWV8TWVkaXVtT3JjaGlkfE1lZGl1bVB1cnBsZXxNZWRpdW1TZWFHcmVlbnxNZWRpdW1TbGF0ZUJsdWV8TWVkaXVtU3ByaW5nR3JlZW58TWVkaXVtVHVycXVvaXNlfE1lZGl1bVZpb2xldFJlZHxNaWRuaWdodEJsdWV8TWludENyZWFtfE1pc3R5Um9zZXxNb2NjYXNpbnxOYXZham9XaGl0ZXxOYXZ5fE9sZExhY2V8T2xpdmV8T2xpdmVEcmFifE9yYW5nZXxPcmFuZ2VSZWR8T3JjaGlkfFBhbGVHb2xkZW5Sb2R8UGFsZUdyZWVufFBhbGVUdXJxdW9pc2V8UGFsZVZpb2xldFJlZHxQYXBheWFXaGlwfFBlYWNoUHVmZnxQZXJ1fFBpbmt8UGx1bXxQb3dkZXJCbHVlfFB1cnBsZXxSZWR8Um9zeUJyb3dufFJveWFsQmx1ZXxTYWRkbGVCcm93bnxTYWxtb258U2FuZHlCcm93bnxTZWFHcmVlbnxTZWFTaGVsbHxTaWVubmF8U2lsdmVyfFNreUJsdWV8U2xhdGVCbHVlfFNsYXRlR3JbYWVdeXxTbm93fFNwcmluZ0dyZWVufFN0ZWVsQmx1ZXxUYW58VGVhbHxUaGlzdGxlfFRvbWF0b3xUcmFuc3BhcmVudHxUdXJxdW9pc2V8VmlvbGV0fFdoZWF0fFdoaXRlfFdoaXRlU21va2V8WWVsbG93fFllbGxvd0dyZWVuKVxcYi9pLCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD86aHNsfHJnYilcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccypcXClcXEJ8XFxiKD86aHNsfHJnYilhXFwoXFxzKlxcZHsxLDN9XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccyooPzowfDA/XFwuXFxkK3wxKVxccypcXClcXEIvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndW5pdCc6IHVuaXQsXG4gICAgICAgICdudW1iZXInOiBudW1iZXIsXG4gICAgICAgICdmdW5jdGlvbic6IC9bXFx3LV0rKD89XFwoKS8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bKCksXS9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnZW50aXR5JzogL1xcXFxbXFxkYS1mXXsxLDh9L2ksXG4gICAgJ3VuaXQnOiB1bml0LFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgICAnb3BlcmF0b3InOiBbLy8gV2Ugd2FudCBub24td29yZCBjaGFycyBhcm91bmQgXCItXCIgYmVjYXVzZSBpdCBpc1xuICAgIC8vIGFjY2VwdGVkIGluIHByb3BlcnR5IG5hbWVzLlxuICAgIC9+fFsrIVxcLyU8Pj89XT0/fFstOl09fFxcKlsqPV0/fFxcLnsyLDN9fCYmfFxcfFxcfHxcXEItXFxCfFxcYig/OmFuZHxpbnxpcyg/OiBhfCBkZWZpbmVkfCBub3R8bnQpP3xub3R8b3IpXFxiL10sXG4gICAgJ251bWJlcic6IG51bWJlcixcbiAgICAncHVuY3R1YXRpb24nOiAvW3t9KClcXFtcXF07OixdL1xuICB9O1xuICBpbnNpZGVbJ2ludGVycG9sYXRpb24nXSA9IHtcbiAgICBwYXR0ZXJuOiAvXFx7W15cXHJcXG59Ol0rXFx9LyxcbiAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdkZWxpbWl0ZXInOiB7XG4gICAgICAgIHBhdHRlcm46IC9eXFx7fFxcfSQvLFxuICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgfSxcbiAgICAgIHJlc3Q6IGluc2lkZVxuICAgIH1cbiAgfTtcbiAgaW5zaWRlWydmdW5jJ10gPSB7XG4gICAgcGF0dGVybjogL1tcXHctXStcXChbXildKlxcKS4qLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdmdW5jdGlvbic6IC9eW14oXSsvLFxuICAgICAgcmVzdDogaW5zaWRlXG4gICAgfVxuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuc3R5bHVzID0ge1xuICAgICdhdHJ1bGUtZGVjbGFyYXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKUAuKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXRydWxlJzogL15AW1xcdy1dKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3ZhcmlhYmxlLWRlY2xhcmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKilbXFx3JC1dK1xccyouPz1bIFxcdF0qKD86XFx7W157fV0qXFx9fFxcUy4qfCQpL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd2YXJpYWJsZSc6IC9eXFxTKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3N0YXRlbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopKD86ZWxzZXxmb3J8aWZ8cmV0dXJufHVubGVzcylbIFxcdF0uKy9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAna2V5d29yZCc6IC9eXFxTKy8sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQSBwcm9wZXJ0eS92YWx1ZSBwYWlyIGNhbm5vdCBlbmQgd2l0aCBhIGNvbW1hIG9yIGEgYnJhY2VcbiAgICAvLyBJdCBjYW5ub3QgaGF2ZSBpbmRlbnRlZCBjb250ZW50IHVubGVzcyBpdCBlbmRlZCB3aXRoIGEgc2VtaWNvbG9uXG4gICAgJ3Byb3BlcnR5LWRlY2xhcmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLygoPzpefFxceykoWyBcXHRdKikpKD86W1xcdy1dfFxce1tefVxcclxcbl0rXFx9KSsoPzpcXHMqOlxccyp8WyBcXHRdKykoPyFcXHMpW157XFxyXFxuXSooPzo7fFtee1xcclxcbixdJCg/ISg/Olxccj9cXG58XFxyKSg/Olxce3xcXDJbIFxcdF0pKSkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eW15cXHM6XSsvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnNpZGUuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogaW5zaWRlXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBIHNlbGVjdG9yIGNhbiBjb250YWluIHBhcmVudGhlc2VzIG9ubHkgYXMgcGFydCBvZiBhIHBzZXVkby1lbGVtZW50XG4gICAgLy8gSXQgY2FuIHNwYW4gbXVsdGlwbGUgbGluZXMuXG4gICAgLy8gSXQgbXVzdCBlbmQgd2l0aCBhIGNvbW1hIG9yIGFuIGFjY29sYWRlIG9yIGhhdmUgaW5kZW50ZWQgY29udGVudC5cbiAgICAnc2VsZWN0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSg/Oig/PVxcUykoPzpbXnt9XFxyXFxuOigpXXw6Oj9bXFx3LV0rKD86XFwoW14pXFxyXFxuXSpcXCl8KD8hW1xcdy1dKSl8XFx7W159XFxyXFxuXStcXH0pKykoPzooPzpcXHI/XFxufFxccikoPzpcXDEoPzooPz1cXFMpKD86W157fVxcclxcbjooKV18Ojo/W1xcdy1dKyg/OlxcKFteKVxcclxcbl0qXFwpfCg/IVtcXHctXSkpfFxce1tefVxcclxcbl0rXFx9KSspKSkqKD86LCR8XFx7fCg/PSg/Olxccj9cXG58XFxyKSg/Olxce3xcXDFbIFxcdF0pKSkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnNpZGUuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgJ2NvbW1lbnQnOiBpbnNpZGUuY29tbWVudCxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1t7fSxdL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2Z1bmMnOiBpbnNpZGUuZnVuYyxcbiAgICAnc3RyaW5nJzogaW5zaWRlLnN0cmluZyxcbiAgICAnY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdpbnRlcnBvbGF0aW9uJzogaW5zaWRlLmludGVycG9sYXRpb24sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1t7fSgpXFxbXFxdOzouXS9cbiAgfTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXRzeFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgdHlwZXNjcmlwdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQpO1xuICBQcmlzbS5sYW5ndWFnZXMudHN4ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnanN4JywgdHlwZXNjcmlwdCk7IC8vIGRvZXNuJ3Qgd29yayB3aXRoIFRTIGJlY2F1c2UgVFMgaXMgdG9vIGNvbXBsZXhcblxuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnRzeFsncGFyYW1ldGVyJ107XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydsaXRlcmFsLXByb3BlcnR5J107IC8vIFRoaXMgd2lsbCBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiBUU1ggdGFncyBhbmQgVFMgZ2VuZXJpYyB0eXBlcy5cbiAgLy8gSWRlYSBieSBodHRwczovL2dpdGh1Yi5jb20va2FybGhvcmt5XG4gIC8vIERpc2N1c3Npb246IGh0dHBzOi8vZ2l0aHViLmNvbS9QcmlzbUpTL3ByaXNtL2lzc3Vlcy8yNTk0I2lzc3VlY29tbWVudC03MTA2NjY5MjhcblxuICB2YXIgdGFnID0gUHJpc20ubGFuZ3VhZ2VzLnRzeC50YWc7XG4gIHRhZy5wYXR0ZXJuID0gUmVnRXhwKC8oXnxbXlxcdyRdfCg/PTxcXC8pKS8uc291cmNlICsgJyg/OicgKyB0YWcucGF0dGVybi5zb3VyY2UgKyAnKScsIHRhZy5wYXR0ZXJuLmZsYWdzKTtcbiAgdGFnLmxvb2tiZWhpbmQgPSB0cnVlO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20td2FzbVwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLndhc20gPSB7XG4gICdjb21tZW50JzogWy9cXCg7W1xcc1xcU10qPztcXCkvLCB7XG4gICAgcGF0dGVybjogLzs7LiovLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcW1xcc1xcU118W15cIlxcXFxdKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogW3tcbiAgICBwYXR0ZXJuOiAvXFxiKD86YWxpZ258b2Zmc2V0KT0vLFxuICAgIGluc2lkZToge1xuICAgICAgJ29wZXJhdG9yJzogLz0vXG4gICAgfVxuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYig/Oig/OmYzMnxmNjR8aTMyfGk2NCkoPzpcXC4oPzphYnN8YWRkfGFuZHxjZWlsfGNsenxjb25zdHxjb252ZXJ0X1tzdV1cXC9pKD86MzJ8NjQpfGNvcHlzaWdufGN0enxkZW1vdGVcXC9mNjR8ZGl2KD86X1tzdV0pP3xlcXo/fGV4dGVuZF9bc3VdXFwvaTMyfGZsb29yfGdlKD86X1tzdV0pP3xndCg/Ol9bc3VdKT98bGUoPzpfW3N1XSk/fGxvYWQoPzooPzo4fDE2fDMyKV9bc3VdKT98bHQoPzpfW3N1XSk/fG1heHxtaW58bXVsfG5lZz98bmVhcmVzdHxvcnxwb3BjbnR8cHJvbW90ZVxcL2YzMnxyZWludGVycHJldFxcL1tmaV0oPzozMnw2NCl8cmVtX1tzdV18cm90W2xyXXxzaGx8c2hyX1tzdV18c3FydHxzdG9yZSg/Ojh8MTZ8MzIpP3xzdWJ8dHJ1bmMoPzpfW3N1XVxcL2YoPzozMnw2NCkpP3x3cmFwXFwvaTY0fHhvcikpP3xtZW1vcnlcXC4oPzpncm93fHNpemUpKVxcYi8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwuL1xuICAgIH1cbiAgfSwgL1xcYig/OmFueWZ1bmN8YmxvY2t8YnIoPzpfaWZ8X3RhYmxlKT98Y2FsbCg/Ol9pbmRpcmVjdCk/fGRhdGF8ZHJvcHxlbGVtfGVsc2V8ZW5kfGV4cG9ydHxmdW5jfGdldF8oPzpnbG9iYWx8bG9jYWwpfGdsb2JhbHxpZnxpbXBvcnR8bG9jYWx8bG9vcHxtZW1vcnl8bW9kdWxlfG11dHxub3B8b2Zmc2V0fHBhcmFtfHJlc3VsdHxyZXR1cm58c2VsZWN0fHNldF8oPzpnbG9iYWx8bG9jYWwpfHN0YXJ0fHRhYmxlfHRlZV9sb2NhbHx0aGVufHR5cGV8dW5yZWFjaGFibGUpXFxiL10sXG4gICd2YXJpYWJsZSc6IC9cXCRbXFx3ISMkJSYnKitcXC0uLzo8PT4/QFxcXFxeYHx+XSsvLFxuICAnbnVtYmVyJzogL1srLV0/XFxiKD86XFxkKD86Xz9cXGQpKig/OlxcLlxcZCg/Ol8/XFxkKSopPyg/OltlRV1bKy1dP1xcZCg/Ol8/XFxkKSopP3wweFtcXGRhLWZBLUZdKD86Xz9bXFxkYS1mQS1GXSkqKD86XFwuW1xcZGEtZkEtRl0oPzpfP1tcXGRhLWZBLURdKSopPyg/OltwUF1bKy1dP1xcZCg/Ol8/XFxkKSopPylcXGJ8XFxiaW5mXFxifFxcYm5hbig/OjoweFtcXGRhLWZBLUZdKD86Xz9bXFxkYS1mQS1EXSkqKT9cXGIvLFxuICAncHVuY3R1YXRpb24nOiAvWygpXS9cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByaXNtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/prism-react-renderer/prism/index.js\n"));

/***/ }),

/***/ "../../node_modules/prism-react-renderer/themes/duotoneDark/index.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/prism-react-renderer/themes/duotoneDark/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Duotone Dark\n// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)\n// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)\n// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)\nvar theme = {\n  plain: {\n    backgroundColor: \"#2a2734\",\n    color: \"#9a86fd\"\n  },\n  styles: [{\n    types: [\"comment\", \"prolog\", \"doctype\", \"cdata\", \"punctuation\"],\n    style: {\n      color: \"#6c6783\"\n    }\n  }, {\n    types: [\"namespace\"],\n    style: {\n      opacity: 0.7\n    }\n  }, {\n    types: [\"tag\", \"operator\", \"number\"],\n    style: {\n      color: \"#e09142\"\n    }\n  }, {\n    types: [\"property\", \"function\"],\n    style: {\n      color: \"#9a86fd\"\n    }\n  }, {\n    types: [\"tag-id\", \"selector\", \"atrule-id\"],\n    style: {\n      color: \"#eeebff\"\n    }\n  }, {\n    types: [\"attr-name\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }, {\n    types: [\"boolean\", \"string\", \"entity\", \"url\", \"attr-value\", \"keyword\", \"control\", \"directive\", \"unit\", \"statement\", \"regex\", \"atrule\", \"placeholder\", \"variable\"],\n    style: {\n      color: \"#ffcc99\"\n    }\n  }, {\n    types: [\"deleted\"],\n    style: {\n      textDecorationLine: \"line-through\"\n    }\n  }, {\n    types: [\"inserted\"],\n    style: {\n      textDecorationLine: \"underline\"\n    }\n  }, {\n    types: [\"italic\"],\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, {\n    types: [\"important\", \"bold\"],\n    style: {\n      fontWeight: \"bold\"\n    }\n  }, {\n    types: [\"important\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }]\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (theme);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL3RoZW1lcy9kdW90b25lRGFyay9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLCtEQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL3RoZW1lcy9kdW90b25lRGFyay9pbmRleC5qcz84YjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIER1b3RvbmUgRGFya1xuLy8gQXV0aG9yOiBTaW11cmFpLCBhZGFwdGVkIGZyb20gRHVvVG9uZSB0aGVtZXMgZm9yIEF0b20gKGh0dHA6Ly9zaW11cmFpLmNvbS9wcm9qZWN0cy8yMDE2LzAxLzAxL2R1b3RvbmUtdGhlbWVzKVxuLy8gQ29udmVyc2lvbjogQnJhbSBkZSBIYWFuIChodHRwOi8vYXRlbGllcmJyYW0uZ2l0aHViLmlvL0Jhc2UyVG9uZS1wcmlzbS9vdXRwdXQvcHJpc20vcHJpc20tYmFzZTJ0b25lLWV2ZW5pbmctZGFyay5jc3MpXG4vLyBHZW5lcmF0ZWQgd2l0aCBCYXNlMTYgQnVpbGRlciAoaHR0cHM6Ly9naXRodWIuY29tL2Jhc2UxNi1idWlsZGVyL2Jhc2UxNi1idWlsZGVyKVxudmFyIHRoZW1lID0ge1xuICBwbGFpbjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMmEyNzM0XCIsXG4gICAgY29sb3I6IFwiIzlhODZmZFwiXG4gIH0sXG4gIHN0eWxlczogW3tcbiAgICB0eXBlczogW1wiY29tbWVudFwiLCBcInByb2xvZ1wiLCBcImRvY3R5cGVcIiwgXCJjZGF0YVwiLCBcInB1bmN0dWF0aW9uXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjNmM2NzgzXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wibmFtZXNwYWNlXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1widGFnXCIsIFwib3BlcmF0b3JcIiwgXCJudW1iZXJcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNlMDkxNDJcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJwcm9wZXJ0eVwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjOWE4NmZkXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1widGFnLWlkXCIsIFwic2VsZWN0b3JcIiwgXCJhdHJ1bGUtaWRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNlZWViZmZcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJhdHRyLW5hbWVcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNjNGI5ZmVcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwiZW50aXR5XCIsIFwidXJsXCIsIFwiYXR0ci12YWx1ZVwiLCBcImtleXdvcmRcIiwgXCJjb250cm9sXCIsIFwiZGlyZWN0aXZlXCIsIFwidW5pdFwiLCBcInN0YXRlbWVudFwiLCBcInJlZ2V4XCIsIFwiYXRydWxlXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJ2YXJpYWJsZVwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2ZmY2M5OVwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImRlbGV0ZWRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uTGluZTogXCJsaW5lLXRocm91Z2hcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJpbnNlcnRlZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgdGV4dERlY29yYXRpb25MaW5lOiBcInVuZGVybGluZVwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcIml0YWxpY1wiXSxcbiAgICBzdHlsZToge1xuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImltcG9ydGFudFwiLCBcImJvbGRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImltcG9ydGFudFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2M0YjlmZVwiXG4gICAgfVxuICB9XVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGhlbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/prism-react-renderer/themes/duotoneDark/index.js\n"));

/***/ }),

/***/ "../../node_modules/@markdoc/markdoc/dist/index.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@markdoc/markdoc/dist/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ast\": function() { return /* binding */ ast_default; },\n/* harmony export */   \"Tag\": function() { return /* binding */ Tag; },\n/* harmony export */   \"Tokenizer\": function() { return /* binding */ Tokenizer; },\n/* harmony export */   \"__EXPERIMENTAL__format\": function() { return /* binding */ format; },\n/* harmony export */   \"createElement\": function() { return /* binding */ createElement; },\n/* harmony export */   \"default\": function() { return /* binding */ Markdoc; },\n/* harmony export */   \"functions\": function() { return /* binding */ functions_default; },\n/* harmony export */   \"globalAttributes\": function() { return /* binding */ globalAttributes; },\n/* harmony export */   \"nodes\": function() { return /* binding */ schema_exports; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse3; },\n/* harmony export */   \"parseTags\": function() { return /* binding */ parseTags; },\n/* harmony export */   \"renderers\": function() { return /* binding */ renderers_default; },\n/* harmony export */   \"resolve\": function() { return /* binding */ resolve2; },\n/* harmony export */   \"tags\": function() { return /* binding */ tags_default; },\n/* harmony export */   \"transform\": function() { return /* binding */ transform2; },\n/* harmony export */   \"transformer\": function() { return /* binding */ transformer_default; },\n/* harmony export */   \"transforms\": function() { return /* binding */ transforms_default; },\n/* harmony export */   \"truthy\": function() { return /* binding */ truthy; },\n/* harmony export */   \"validate\": function() { return /* binding */ validate2; },\n/* harmony export */   \"validator\": function() { return /* binding */ validate; }\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module, desc) => {\n  if (module && typeof module === \"object\" || typeof module === \"function\") {\n    for (let key of __getOwnPropNames(module))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module) => {\n  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, \"default\", module && module.__esModule && \"default\" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);\n};\n\n// src/grammar/tag.js\nvar require_tag = __commonJS({\n  \"src/grammar/tag.js\"(exports, module) {\n    \"use strict\";\n    function peg$subclass(child, parent) {\n      function C() {\n        this.constructor = child;\n      }\n      C.prototype = parent.prototype;\n      child.prototype = new C();\n    }\n    function peg$SyntaxError(message, expected, found, location) {\n      this.message = message;\n      this.expected = expected;\n      this.found = found;\n      this.location = location;\n      this.name = \"SyntaxError\";\n      if (typeof Error.captureStackTrace === \"function\") {\n        Error.captureStackTrace(this, peg$SyntaxError);\n      }\n    }\n    peg$subclass(peg$SyntaxError, Error);\n    peg$SyntaxError.buildMessage = function(expected, found, location) {\n      var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return '\"' + literalEscape(expectation.text) + '\"';\n        },\n        class: function(expectation) {\n          var escapedParts = expectation.parts.map(function(part) {\n            return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n          });\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n        any: function() {\n          return \"any character\";\n        },\n        end: function() {\n          return \"end of input\";\n        },\n        other: function(expectation) {\n          return expectation.description;\n        },\n        not: function(expectation) {\n          return \"not \" + describeExpectation(expectation.expected);\n        }\n      };\n      function hex(ch) {\n        return ch.charCodeAt(0).toString(16).toUpperCase();\n      }\n      function literalEscape(s2) {\n        return s2.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function classEscape(s2) {\n        return s2.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n          return \"\\\\x0\" + hex(ch);\n        }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n          return \"\\\\x\" + hex(ch);\n        });\n      }\n      function describeExpectation(expectation) {\n        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n      }\n      function describeExpected(expected2) {\n        var descriptions = expected2.map(describeExpectation);\n        var i, j;\n        descriptions.sort();\n        if (descriptions.length > 0) {\n          for (i = 1, j = 1; i < descriptions.length; i++) {\n            if (descriptions[i - 1] !== descriptions[i]) {\n              descriptions[j] = descriptions[i];\n              j++;\n            }\n          }\n          descriptions.length = j;\n        }\n        switch (descriptions.length) {\n          case 1:\n            return descriptions[0];\n          case 2:\n            return descriptions[0] + \" or \" + descriptions[1];\n          default:\n            return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n        }\n      }\n      function describeFound(found2) {\n        return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n      }\n      return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    };\n    function peg$parse(input, options) {\n      options = options !== void 0 ? options : {};\n      var peg$FAILED = {};\n      var peg$startRuleFunctions = { Top: peg$parseTop };\n      var peg$startRuleFunction = peg$parseTop;\n      var peg$c0 = \"/\";\n      var peg$c1 = \".\";\n      var peg$c2 = \"#\";\n      var peg$c3 = \"=\";\n      var peg$c4 = \"(\";\n      var peg$c5 = \")\";\n      var peg$c6 = \",\";\n      var peg$c7 = \"[\";\n      var peg$c8 = \"]\";\n      var peg$c9 = \"null\";\n      var peg$c10 = \"true\";\n      var peg$c11 = \"false\";\n      var peg$c12 = \"{\";\n      var peg$c13 = \"}\";\n      var peg$c14 = \":\";\n      var peg$c15 = \"-\";\n      var peg$c16 = '\"';\n      var peg$c17 = \"\\\\\";\n      var peg$r0 = /^[$@]/;\n      var peg$r1 = /^[0-9]/;\n      var peg$r2 = /^[^\\0-\\x1F\"\\\\]/;\n      var peg$r3 = /^[a-zA-Z0-9_\\-]/;\n      var peg$r4 = /^[ \\n\\t]/;\n      var peg$e0 = peg$literalExpectation(\"/\", false);\n      var peg$e1 = peg$otherExpectation(\"tag name\");\n      var peg$e2 = peg$otherExpectation(\"class\");\n      var peg$e3 = peg$otherExpectation(\"id\");\n      var peg$e4 = peg$literalExpectation(\"=\", false);\n      var peg$e5 = peg$literalExpectation(\"(\", false);\n      var peg$e6 = peg$literalExpectation(\")\", false);\n      var peg$e7 = peg$literalExpectation(\",\", false);\n      var peg$e8 = peg$otherExpectation(\"variable\");\n      var peg$e9 = peg$otherExpectation(\"null\");\n      var peg$e10 = peg$otherExpectation(\"boolean\");\n      var peg$e11 = peg$literalExpectation(\"[\", false);\n      var peg$e12 = peg$literalExpectation(\"]\", false);\n      var peg$e13 = peg$literalExpectation(\"{\", false);\n      var peg$e14 = peg$literalExpectation(\"}\", false);\n      var peg$e15 = peg$literalExpectation(\":\", false);\n      var peg$e16 = peg$otherExpectation(\"number\");\n      var peg$e17 = peg$otherExpectation(\"string\");\n      var peg$e18 = peg$otherExpectation(\"identifier\");\n      var peg$e19 = peg$otherExpectation(\"whitespace\");\n      var peg$f0 = function(variable) {\n        return { type: \"variable\", meta: { variable } };\n      };\n      var peg$f1 = function(attributes) {\n        return { type: \"annotation\", meta: { attributes } };\n      };\n      var peg$f2 = function(tag, value) {\n        return value;\n      };\n      var peg$f3 = function(tag, primary, attributes, close) {\n        if (primary) {\n          attributes = attributes || [];\n          attributes.unshift({\n            type: \"attribute\",\n            name: \"primary\",\n            value: primary\n          });\n        }\n        const [type, nesting] = close ? [\"tag\", 0] : [\"tag_open\", 1];\n        return { type, nesting, meta: { tag, attributes } };\n      };\n      var peg$f4 = function(tag) {\n        return { type: \"tag_close\", nesting: -1, meta: { tag } };\n      };\n      var peg$f5 = function(head, tail) {\n        return !head ? [] : [head, ...tail];\n      };\n      var peg$f6 = function(item2) {\n        return item2;\n      };\n      var peg$f7 = function(ids) {\n        return ids;\n      };\n      var peg$f8 = function(classes) {\n        return classes;\n      };\n      var peg$f9 = function(attribute) {\n        return attribute;\n      };\n      var peg$f10 = function(name) {\n        return { type: \"class\", name, value: true };\n      };\n      var peg$f11 = function(value) {\n        return { type: \"attribute\", name: \"id\", value };\n      };\n      var peg$f12 = function(name, value) {\n        return { type: \"attribute\", name, value };\n      };\n      var peg$f13 = function(name, head, tail) {\n        return head ? [head, ...tail] : [];\n      };\n      var peg$f14 = function(name, params) {\n        let parameters = {};\n        for (let [index, { name: name2, value }] of params.entries())\n          parameters[name2 || index] = value;\n        return new Function3(name, parameters);\n      };\n      var peg$f15 = function(name) {\n        return name;\n      };\n      var peg$f16 = function(name, value) {\n        return { name, value };\n      };\n      var peg$f17 = function(value) {\n        return value;\n      };\n      var peg$f18 = function(prefix, head, tail) {\n        if (prefix === \"@\")\n          return [head, ...tail];\n        return new Variable2([head, ...tail]);\n      };\n      var peg$f19 = function() {\n        return null;\n      };\n      var peg$f20 = function() {\n        return true;\n      };\n      var peg$f21 = function() {\n        return false;\n      };\n      var peg$f22 = function(head, tail) {\n        return [head, ...tail];\n      };\n      var peg$f23 = function(value) {\n        return value || [];\n      };\n      var peg$f24 = function(head, tail) {\n        return Object.assign(head, ...tail);\n      };\n      var peg$f25 = function(value) {\n        return value || {};\n      };\n      var peg$f26 = function(key, value) {\n        return key === \"$$mdtype\" ? {} : { [key]: value };\n      };\n      var peg$f27 = function() {\n        return parseFloat(text2());\n      };\n      var peg$f28 = function(value) {\n        return value.join(\"\");\n      };\n      var peg$f29 = function(sequence) {\n        return sequence;\n      };\n      var peg$currPos = 0;\n      var peg$savedPos = 0;\n      var peg$posDetailsCache = [{ line: 1, column: 1 }];\n      var peg$expected = [];\n      var peg$silentFails = 0;\n      var peg$result;\n      if (\"startRule\" in options) {\n        if (!(options.startRule in peg$startRuleFunctions)) {\n          throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n        }\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n      }\n      function text2() {\n        return input.substring(peg$savedPos, peg$currPos);\n      }\n      function offset() {\n        return peg$savedPos;\n      }\n      function range() {\n        return [peg$savedPos, peg$currPos];\n      }\n      function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n      }\n      function expected(description, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location2);\n      }\n      function error2(message, location2) {\n        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location2);\n      }\n      function peg$literalExpectation(text3, ignoreCase) {\n        return { type: \"literal\", text: text3, ignoreCase };\n      }\n      function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n          type: \"class\",\n          parts,\n          inverted,\n          ignoreCase\n        };\n      }\n      function peg$anyExpectation() {\n        return { type: \"any\" };\n      }\n      function peg$endExpectation() {\n        return { type: \"end\" };\n      }\n      function peg$otherExpectation(description) {\n        return { type: \"other\", description };\n      }\n      function peg$computePosDetails(pos) {\n        var details = peg$posDetailsCache[pos];\n        var p;\n        if (details) {\n          return details;\n        } else {\n          p = pos - 1;\n          while (!peg$posDetailsCache[p]) {\n            p--;\n          }\n          details = peg$posDetailsCache[p];\n          details = {\n            line: details.line,\n            column: details.column\n          };\n          while (p < pos) {\n            if (input.charCodeAt(p) === 10) {\n              details.line++;\n              details.column = 1;\n            } else {\n              details.column++;\n            }\n            p++;\n          }\n          peg$posDetailsCache[pos] = details;\n          return details;\n        }\n      }\n      var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n      function peg$computeLocation(startPos, endPos) {\n        var loc = {};\n        if (peg$VALIDFILENAME)\n          loc.filename = options.filename;\n        var startPosDetails = peg$computePosDetails(startPos);\n        loc.start = {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        };\n        var endPosDetails = peg$computePosDetails(endPos);\n        loc.end = {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        };\n        return loc;\n      }\n      function peg$begin() {\n        peg$expected.push({ pos: peg$currPos, variants: [] });\n      }\n      function peg$expect(expected2) {\n        var top = peg$expected[peg$expected.length - 1];\n        if (peg$currPos < top.pos) {\n          return;\n        }\n        if (peg$currPos > top.pos) {\n          top.pos = peg$currPos;\n          top.variants = [];\n        }\n        top.variants.push(expected2);\n      }\n      function peg$end(invert) {\n        var expected2 = peg$expected.pop();\n        var top = peg$expected[peg$expected.length - 1];\n        var variants = expected2.variants;\n        if (top.pos !== expected2.pos) {\n          return;\n        }\n        if (invert) {\n          variants = variants.map(function(e) {\n            return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n          });\n        }\n        Array.prototype.push.apply(top.variants, variants);\n      }\n      function peg$buildSimpleError(message, location2) {\n        return new peg$SyntaxError(message, null, null, location2);\n      }\n      function peg$buildStructuredError(expected2, found, location2) {\n        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location2), expected2, found, location2);\n      }\n      function peg$buildError() {\n        var expected2 = peg$expected[0];\n        var failPos = expected2.pos;\n        return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));\n      }\n      function peg$parseTop() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$parseTopLevelValue();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseAnnotation();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseTagOpen();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseTagClose();\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseTopLevelValue() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseVariable();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseFunction();\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f0(s1);\n        }\n        s0 = s1;\n        return s0;\n      }\n      function peg$parseAnnotation() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagAttributes();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f1(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagOpen() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagName();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            peg$savedPos = s3;\n            s3 = peg$f2(s1, s4);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = peg$parseTagAttributes();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          s5 = [];\n          s6 = peg$parse_();\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parse_();\n          }\n          rule$expects(peg$e0);\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s6 = peg$c0;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f3(s1, s3, s4, s6);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagClose() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e0);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s1 = peg$c0;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseTagName();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagName() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e1);\n        peg$silentFails++;\n        s0 = peg$parseIdentifier();\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagAttributes() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagAttributesItem();\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseTagAttributesTail();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseTagAttributesTail();\n          }\n          peg$savedPos = s0;\n          s0 = peg$f5(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagAttributesTail() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            s2 = peg$parse_();\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseTagAttributesItem();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTagAttributesItem() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseTagShortcutId();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f7(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseTagShortcutClass();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f8(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseTagAttribute();\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f9(s1);\n            }\n            s0 = s1;\n          }\n        }\n        return s0;\n      }\n      function peg$parseTagShortcutClass() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e2);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c1;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f10(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagShortcutId() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e3);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s1 = peg$c2;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseTagAttribute() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e4);\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s2 = peg$c3;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseValue();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f12(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunction() {\n        var s0, s1, s2, s3, s4, s5, s6, s7;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e5);\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s2 = peg$c4;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parse_();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n            s4 = peg$currPos;\n            s5 = peg$parseFunctionParameter();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            s6 = [];\n            s7 = peg$parseFunctionParameterTail();\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$parseFunctionParameterTail();\n            }\n            peg$savedPos = s4;\n            s4 = peg$f13(s1, s5, s6);\n            rule$expects(peg$e6);\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c5;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f14(s1, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunctionParameter() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseIdentifier();\n        if (s2 !== peg$FAILED) {\n          rule$expects(peg$e4);\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s1;\n            s1 = peg$f15(s2);\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = peg$parseValue();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f16(s1, s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseFunctionParameterTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseFunctionParameter();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseTrailingComma() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = null;\n        }\n        return s0;\n      }\n      function peg$parseVariable() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e8);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parseVariableTail();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parseVariableTail();\n            }\n            peg$savedPos = s0;\n            s0 = peg$f18(s1, s2, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseVariableTail() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s1 = peg$c1;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f15(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c7;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseValueNumber();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parseValueString();\n            }\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s3 = peg$c8;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f17(s2);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n        return s0;\n      }\n      function peg$parseValue() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$parseValueNull();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueBoolean();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseValueString();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseValueNumber();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseValueArray();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseValueHash();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseFunction();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseVariable();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return s0;\n      }\n      function peg$parseValueNull() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e9);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c9) {\n          s1 = peg$c9;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f19();\n        }\n        s0 = s1;\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueBoolean() {\n        var s0, s1;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e10);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c10) {\n          s1 = peg$c10;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f20();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c11) {\n            s1 = peg$c11;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f21();\n          }\n          s0 = s1;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueArray() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e11);\n        if (input.charCodeAt(peg$currPos) === 91) {\n          s1 = peg$c7;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseValueArrayTail();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseValueArrayTail();\n            }\n            s6 = peg$parseTrailingComma();\n            peg$savedPos = s3;\n            s3 = peg$f22(s4, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          rule$expects(peg$e12);\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s5 = peg$c8;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f23(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueArrayTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseValue();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f17(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHash() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        rule$expects(peg$e13);\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c12;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parse_();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parse_();\n          }\n          s3 = peg$currPos;\n          s4 = peg$parseValueHashItem();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseValueHashTail();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseValueHashTail();\n            }\n            s6 = peg$parseTrailingComma();\n            peg$savedPos = s3;\n            s3 = peg$f24(s4, s5);\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s4 = [];\n          s5 = peg$parse_();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parse_();\n          }\n          rule$expects(peg$e14);\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c13;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f25(s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHashTail() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        rule$expects(peg$e7);\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          s4 = peg$parseValueHashItem();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueHashItem() {\n        var s0, s1, s2, s3, s4;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        s1 = peg$parseIdentifier();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseValueString();\n        }\n        if (s1 !== peg$FAILED) {\n          rule$expects(peg$e15);\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s2 = peg$c14;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parse_();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n            s4 = peg$parseValue();\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f26(s1, s4);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseValueNumber() {\n        var s0, s1, s2, s3, s4, s5, s6;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e16);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c15;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        s2 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s4 = peg$c1;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n            }\n            if (s6 !== peg$FAILED) {\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                if (peg$r1.test(input.charAt(peg$currPos))) {\n                  s6 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                }\n              }\n            } else {\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          peg$savedPos = s0;\n          s0 = peg$f27();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueString() {\n        var s0, s1, s2, s3;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e17);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s1 = peg$c16;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = [];\n          s3 = peg$parseValueStringChars();\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseValueStringChars();\n          }\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c16;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f28(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parseValueStringChars() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseValueStringEscapes();\n        }\n        return s0;\n      }\n      function peg$parseValueStringEscapes() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s2 = peg$c16;\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n          }\n          if (s2 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 92) {\n              s2 = peg$c17;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f29(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        return s0;\n      }\n      function peg$parseIdentifier() {\n        var s0, s1, s2;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e18);\n        peg$silentFails++;\n        s0 = peg$currPos;\n        s1 = [];\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          while (s2 !== peg$FAILED) {\n            s1.push(s2);\n            if (peg$r3.test(input.charAt(peg$currPos))) {\n              s2 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n          }\n        } else {\n          s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n          s0 = input.substring(s0, peg$currPos);\n        } else {\n          s0 = s1;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      function peg$parse_() {\n        var s0;\n        var rule$expects = function(expected2) {\n          if (peg$silentFails === 0)\n            peg$expect(expected2);\n        };\n        rule$expects(peg$e19);\n        peg$silentFails++;\n        if (peg$r4.test(input.charAt(peg$currPos))) {\n          s0 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n        }\n        peg$silentFails--;\n        return s0;\n      }\n      const { Variable: Variable2, Function: Function3 } = options;\n      peg$begin();\n      peg$result = peg$startRuleFunction();\n      if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n        return peg$result;\n      } else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n          peg$expect(peg$endExpectation());\n        }\n        throw peg$buildError();\n      }\n    }\n    module.exports = {\n      SyntaxError: peg$SyntaxError,\n      parse: peg$parse\n    };\n  }\n});\n\n// node_modules/entities/lib/maps/entities.json\nvar require_entities = __commonJS({\n  \"node_modules/entities/lib/maps/entities.json\"(exports, module) {\n    module.exports = { Aacute: \"\\xC1\", aacute: \"\\xE1\", Abreve: \"\\u0102\", abreve: \"\\u0103\", ac: \"\\u223E\", acd: \"\\u223F\", acE: \"\\u223E\\u0333\", Acirc: \"\\xC2\", acirc: \"\\xE2\", acute: \"\\xB4\", Acy: \"\\u0410\", acy: \"\\u0430\", AElig: \"\\xC6\", aelig: \"\\xE6\", af: \"\\u2061\", Afr: \"\\u{1D504}\", afr: \"\\u{1D51E}\", Agrave: \"\\xC0\", agrave: \"\\xE0\", alefsym: \"\\u2135\", aleph: \"\\u2135\", Alpha: \"\\u0391\", alpha: \"\\u03B1\", Amacr: \"\\u0100\", amacr: \"\\u0101\", amalg: \"\\u2A3F\", amp: \"&\", AMP: \"&\", andand: \"\\u2A55\", And: \"\\u2A53\", and: \"\\u2227\", andd: \"\\u2A5C\", andslope: \"\\u2A58\", andv: \"\\u2A5A\", ang: \"\\u2220\", ange: \"\\u29A4\", angle: \"\\u2220\", angmsdaa: \"\\u29A8\", angmsdab: \"\\u29A9\", angmsdac: \"\\u29AA\", angmsdad: \"\\u29AB\", angmsdae: \"\\u29AC\", angmsdaf: \"\\u29AD\", angmsdag: \"\\u29AE\", angmsdah: \"\\u29AF\", angmsd: \"\\u2221\", angrt: \"\\u221F\", angrtvb: \"\\u22BE\", angrtvbd: \"\\u299D\", angsph: \"\\u2222\", angst: \"\\xC5\", angzarr: \"\\u237C\", Aogon: \"\\u0104\", aogon: \"\\u0105\", Aopf: \"\\u{1D538}\", aopf: \"\\u{1D552}\", apacir: \"\\u2A6F\", ap: \"\\u2248\", apE: \"\\u2A70\", ape: \"\\u224A\", apid: \"\\u224B\", apos: \"'\", ApplyFunction: \"\\u2061\", approx: \"\\u2248\", approxeq: \"\\u224A\", Aring: \"\\xC5\", aring: \"\\xE5\", Ascr: \"\\u{1D49C}\", ascr: \"\\u{1D4B6}\", Assign: \"\\u2254\", ast: \"*\", asymp: \"\\u2248\", asympeq: \"\\u224D\", Atilde: \"\\xC3\", atilde: \"\\xE3\", Auml: \"\\xC4\", auml: \"\\xE4\", awconint: \"\\u2233\", awint: \"\\u2A11\", backcong: \"\\u224C\", backepsilon: \"\\u03F6\", backprime: \"\\u2035\", backsim: \"\\u223D\", backsimeq: \"\\u22CD\", Backslash: \"\\u2216\", Barv: \"\\u2AE7\", barvee: \"\\u22BD\", barwed: \"\\u2305\", Barwed: \"\\u2306\", barwedge: \"\\u2305\", bbrk: \"\\u23B5\", bbrktbrk: \"\\u23B6\", bcong: \"\\u224C\", Bcy: \"\\u0411\", bcy: \"\\u0431\", bdquo: \"\\u201E\", becaus: \"\\u2235\", because: \"\\u2235\", Because: \"\\u2235\", bemptyv: \"\\u29B0\", bepsi: \"\\u03F6\", bernou: \"\\u212C\", Bernoullis: \"\\u212C\", Beta: \"\\u0392\", beta: \"\\u03B2\", beth: \"\\u2136\", between: \"\\u226C\", Bfr: \"\\u{1D505}\", bfr: \"\\u{1D51F}\", bigcap: \"\\u22C2\", bigcirc: \"\\u25EF\", bigcup: \"\\u22C3\", bigodot: \"\\u2A00\", bigoplus: \"\\u2A01\", bigotimes: \"\\u2A02\", bigsqcup: \"\\u2A06\", bigstar: \"\\u2605\", bigtriangledown: \"\\u25BD\", bigtriangleup: \"\\u25B3\", biguplus: \"\\u2A04\", bigvee: \"\\u22C1\", bigwedge: \"\\u22C0\", bkarow: \"\\u290D\", blacklozenge: \"\\u29EB\", blacksquare: \"\\u25AA\", blacktriangle: \"\\u25B4\", blacktriangledown: \"\\u25BE\", blacktriangleleft: \"\\u25C2\", blacktriangleright: \"\\u25B8\", blank: \"\\u2423\", blk12: \"\\u2592\", blk14: \"\\u2591\", blk34: \"\\u2593\", block: \"\\u2588\", bne: \"=\\u20E5\", bnequiv: \"\\u2261\\u20E5\", bNot: \"\\u2AED\", bnot: \"\\u2310\", Bopf: \"\\u{1D539}\", bopf: \"\\u{1D553}\", bot: \"\\u22A5\", bottom: \"\\u22A5\", bowtie: \"\\u22C8\", boxbox: \"\\u29C9\", boxdl: \"\\u2510\", boxdL: \"\\u2555\", boxDl: \"\\u2556\", boxDL: \"\\u2557\", boxdr: \"\\u250C\", boxdR: \"\\u2552\", boxDr: \"\\u2553\", boxDR: \"\\u2554\", boxh: \"\\u2500\", boxH: \"\\u2550\", boxhd: \"\\u252C\", boxHd: \"\\u2564\", boxhD: \"\\u2565\", boxHD: \"\\u2566\", boxhu: \"\\u2534\", boxHu: \"\\u2567\", boxhU: \"\\u2568\", boxHU: \"\\u2569\", boxminus: \"\\u229F\", boxplus: \"\\u229E\", boxtimes: \"\\u22A0\", boxul: \"\\u2518\", boxuL: \"\\u255B\", boxUl: \"\\u255C\", boxUL: \"\\u255D\", boxur: \"\\u2514\", boxuR: \"\\u2558\", boxUr: \"\\u2559\", boxUR: \"\\u255A\", boxv: \"\\u2502\", boxV: \"\\u2551\", boxvh: \"\\u253C\", boxvH: \"\\u256A\", boxVh: \"\\u256B\", boxVH: \"\\u256C\", boxvl: \"\\u2524\", boxvL: \"\\u2561\", boxVl: \"\\u2562\", boxVL: \"\\u2563\", boxvr: \"\\u251C\", boxvR: \"\\u255E\", boxVr: \"\\u255F\", boxVR: \"\\u2560\", bprime: \"\\u2035\", breve: \"\\u02D8\", Breve: \"\\u02D8\", brvbar: \"\\xA6\", bscr: \"\\u{1D4B7}\", Bscr: \"\\u212C\", bsemi: \"\\u204F\", bsim: \"\\u223D\", bsime: \"\\u22CD\", bsolb: \"\\u29C5\", bsol: \"\\\\\", bsolhsub: \"\\u27C8\", bull: \"\\u2022\", bullet: \"\\u2022\", bump: \"\\u224E\", bumpE: \"\\u2AAE\", bumpe: \"\\u224F\", Bumpeq: \"\\u224E\", bumpeq: \"\\u224F\", Cacute: \"\\u0106\", cacute: \"\\u0107\", capand: \"\\u2A44\", capbrcup: \"\\u2A49\", capcap: \"\\u2A4B\", cap: \"\\u2229\", Cap: \"\\u22D2\", capcup: \"\\u2A47\", capdot: \"\\u2A40\", CapitalDifferentialD: \"\\u2145\", caps: \"\\u2229\\uFE00\", caret: \"\\u2041\", caron: \"\\u02C7\", Cayleys: \"\\u212D\", ccaps: \"\\u2A4D\", Ccaron: \"\\u010C\", ccaron: \"\\u010D\", Ccedil: \"\\xC7\", ccedil: \"\\xE7\", Ccirc: \"\\u0108\", ccirc: \"\\u0109\", Cconint: \"\\u2230\", ccups: \"\\u2A4C\", ccupssm: \"\\u2A50\", Cdot: \"\\u010A\", cdot: \"\\u010B\", cedil: \"\\xB8\", Cedilla: \"\\xB8\", cemptyv: \"\\u29B2\", cent: \"\\xA2\", centerdot: \"\\xB7\", CenterDot: \"\\xB7\", cfr: \"\\u{1D520}\", Cfr: \"\\u212D\", CHcy: \"\\u0427\", chcy: \"\\u0447\", check: \"\\u2713\", checkmark: \"\\u2713\", Chi: \"\\u03A7\", chi: \"\\u03C7\", circ: \"\\u02C6\", circeq: \"\\u2257\", circlearrowleft: \"\\u21BA\", circlearrowright: \"\\u21BB\", circledast: \"\\u229B\", circledcirc: \"\\u229A\", circleddash: \"\\u229D\", CircleDot: \"\\u2299\", circledR: \"\\xAE\", circledS: \"\\u24C8\", CircleMinus: \"\\u2296\", CirclePlus: \"\\u2295\", CircleTimes: \"\\u2297\", cir: \"\\u25CB\", cirE: \"\\u29C3\", cire: \"\\u2257\", cirfnint: \"\\u2A10\", cirmid: \"\\u2AEF\", cirscir: \"\\u29C2\", ClockwiseContourIntegral: \"\\u2232\", CloseCurlyDoubleQuote: \"\\u201D\", CloseCurlyQuote: \"\\u2019\", clubs: \"\\u2663\", clubsuit: \"\\u2663\", colon: \":\", Colon: \"\\u2237\", Colone: \"\\u2A74\", colone: \"\\u2254\", coloneq: \"\\u2254\", comma: \",\", commat: \"@\", comp: \"\\u2201\", compfn: \"\\u2218\", complement: \"\\u2201\", complexes: \"\\u2102\", cong: \"\\u2245\", congdot: \"\\u2A6D\", Congruent: \"\\u2261\", conint: \"\\u222E\", Conint: \"\\u222F\", ContourIntegral: \"\\u222E\", copf: \"\\u{1D554}\", Copf: \"\\u2102\", coprod: \"\\u2210\", Coproduct: \"\\u2210\", copy: \"\\xA9\", COPY: \"\\xA9\", copysr: \"\\u2117\", CounterClockwiseContourIntegral: \"\\u2233\", crarr: \"\\u21B5\", cross: \"\\u2717\", Cross: \"\\u2A2F\", Cscr: \"\\u{1D49E}\", cscr: \"\\u{1D4B8}\", csub: \"\\u2ACF\", csube: \"\\u2AD1\", csup: \"\\u2AD0\", csupe: \"\\u2AD2\", ctdot: \"\\u22EF\", cudarrl: \"\\u2938\", cudarrr: \"\\u2935\", cuepr: \"\\u22DE\", cuesc: \"\\u22DF\", cularr: \"\\u21B6\", cularrp: \"\\u293D\", cupbrcap: \"\\u2A48\", cupcap: \"\\u2A46\", CupCap: \"\\u224D\", cup: \"\\u222A\", Cup: \"\\u22D3\", cupcup: \"\\u2A4A\", cupdot: \"\\u228D\", cupor: \"\\u2A45\", cups: \"\\u222A\\uFE00\", curarr: \"\\u21B7\", curarrm: \"\\u293C\", curlyeqprec: \"\\u22DE\", curlyeqsucc: \"\\u22DF\", curlyvee: \"\\u22CE\", curlywedge: \"\\u22CF\", curren: \"\\xA4\", curvearrowleft: \"\\u21B6\", curvearrowright: \"\\u21B7\", cuvee: \"\\u22CE\", cuwed: \"\\u22CF\", cwconint: \"\\u2232\", cwint: \"\\u2231\", cylcty: \"\\u232D\", dagger: \"\\u2020\", Dagger: \"\\u2021\", daleth: \"\\u2138\", darr: \"\\u2193\", Darr: \"\\u21A1\", dArr: \"\\u21D3\", dash: \"\\u2010\", Dashv: \"\\u2AE4\", dashv: \"\\u22A3\", dbkarow: \"\\u290F\", dblac: \"\\u02DD\", Dcaron: \"\\u010E\", dcaron: \"\\u010F\", Dcy: \"\\u0414\", dcy: \"\\u0434\", ddagger: \"\\u2021\", ddarr: \"\\u21CA\", DD: \"\\u2145\", dd: \"\\u2146\", DDotrahd: \"\\u2911\", ddotseq: \"\\u2A77\", deg: \"\\xB0\", Del: \"\\u2207\", Delta: \"\\u0394\", delta: \"\\u03B4\", demptyv: \"\\u29B1\", dfisht: \"\\u297F\", Dfr: \"\\u{1D507}\", dfr: \"\\u{1D521}\", dHar: \"\\u2965\", dharl: \"\\u21C3\", dharr: \"\\u21C2\", DiacriticalAcute: \"\\xB4\", DiacriticalDot: \"\\u02D9\", DiacriticalDoubleAcute: \"\\u02DD\", DiacriticalGrave: \"`\", DiacriticalTilde: \"\\u02DC\", diam: \"\\u22C4\", diamond: \"\\u22C4\", Diamond: \"\\u22C4\", diamondsuit: \"\\u2666\", diams: \"\\u2666\", die: \"\\xA8\", DifferentialD: \"\\u2146\", digamma: \"\\u03DD\", disin: \"\\u22F2\", div: \"\\xF7\", divide: \"\\xF7\", divideontimes: \"\\u22C7\", divonx: \"\\u22C7\", DJcy: \"\\u0402\", djcy: \"\\u0452\", dlcorn: \"\\u231E\", dlcrop: \"\\u230D\", dollar: \"$\", Dopf: \"\\u{1D53B}\", dopf: \"\\u{1D555}\", Dot: \"\\xA8\", dot: \"\\u02D9\", DotDot: \"\\u20DC\", doteq: \"\\u2250\", doteqdot: \"\\u2251\", DotEqual: \"\\u2250\", dotminus: \"\\u2238\", dotplus: \"\\u2214\", dotsquare: \"\\u22A1\", doublebarwedge: \"\\u2306\", DoubleContourIntegral: \"\\u222F\", DoubleDot: \"\\xA8\", DoubleDownArrow: \"\\u21D3\", DoubleLeftArrow: \"\\u21D0\", DoubleLeftRightArrow: \"\\u21D4\", DoubleLeftTee: \"\\u2AE4\", DoubleLongLeftArrow: \"\\u27F8\", DoubleLongLeftRightArrow: \"\\u27FA\", DoubleLongRightArrow: \"\\u27F9\", DoubleRightArrow: \"\\u21D2\", DoubleRightTee: \"\\u22A8\", DoubleUpArrow: \"\\u21D1\", DoubleUpDownArrow: \"\\u21D5\", DoubleVerticalBar: \"\\u2225\", DownArrowBar: \"\\u2913\", downarrow: \"\\u2193\", DownArrow: \"\\u2193\", Downarrow: \"\\u21D3\", DownArrowUpArrow: \"\\u21F5\", DownBreve: \"\\u0311\", downdownarrows: \"\\u21CA\", downharpoonleft: \"\\u21C3\", downharpoonright: \"\\u21C2\", DownLeftRightVector: \"\\u2950\", DownLeftTeeVector: \"\\u295E\", DownLeftVectorBar: \"\\u2956\", DownLeftVector: \"\\u21BD\", DownRightTeeVector: \"\\u295F\", DownRightVectorBar: \"\\u2957\", DownRightVector: \"\\u21C1\", DownTeeArrow: \"\\u21A7\", DownTee: \"\\u22A4\", drbkarow: \"\\u2910\", drcorn: \"\\u231F\", drcrop: \"\\u230C\", Dscr: \"\\u{1D49F}\", dscr: \"\\u{1D4B9}\", DScy: \"\\u0405\", dscy: \"\\u0455\", dsol: \"\\u29F6\", Dstrok: \"\\u0110\", dstrok: \"\\u0111\", dtdot: \"\\u22F1\", dtri: \"\\u25BF\", dtrif: \"\\u25BE\", duarr: \"\\u21F5\", duhar: \"\\u296F\", dwangle: \"\\u29A6\", DZcy: \"\\u040F\", dzcy: \"\\u045F\", dzigrarr: \"\\u27FF\", Eacute: \"\\xC9\", eacute: \"\\xE9\", easter: \"\\u2A6E\", Ecaron: \"\\u011A\", ecaron: \"\\u011B\", Ecirc: \"\\xCA\", ecirc: \"\\xEA\", ecir: \"\\u2256\", ecolon: \"\\u2255\", Ecy: \"\\u042D\", ecy: \"\\u044D\", eDDot: \"\\u2A77\", Edot: \"\\u0116\", edot: \"\\u0117\", eDot: \"\\u2251\", ee: \"\\u2147\", efDot: \"\\u2252\", Efr: \"\\u{1D508}\", efr: \"\\u{1D522}\", eg: \"\\u2A9A\", Egrave: \"\\xC8\", egrave: \"\\xE8\", egs: \"\\u2A96\", egsdot: \"\\u2A98\", el: \"\\u2A99\", Element: \"\\u2208\", elinters: \"\\u23E7\", ell: \"\\u2113\", els: \"\\u2A95\", elsdot: \"\\u2A97\", Emacr: \"\\u0112\", emacr: \"\\u0113\", empty: \"\\u2205\", emptyset: \"\\u2205\", EmptySmallSquare: \"\\u25FB\", emptyv: \"\\u2205\", EmptyVerySmallSquare: \"\\u25AB\", emsp13: \"\\u2004\", emsp14: \"\\u2005\", emsp: \"\\u2003\", ENG: \"\\u014A\", eng: \"\\u014B\", ensp: \"\\u2002\", Eogon: \"\\u0118\", eogon: \"\\u0119\", Eopf: \"\\u{1D53C}\", eopf: \"\\u{1D556}\", epar: \"\\u22D5\", eparsl: \"\\u29E3\", eplus: \"\\u2A71\", epsi: \"\\u03B5\", Epsilon: \"\\u0395\", epsilon: \"\\u03B5\", epsiv: \"\\u03F5\", eqcirc: \"\\u2256\", eqcolon: \"\\u2255\", eqsim: \"\\u2242\", eqslantgtr: \"\\u2A96\", eqslantless: \"\\u2A95\", Equal: \"\\u2A75\", equals: \"=\", EqualTilde: \"\\u2242\", equest: \"\\u225F\", Equilibrium: \"\\u21CC\", equiv: \"\\u2261\", equivDD: \"\\u2A78\", eqvparsl: \"\\u29E5\", erarr: \"\\u2971\", erDot: \"\\u2253\", escr: \"\\u212F\", Escr: \"\\u2130\", esdot: \"\\u2250\", Esim: \"\\u2A73\", esim: \"\\u2242\", Eta: \"\\u0397\", eta: \"\\u03B7\", ETH: \"\\xD0\", eth: \"\\xF0\", Euml: \"\\xCB\", euml: \"\\xEB\", euro: \"\\u20AC\", excl: \"!\", exist: \"\\u2203\", Exists: \"\\u2203\", expectation: \"\\u2130\", exponentiale: \"\\u2147\", ExponentialE: \"\\u2147\", fallingdotseq: \"\\u2252\", Fcy: \"\\u0424\", fcy: \"\\u0444\", female: \"\\u2640\", ffilig: \"\\uFB03\", fflig: \"\\uFB00\", ffllig: \"\\uFB04\", Ffr: \"\\u{1D509}\", ffr: \"\\u{1D523}\", filig: \"\\uFB01\", FilledSmallSquare: \"\\u25FC\", FilledVerySmallSquare: \"\\u25AA\", fjlig: \"fj\", flat: \"\\u266D\", fllig: \"\\uFB02\", fltns: \"\\u25B1\", fnof: \"\\u0192\", Fopf: \"\\u{1D53D}\", fopf: \"\\u{1D557}\", forall: \"\\u2200\", ForAll: \"\\u2200\", fork: \"\\u22D4\", forkv: \"\\u2AD9\", Fouriertrf: \"\\u2131\", fpartint: \"\\u2A0D\", frac12: \"\\xBD\", frac13: \"\\u2153\", frac14: \"\\xBC\", frac15: \"\\u2155\", frac16: \"\\u2159\", frac18: \"\\u215B\", frac23: \"\\u2154\", frac25: \"\\u2156\", frac34: \"\\xBE\", frac35: \"\\u2157\", frac38: \"\\u215C\", frac45: \"\\u2158\", frac56: \"\\u215A\", frac58: \"\\u215D\", frac78: \"\\u215E\", frasl: \"\\u2044\", frown: \"\\u2322\", fscr: \"\\u{1D4BB}\", Fscr: \"\\u2131\", gacute: \"\\u01F5\", Gamma: \"\\u0393\", gamma: \"\\u03B3\", Gammad: \"\\u03DC\", gammad: \"\\u03DD\", gap: \"\\u2A86\", Gbreve: \"\\u011E\", gbreve: \"\\u011F\", Gcedil: \"\\u0122\", Gcirc: \"\\u011C\", gcirc: \"\\u011D\", Gcy: \"\\u0413\", gcy: \"\\u0433\", Gdot: \"\\u0120\", gdot: \"\\u0121\", ge: \"\\u2265\", gE: \"\\u2267\", gEl: \"\\u2A8C\", gel: \"\\u22DB\", geq: \"\\u2265\", geqq: \"\\u2267\", geqslant: \"\\u2A7E\", gescc: \"\\u2AA9\", ges: \"\\u2A7E\", gesdot: \"\\u2A80\", gesdoto: \"\\u2A82\", gesdotol: \"\\u2A84\", gesl: \"\\u22DB\\uFE00\", gesles: \"\\u2A94\", Gfr: \"\\u{1D50A}\", gfr: \"\\u{1D524}\", gg: \"\\u226B\", Gg: \"\\u22D9\", ggg: \"\\u22D9\", gimel: \"\\u2137\", GJcy: \"\\u0403\", gjcy: \"\\u0453\", gla: \"\\u2AA5\", gl: \"\\u2277\", glE: \"\\u2A92\", glj: \"\\u2AA4\", gnap: \"\\u2A8A\", gnapprox: \"\\u2A8A\", gne: \"\\u2A88\", gnE: \"\\u2269\", gneq: \"\\u2A88\", gneqq: \"\\u2269\", gnsim: \"\\u22E7\", Gopf: \"\\u{1D53E}\", gopf: \"\\u{1D558}\", grave: \"`\", GreaterEqual: \"\\u2265\", GreaterEqualLess: \"\\u22DB\", GreaterFullEqual: \"\\u2267\", GreaterGreater: \"\\u2AA2\", GreaterLess: \"\\u2277\", GreaterSlantEqual: \"\\u2A7E\", GreaterTilde: \"\\u2273\", Gscr: \"\\u{1D4A2}\", gscr: \"\\u210A\", gsim: \"\\u2273\", gsime: \"\\u2A8E\", gsiml: \"\\u2A90\", gtcc: \"\\u2AA7\", gtcir: \"\\u2A7A\", gt: \">\", GT: \">\", Gt: \"\\u226B\", gtdot: \"\\u22D7\", gtlPar: \"\\u2995\", gtquest: \"\\u2A7C\", gtrapprox: \"\\u2A86\", gtrarr: \"\\u2978\", gtrdot: \"\\u22D7\", gtreqless: \"\\u22DB\", gtreqqless: \"\\u2A8C\", gtrless: \"\\u2277\", gtrsim: \"\\u2273\", gvertneqq: \"\\u2269\\uFE00\", gvnE: \"\\u2269\\uFE00\", Hacek: \"\\u02C7\", hairsp: \"\\u200A\", half: \"\\xBD\", hamilt: \"\\u210B\", HARDcy: \"\\u042A\", hardcy: \"\\u044A\", harrcir: \"\\u2948\", harr: \"\\u2194\", hArr: \"\\u21D4\", harrw: \"\\u21AD\", Hat: \"^\", hbar: \"\\u210F\", Hcirc: \"\\u0124\", hcirc: \"\\u0125\", hearts: \"\\u2665\", heartsuit: \"\\u2665\", hellip: \"\\u2026\", hercon: \"\\u22B9\", hfr: \"\\u{1D525}\", Hfr: \"\\u210C\", HilbertSpace: \"\\u210B\", hksearow: \"\\u2925\", hkswarow: \"\\u2926\", hoarr: \"\\u21FF\", homtht: \"\\u223B\", hookleftarrow: \"\\u21A9\", hookrightarrow: \"\\u21AA\", hopf: \"\\u{1D559}\", Hopf: \"\\u210D\", horbar: \"\\u2015\", HorizontalLine: \"\\u2500\", hscr: \"\\u{1D4BD}\", Hscr: \"\\u210B\", hslash: \"\\u210F\", Hstrok: \"\\u0126\", hstrok: \"\\u0127\", HumpDownHump: \"\\u224E\", HumpEqual: \"\\u224F\", hybull: \"\\u2043\", hyphen: \"\\u2010\", Iacute: \"\\xCD\", iacute: \"\\xED\", ic: \"\\u2063\", Icirc: \"\\xCE\", icirc: \"\\xEE\", Icy: \"\\u0418\", icy: \"\\u0438\", Idot: \"\\u0130\", IEcy: \"\\u0415\", iecy: \"\\u0435\", iexcl: \"\\xA1\", iff: \"\\u21D4\", ifr: \"\\u{1D526}\", Ifr: \"\\u2111\", Igrave: \"\\xCC\", igrave: \"\\xEC\", ii: \"\\u2148\", iiiint: \"\\u2A0C\", iiint: \"\\u222D\", iinfin: \"\\u29DC\", iiota: \"\\u2129\", IJlig: \"\\u0132\", ijlig: \"\\u0133\", Imacr: \"\\u012A\", imacr: \"\\u012B\", image: \"\\u2111\", ImaginaryI: \"\\u2148\", imagline: \"\\u2110\", imagpart: \"\\u2111\", imath: \"\\u0131\", Im: \"\\u2111\", imof: \"\\u22B7\", imped: \"\\u01B5\", Implies: \"\\u21D2\", incare: \"\\u2105\", in: \"\\u2208\", infin: \"\\u221E\", infintie: \"\\u29DD\", inodot: \"\\u0131\", intcal: \"\\u22BA\", int: \"\\u222B\", Int: \"\\u222C\", integers: \"\\u2124\", Integral: \"\\u222B\", intercal: \"\\u22BA\", Intersection: \"\\u22C2\", intlarhk: \"\\u2A17\", intprod: \"\\u2A3C\", InvisibleComma: \"\\u2063\", InvisibleTimes: \"\\u2062\", IOcy: \"\\u0401\", iocy: \"\\u0451\", Iogon: \"\\u012E\", iogon: \"\\u012F\", Iopf: \"\\u{1D540}\", iopf: \"\\u{1D55A}\", Iota: \"\\u0399\", iota: \"\\u03B9\", iprod: \"\\u2A3C\", iquest: \"\\xBF\", iscr: \"\\u{1D4BE}\", Iscr: \"\\u2110\", isin: \"\\u2208\", isindot: \"\\u22F5\", isinE: \"\\u22F9\", isins: \"\\u22F4\", isinsv: \"\\u22F3\", isinv: \"\\u2208\", it: \"\\u2062\", Itilde: \"\\u0128\", itilde: \"\\u0129\", Iukcy: \"\\u0406\", iukcy: \"\\u0456\", Iuml: \"\\xCF\", iuml: \"\\xEF\", Jcirc: \"\\u0134\", jcirc: \"\\u0135\", Jcy: \"\\u0419\", jcy: \"\\u0439\", Jfr: \"\\u{1D50D}\", jfr: \"\\u{1D527}\", jmath: \"\\u0237\", Jopf: \"\\u{1D541}\", jopf: \"\\u{1D55B}\", Jscr: \"\\u{1D4A5}\", jscr: \"\\u{1D4BF}\", Jsercy: \"\\u0408\", jsercy: \"\\u0458\", Jukcy: \"\\u0404\", jukcy: \"\\u0454\", Kappa: \"\\u039A\", kappa: \"\\u03BA\", kappav: \"\\u03F0\", Kcedil: \"\\u0136\", kcedil: \"\\u0137\", Kcy: \"\\u041A\", kcy: \"\\u043A\", Kfr: \"\\u{1D50E}\", kfr: \"\\u{1D528}\", kgreen: \"\\u0138\", KHcy: \"\\u0425\", khcy: \"\\u0445\", KJcy: \"\\u040C\", kjcy: \"\\u045C\", Kopf: \"\\u{1D542}\", kopf: \"\\u{1D55C}\", Kscr: \"\\u{1D4A6}\", kscr: \"\\u{1D4C0}\", lAarr: \"\\u21DA\", Lacute: \"\\u0139\", lacute: \"\\u013A\", laemptyv: \"\\u29B4\", lagran: \"\\u2112\", Lambda: \"\\u039B\", lambda: \"\\u03BB\", lang: \"\\u27E8\", Lang: \"\\u27EA\", langd: \"\\u2991\", langle: \"\\u27E8\", lap: \"\\u2A85\", Laplacetrf: \"\\u2112\", laquo: \"\\xAB\", larrb: \"\\u21E4\", larrbfs: \"\\u291F\", larr: \"\\u2190\", Larr: \"\\u219E\", lArr: \"\\u21D0\", larrfs: \"\\u291D\", larrhk: \"\\u21A9\", larrlp: \"\\u21AB\", larrpl: \"\\u2939\", larrsim: \"\\u2973\", larrtl: \"\\u21A2\", latail: \"\\u2919\", lAtail: \"\\u291B\", lat: \"\\u2AAB\", late: \"\\u2AAD\", lates: \"\\u2AAD\\uFE00\", lbarr: \"\\u290C\", lBarr: \"\\u290E\", lbbrk: \"\\u2772\", lbrace: \"{\", lbrack: \"[\", lbrke: \"\\u298B\", lbrksld: \"\\u298F\", lbrkslu: \"\\u298D\", Lcaron: \"\\u013D\", lcaron: \"\\u013E\", Lcedil: \"\\u013B\", lcedil: \"\\u013C\", lceil: \"\\u2308\", lcub: \"{\", Lcy: \"\\u041B\", lcy: \"\\u043B\", ldca: \"\\u2936\", ldquo: \"\\u201C\", ldquor: \"\\u201E\", ldrdhar: \"\\u2967\", ldrushar: \"\\u294B\", ldsh: \"\\u21B2\", le: \"\\u2264\", lE: \"\\u2266\", LeftAngleBracket: \"\\u27E8\", LeftArrowBar: \"\\u21E4\", leftarrow: \"\\u2190\", LeftArrow: \"\\u2190\", Leftarrow: \"\\u21D0\", LeftArrowRightArrow: \"\\u21C6\", leftarrowtail: \"\\u21A2\", LeftCeiling: \"\\u2308\", LeftDoubleBracket: \"\\u27E6\", LeftDownTeeVector: \"\\u2961\", LeftDownVectorBar: \"\\u2959\", LeftDownVector: \"\\u21C3\", LeftFloor: \"\\u230A\", leftharpoondown: \"\\u21BD\", leftharpoonup: \"\\u21BC\", leftleftarrows: \"\\u21C7\", leftrightarrow: \"\\u2194\", LeftRightArrow: \"\\u2194\", Leftrightarrow: \"\\u21D4\", leftrightarrows: \"\\u21C6\", leftrightharpoons: \"\\u21CB\", leftrightsquigarrow: \"\\u21AD\", LeftRightVector: \"\\u294E\", LeftTeeArrow: \"\\u21A4\", LeftTee: \"\\u22A3\", LeftTeeVector: \"\\u295A\", leftthreetimes: \"\\u22CB\", LeftTriangleBar: \"\\u29CF\", LeftTriangle: \"\\u22B2\", LeftTriangleEqual: \"\\u22B4\", LeftUpDownVector: \"\\u2951\", LeftUpTeeVector: \"\\u2960\", LeftUpVectorBar: \"\\u2958\", LeftUpVector: \"\\u21BF\", LeftVectorBar: \"\\u2952\", LeftVector: \"\\u21BC\", lEg: \"\\u2A8B\", leg: \"\\u22DA\", leq: \"\\u2264\", leqq: \"\\u2266\", leqslant: \"\\u2A7D\", lescc: \"\\u2AA8\", les: \"\\u2A7D\", lesdot: \"\\u2A7F\", lesdoto: \"\\u2A81\", lesdotor: \"\\u2A83\", lesg: \"\\u22DA\\uFE00\", lesges: \"\\u2A93\", lessapprox: \"\\u2A85\", lessdot: \"\\u22D6\", lesseqgtr: \"\\u22DA\", lesseqqgtr: \"\\u2A8B\", LessEqualGreater: \"\\u22DA\", LessFullEqual: \"\\u2266\", LessGreater: \"\\u2276\", lessgtr: \"\\u2276\", LessLess: \"\\u2AA1\", lesssim: \"\\u2272\", LessSlantEqual: \"\\u2A7D\", LessTilde: \"\\u2272\", lfisht: \"\\u297C\", lfloor: \"\\u230A\", Lfr: \"\\u{1D50F}\", lfr: \"\\u{1D529}\", lg: \"\\u2276\", lgE: \"\\u2A91\", lHar: \"\\u2962\", lhard: \"\\u21BD\", lharu: \"\\u21BC\", lharul: \"\\u296A\", lhblk: \"\\u2584\", LJcy: \"\\u0409\", ljcy: \"\\u0459\", llarr: \"\\u21C7\", ll: \"\\u226A\", Ll: \"\\u22D8\", llcorner: \"\\u231E\", Lleftarrow: \"\\u21DA\", llhard: \"\\u296B\", lltri: \"\\u25FA\", Lmidot: \"\\u013F\", lmidot: \"\\u0140\", lmoustache: \"\\u23B0\", lmoust: \"\\u23B0\", lnap: \"\\u2A89\", lnapprox: \"\\u2A89\", lne: \"\\u2A87\", lnE: \"\\u2268\", lneq: \"\\u2A87\", lneqq: \"\\u2268\", lnsim: \"\\u22E6\", loang: \"\\u27EC\", loarr: \"\\u21FD\", lobrk: \"\\u27E6\", longleftarrow: \"\\u27F5\", LongLeftArrow: \"\\u27F5\", Longleftarrow: \"\\u27F8\", longleftrightarrow: \"\\u27F7\", LongLeftRightArrow: \"\\u27F7\", Longleftrightarrow: \"\\u27FA\", longmapsto: \"\\u27FC\", longrightarrow: \"\\u27F6\", LongRightArrow: \"\\u27F6\", Longrightarrow: \"\\u27F9\", looparrowleft: \"\\u21AB\", looparrowright: \"\\u21AC\", lopar: \"\\u2985\", Lopf: \"\\u{1D543}\", lopf: \"\\u{1D55D}\", loplus: \"\\u2A2D\", lotimes: \"\\u2A34\", lowast: \"\\u2217\", lowbar: \"_\", LowerLeftArrow: \"\\u2199\", LowerRightArrow: \"\\u2198\", loz: \"\\u25CA\", lozenge: \"\\u25CA\", lozf: \"\\u29EB\", lpar: \"(\", lparlt: \"\\u2993\", lrarr: \"\\u21C6\", lrcorner: \"\\u231F\", lrhar: \"\\u21CB\", lrhard: \"\\u296D\", lrm: \"\\u200E\", lrtri: \"\\u22BF\", lsaquo: \"\\u2039\", lscr: \"\\u{1D4C1}\", Lscr: \"\\u2112\", lsh: \"\\u21B0\", Lsh: \"\\u21B0\", lsim: \"\\u2272\", lsime: \"\\u2A8D\", lsimg: \"\\u2A8F\", lsqb: \"[\", lsquo: \"\\u2018\", lsquor: \"\\u201A\", Lstrok: \"\\u0141\", lstrok: \"\\u0142\", ltcc: \"\\u2AA6\", ltcir: \"\\u2A79\", lt: \"<\", LT: \"<\", Lt: \"\\u226A\", ltdot: \"\\u22D6\", lthree: \"\\u22CB\", ltimes: \"\\u22C9\", ltlarr: \"\\u2976\", ltquest: \"\\u2A7B\", ltri: \"\\u25C3\", ltrie: \"\\u22B4\", ltrif: \"\\u25C2\", ltrPar: \"\\u2996\", lurdshar: \"\\u294A\", luruhar: \"\\u2966\", lvertneqq: \"\\u2268\\uFE00\", lvnE: \"\\u2268\\uFE00\", macr: \"\\xAF\", male: \"\\u2642\", malt: \"\\u2720\", maltese: \"\\u2720\", Map: \"\\u2905\", map: \"\\u21A6\", mapsto: \"\\u21A6\", mapstodown: \"\\u21A7\", mapstoleft: \"\\u21A4\", mapstoup: \"\\u21A5\", marker: \"\\u25AE\", mcomma: \"\\u2A29\", Mcy: \"\\u041C\", mcy: \"\\u043C\", mdash: \"\\u2014\", mDDot: \"\\u223A\", measuredangle: \"\\u2221\", MediumSpace: \"\\u205F\", Mellintrf: \"\\u2133\", Mfr: \"\\u{1D510}\", mfr: \"\\u{1D52A}\", mho: \"\\u2127\", micro: \"\\xB5\", midast: \"*\", midcir: \"\\u2AF0\", mid: \"\\u2223\", middot: \"\\xB7\", minusb: \"\\u229F\", minus: \"\\u2212\", minusd: \"\\u2238\", minusdu: \"\\u2A2A\", MinusPlus: \"\\u2213\", mlcp: \"\\u2ADB\", mldr: \"\\u2026\", mnplus: \"\\u2213\", models: \"\\u22A7\", Mopf: \"\\u{1D544}\", mopf: \"\\u{1D55E}\", mp: \"\\u2213\", mscr: \"\\u{1D4C2}\", Mscr: \"\\u2133\", mstpos: \"\\u223E\", Mu: \"\\u039C\", mu: \"\\u03BC\", multimap: \"\\u22B8\", mumap: \"\\u22B8\", nabla: \"\\u2207\", Nacute: \"\\u0143\", nacute: \"\\u0144\", nang: \"\\u2220\\u20D2\", nap: \"\\u2249\", napE: \"\\u2A70\\u0338\", napid: \"\\u224B\\u0338\", napos: \"\\u0149\", napprox: \"\\u2249\", natural: \"\\u266E\", naturals: \"\\u2115\", natur: \"\\u266E\", nbsp: \"\\xA0\", nbump: \"\\u224E\\u0338\", nbumpe: \"\\u224F\\u0338\", ncap: \"\\u2A43\", Ncaron: \"\\u0147\", ncaron: \"\\u0148\", Ncedil: \"\\u0145\", ncedil: \"\\u0146\", ncong: \"\\u2247\", ncongdot: \"\\u2A6D\\u0338\", ncup: \"\\u2A42\", Ncy: \"\\u041D\", ncy: \"\\u043D\", ndash: \"\\u2013\", nearhk: \"\\u2924\", nearr: \"\\u2197\", neArr: \"\\u21D7\", nearrow: \"\\u2197\", ne: \"\\u2260\", nedot: \"\\u2250\\u0338\", NegativeMediumSpace: \"\\u200B\", NegativeThickSpace: \"\\u200B\", NegativeThinSpace: \"\\u200B\", NegativeVeryThinSpace: \"\\u200B\", nequiv: \"\\u2262\", nesear: \"\\u2928\", nesim: \"\\u2242\\u0338\", NestedGreaterGreater: \"\\u226B\", NestedLessLess: \"\\u226A\", NewLine: \"\\n\", nexist: \"\\u2204\", nexists: \"\\u2204\", Nfr: \"\\u{1D511}\", nfr: \"\\u{1D52B}\", ngE: \"\\u2267\\u0338\", nge: \"\\u2271\", ngeq: \"\\u2271\", ngeqq: \"\\u2267\\u0338\", ngeqslant: \"\\u2A7E\\u0338\", nges: \"\\u2A7E\\u0338\", nGg: \"\\u22D9\\u0338\", ngsim: \"\\u2275\", nGt: \"\\u226B\\u20D2\", ngt: \"\\u226F\", ngtr: \"\\u226F\", nGtv: \"\\u226B\\u0338\", nharr: \"\\u21AE\", nhArr: \"\\u21CE\", nhpar: \"\\u2AF2\", ni: \"\\u220B\", nis: \"\\u22FC\", nisd: \"\\u22FA\", niv: \"\\u220B\", NJcy: \"\\u040A\", njcy: \"\\u045A\", nlarr: \"\\u219A\", nlArr: \"\\u21CD\", nldr: \"\\u2025\", nlE: \"\\u2266\\u0338\", nle: \"\\u2270\", nleftarrow: \"\\u219A\", nLeftarrow: \"\\u21CD\", nleftrightarrow: \"\\u21AE\", nLeftrightarrow: \"\\u21CE\", nleq: \"\\u2270\", nleqq: \"\\u2266\\u0338\", nleqslant: \"\\u2A7D\\u0338\", nles: \"\\u2A7D\\u0338\", nless: \"\\u226E\", nLl: \"\\u22D8\\u0338\", nlsim: \"\\u2274\", nLt: \"\\u226A\\u20D2\", nlt: \"\\u226E\", nltri: \"\\u22EA\", nltrie: \"\\u22EC\", nLtv: \"\\u226A\\u0338\", nmid: \"\\u2224\", NoBreak: \"\\u2060\", NonBreakingSpace: \"\\xA0\", nopf: \"\\u{1D55F}\", Nopf: \"\\u2115\", Not: \"\\u2AEC\", not: \"\\xAC\", NotCongruent: \"\\u2262\", NotCupCap: \"\\u226D\", NotDoubleVerticalBar: \"\\u2226\", NotElement: \"\\u2209\", NotEqual: \"\\u2260\", NotEqualTilde: \"\\u2242\\u0338\", NotExists: \"\\u2204\", NotGreater: \"\\u226F\", NotGreaterEqual: \"\\u2271\", NotGreaterFullEqual: \"\\u2267\\u0338\", NotGreaterGreater: \"\\u226B\\u0338\", NotGreaterLess: \"\\u2279\", NotGreaterSlantEqual: \"\\u2A7E\\u0338\", NotGreaterTilde: \"\\u2275\", NotHumpDownHump: \"\\u224E\\u0338\", NotHumpEqual: \"\\u224F\\u0338\", notin: \"\\u2209\", notindot: \"\\u22F5\\u0338\", notinE: \"\\u22F9\\u0338\", notinva: \"\\u2209\", notinvb: \"\\u22F7\", notinvc: \"\\u22F6\", NotLeftTriangleBar: \"\\u29CF\\u0338\", NotLeftTriangle: \"\\u22EA\", NotLeftTriangleEqual: \"\\u22EC\", NotLess: \"\\u226E\", NotLessEqual: \"\\u2270\", NotLessGreater: \"\\u2278\", NotLessLess: \"\\u226A\\u0338\", NotLessSlantEqual: \"\\u2A7D\\u0338\", NotLessTilde: \"\\u2274\", NotNestedGreaterGreater: \"\\u2AA2\\u0338\", NotNestedLessLess: \"\\u2AA1\\u0338\", notni: \"\\u220C\", notniva: \"\\u220C\", notnivb: \"\\u22FE\", notnivc: \"\\u22FD\", NotPrecedes: \"\\u2280\", NotPrecedesEqual: \"\\u2AAF\\u0338\", NotPrecedesSlantEqual: \"\\u22E0\", NotReverseElement: \"\\u220C\", NotRightTriangleBar: \"\\u29D0\\u0338\", NotRightTriangle: \"\\u22EB\", NotRightTriangleEqual: \"\\u22ED\", NotSquareSubset: \"\\u228F\\u0338\", NotSquareSubsetEqual: \"\\u22E2\", NotSquareSuperset: \"\\u2290\\u0338\", NotSquareSupersetEqual: \"\\u22E3\", NotSubset: \"\\u2282\\u20D2\", NotSubsetEqual: \"\\u2288\", NotSucceeds: \"\\u2281\", NotSucceedsEqual: \"\\u2AB0\\u0338\", NotSucceedsSlantEqual: \"\\u22E1\", NotSucceedsTilde: \"\\u227F\\u0338\", NotSuperset: \"\\u2283\\u20D2\", NotSupersetEqual: \"\\u2289\", NotTilde: \"\\u2241\", NotTildeEqual: \"\\u2244\", NotTildeFullEqual: \"\\u2247\", NotTildeTilde: \"\\u2249\", NotVerticalBar: \"\\u2224\", nparallel: \"\\u2226\", npar: \"\\u2226\", nparsl: \"\\u2AFD\\u20E5\", npart: \"\\u2202\\u0338\", npolint: \"\\u2A14\", npr: \"\\u2280\", nprcue: \"\\u22E0\", nprec: \"\\u2280\", npreceq: \"\\u2AAF\\u0338\", npre: \"\\u2AAF\\u0338\", nrarrc: \"\\u2933\\u0338\", nrarr: \"\\u219B\", nrArr: \"\\u21CF\", nrarrw: \"\\u219D\\u0338\", nrightarrow: \"\\u219B\", nRightarrow: \"\\u21CF\", nrtri: \"\\u22EB\", nrtrie: \"\\u22ED\", nsc: \"\\u2281\", nsccue: \"\\u22E1\", nsce: \"\\u2AB0\\u0338\", Nscr: \"\\u{1D4A9}\", nscr: \"\\u{1D4C3}\", nshortmid: \"\\u2224\", nshortparallel: \"\\u2226\", nsim: \"\\u2241\", nsime: \"\\u2244\", nsimeq: \"\\u2244\", nsmid: \"\\u2224\", nspar: \"\\u2226\", nsqsube: \"\\u22E2\", nsqsupe: \"\\u22E3\", nsub: \"\\u2284\", nsubE: \"\\u2AC5\\u0338\", nsube: \"\\u2288\", nsubset: \"\\u2282\\u20D2\", nsubseteq: \"\\u2288\", nsubseteqq: \"\\u2AC5\\u0338\", nsucc: \"\\u2281\", nsucceq: \"\\u2AB0\\u0338\", nsup: \"\\u2285\", nsupE: \"\\u2AC6\\u0338\", nsupe: \"\\u2289\", nsupset: \"\\u2283\\u20D2\", nsupseteq: \"\\u2289\", nsupseteqq: \"\\u2AC6\\u0338\", ntgl: \"\\u2279\", Ntilde: \"\\xD1\", ntilde: \"\\xF1\", ntlg: \"\\u2278\", ntriangleleft: \"\\u22EA\", ntrianglelefteq: \"\\u22EC\", ntriangleright: \"\\u22EB\", ntrianglerighteq: \"\\u22ED\", Nu: \"\\u039D\", nu: \"\\u03BD\", num: \"#\", numero: \"\\u2116\", numsp: \"\\u2007\", nvap: \"\\u224D\\u20D2\", nvdash: \"\\u22AC\", nvDash: \"\\u22AD\", nVdash: \"\\u22AE\", nVDash: \"\\u22AF\", nvge: \"\\u2265\\u20D2\", nvgt: \">\\u20D2\", nvHarr: \"\\u2904\", nvinfin: \"\\u29DE\", nvlArr: \"\\u2902\", nvle: \"\\u2264\\u20D2\", nvlt: \"<\\u20D2\", nvltrie: \"\\u22B4\\u20D2\", nvrArr: \"\\u2903\", nvrtrie: \"\\u22B5\\u20D2\", nvsim: \"\\u223C\\u20D2\", nwarhk: \"\\u2923\", nwarr: \"\\u2196\", nwArr: \"\\u21D6\", nwarrow: \"\\u2196\", nwnear: \"\\u2927\", Oacute: \"\\xD3\", oacute: \"\\xF3\", oast: \"\\u229B\", Ocirc: \"\\xD4\", ocirc: \"\\xF4\", ocir: \"\\u229A\", Ocy: \"\\u041E\", ocy: \"\\u043E\", odash: \"\\u229D\", Odblac: \"\\u0150\", odblac: \"\\u0151\", odiv: \"\\u2A38\", odot: \"\\u2299\", odsold: \"\\u29BC\", OElig: \"\\u0152\", oelig: \"\\u0153\", ofcir: \"\\u29BF\", Ofr: \"\\u{1D512}\", ofr: \"\\u{1D52C}\", ogon: \"\\u02DB\", Ograve: \"\\xD2\", ograve: \"\\xF2\", ogt: \"\\u29C1\", ohbar: \"\\u29B5\", ohm: \"\\u03A9\", oint: \"\\u222E\", olarr: \"\\u21BA\", olcir: \"\\u29BE\", olcross: \"\\u29BB\", oline: \"\\u203E\", olt: \"\\u29C0\", Omacr: \"\\u014C\", omacr: \"\\u014D\", Omega: \"\\u03A9\", omega: \"\\u03C9\", Omicron: \"\\u039F\", omicron: \"\\u03BF\", omid: \"\\u29B6\", ominus: \"\\u2296\", Oopf: \"\\u{1D546}\", oopf: \"\\u{1D560}\", opar: \"\\u29B7\", OpenCurlyDoubleQuote: \"\\u201C\", OpenCurlyQuote: \"\\u2018\", operp: \"\\u29B9\", oplus: \"\\u2295\", orarr: \"\\u21BB\", Or: \"\\u2A54\", or: \"\\u2228\", ord: \"\\u2A5D\", order: \"\\u2134\", orderof: \"\\u2134\", ordf: \"\\xAA\", ordm: \"\\xBA\", origof: \"\\u22B6\", oror: \"\\u2A56\", orslope: \"\\u2A57\", orv: \"\\u2A5B\", oS: \"\\u24C8\", Oscr: \"\\u{1D4AA}\", oscr: \"\\u2134\", Oslash: \"\\xD8\", oslash: \"\\xF8\", osol: \"\\u2298\", Otilde: \"\\xD5\", otilde: \"\\xF5\", otimesas: \"\\u2A36\", Otimes: \"\\u2A37\", otimes: \"\\u2297\", Ouml: \"\\xD6\", ouml: \"\\xF6\", ovbar: \"\\u233D\", OverBar: \"\\u203E\", OverBrace: \"\\u23DE\", OverBracket: \"\\u23B4\", OverParenthesis: \"\\u23DC\", para: \"\\xB6\", parallel: \"\\u2225\", par: \"\\u2225\", parsim: \"\\u2AF3\", parsl: \"\\u2AFD\", part: \"\\u2202\", PartialD: \"\\u2202\", Pcy: \"\\u041F\", pcy: \"\\u043F\", percnt: \"%\", period: \".\", permil: \"\\u2030\", perp: \"\\u22A5\", pertenk: \"\\u2031\", Pfr: \"\\u{1D513}\", pfr: \"\\u{1D52D}\", Phi: \"\\u03A6\", phi: \"\\u03C6\", phiv: \"\\u03D5\", phmmat: \"\\u2133\", phone: \"\\u260E\", Pi: \"\\u03A0\", pi: \"\\u03C0\", pitchfork: \"\\u22D4\", piv: \"\\u03D6\", planck: \"\\u210F\", planckh: \"\\u210E\", plankv: \"\\u210F\", plusacir: \"\\u2A23\", plusb: \"\\u229E\", pluscir: \"\\u2A22\", plus: \"+\", plusdo: \"\\u2214\", plusdu: \"\\u2A25\", pluse: \"\\u2A72\", PlusMinus: \"\\xB1\", plusmn: \"\\xB1\", plussim: \"\\u2A26\", plustwo: \"\\u2A27\", pm: \"\\xB1\", Poincareplane: \"\\u210C\", pointint: \"\\u2A15\", popf: \"\\u{1D561}\", Popf: \"\\u2119\", pound: \"\\xA3\", prap: \"\\u2AB7\", Pr: \"\\u2ABB\", pr: \"\\u227A\", prcue: \"\\u227C\", precapprox: \"\\u2AB7\", prec: \"\\u227A\", preccurlyeq: \"\\u227C\", Precedes: \"\\u227A\", PrecedesEqual: \"\\u2AAF\", PrecedesSlantEqual: \"\\u227C\", PrecedesTilde: \"\\u227E\", preceq: \"\\u2AAF\", precnapprox: \"\\u2AB9\", precneqq: \"\\u2AB5\", precnsim: \"\\u22E8\", pre: \"\\u2AAF\", prE: \"\\u2AB3\", precsim: \"\\u227E\", prime: \"\\u2032\", Prime: \"\\u2033\", primes: \"\\u2119\", prnap: \"\\u2AB9\", prnE: \"\\u2AB5\", prnsim: \"\\u22E8\", prod: \"\\u220F\", Product: \"\\u220F\", profalar: \"\\u232E\", profline: \"\\u2312\", profsurf: \"\\u2313\", prop: \"\\u221D\", Proportional: \"\\u221D\", Proportion: \"\\u2237\", propto: \"\\u221D\", prsim: \"\\u227E\", prurel: \"\\u22B0\", Pscr: \"\\u{1D4AB}\", pscr: \"\\u{1D4C5}\", Psi: \"\\u03A8\", psi: \"\\u03C8\", puncsp: \"\\u2008\", Qfr: \"\\u{1D514}\", qfr: \"\\u{1D52E}\", qint: \"\\u2A0C\", qopf: \"\\u{1D562}\", Qopf: \"\\u211A\", qprime: \"\\u2057\", Qscr: \"\\u{1D4AC}\", qscr: \"\\u{1D4C6}\", quaternions: \"\\u210D\", quatint: \"\\u2A16\", quest: \"?\", questeq: \"\\u225F\", quot: '\"', QUOT: '\"', rAarr: \"\\u21DB\", race: \"\\u223D\\u0331\", Racute: \"\\u0154\", racute: \"\\u0155\", radic: \"\\u221A\", raemptyv: \"\\u29B3\", rang: \"\\u27E9\", Rang: \"\\u27EB\", rangd: \"\\u2992\", range: \"\\u29A5\", rangle: \"\\u27E9\", raquo: \"\\xBB\", rarrap: \"\\u2975\", rarrb: \"\\u21E5\", rarrbfs: \"\\u2920\", rarrc: \"\\u2933\", rarr: \"\\u2192\", Rarr: \"\\u21A0\", rArr: \"\\u21D2\", rarrfs: \"\\u291E\", rarrhk: \"\\u21AA\", rarrlp: \"\\u21AC\", rarrpl: \"\\u2945\", rarrsim: \"\\u2974\", Rarrtl: \"\\u2916\", rarrtl: \"\\u21A3\", rarrw: \"\\u219D\", ratail: \"\\u291A\", rAtail: \"\\u291C\", ratio: \"\\u2236\", rationals: \"\\u211A\", rbarr: \"\\u290D\", rBarr: \"\\u290F\", RBarr: \"\\u2910\", rbbrk: \"\\u2773\", rbrace: \"}\", rbrack: \"]\", rbrke: \"\\u298C\", rbrksld: \"\\u298E\", rbrkslu: \"\\u2990\", Rcaron: \"\\u0158\", rcaron: \"\\u0159\", Rcedil: \"\\u0156\", rcedil: \"\\u0157\", rceil: \"\\u2309\", rcub: \"}\", Rcy: \"\\u0420\", rcy: \"\\u0440\", rdca: \"\\u2937\", rdldhar: \"\\u2969\", rdquo: \"\\u201D\", rdquor: \"\\u201D\", rdsh: \"\\u21B3\", real: \"\\u211C\", realine: \"\\u211B\", realpart: \"\\u211C\", reals: \"\\u211D\", Re: \"\\u211C\", rect: \"\\u25AD\", reg: \"\\xAE\", REG: \"\\xAE\", ReverseElement: \"\\u220B\", ReverseEquilibrium: \"\\u21CB\", ReverseUpEquilibrium: \"\\u296F\", rfisht: \"\\u297D\", rfloor: \"\\u230B\", rfr: \"\\u{1D52F}\", Rfr: \"\\u211C\", rHar: \"\\u2964\", rhard: \"\\u21C1\", rharu: \"\\u21C0\", rharul: \"\\u296C\", Rho: \"\\u03A1\", rho: \"\\u03C1\", rhov: \"\\u03F1\", RightAngleBracket: \"\\u27E9\", RightArrowBar: \"\\u21E5\", rightarrow: \"\\u2192\", RightArrow: \"\\u2192\", Rightarrow: \"\\u21D2\", RightArrowLeftArrow: \"\\u21C4\", rightarrowtail: \"\\u21A3\", RightCeiling: \"\\u2309\", RightDoubleBracket: \"\\u27E7\", RightDownTeeVector: \"\\u295D\", RightDownVectorBar: \"\\u2955\", RightDownVector: \"\\u21C2\", RightFloor: \"\\u230B\", rightharpoondown: \"\\u21C1\", rightharpoonup: \"\\u21C0\", rightleftarrows: \"\\u21C4\", rightleftharpoons: \"\\u21CC\", rightrightarrows: \"\\u21C9\", rightsquigarrow: \"\\u219D\", RightTeeArrow: \"\\u21A6\", RightTee: \"\\u22A2\", RightTeeVector: \"\\u295B\", rightthreetimes: \"\\u22CC\", RightTriangleBar: \"\\u29D0\", RightTriangle: \"\\u22B3\", RightTriangleEqual: \"\\u22B5\", RightUpDownVector: \"\\u294F\", RightUpTeeVector: \"\\u295C\", RightUpVectorBar: \"\\u2954\", RightUpVector: \"\\u21BE\", RightVectorBar: \"\\u2953\", RightVector: \"\\u21C0\", ring: \"\\u02DA\", risingdotseq: \"\\u2253\", rlarr: \"\\u21C4\", rlhar: \"\\u21CC\", rlm: \"\\u200F\", rmoustache: \"\\u23B1\", rmoust: \"\\u23B1\", rnmid: \"\\u2AEE\", roang: \"\\u27ED\", roarr: \"\\u21FE\", robrk: \"\\u27E7\", ropar: \"\\u2986\", ropf: \"\\u{1D563}\", Ropf: \"\\u211D\", roplus: \"\\u2A2E\", rotimes: \"\\u2A35\", RoundImplies: \"\\u2970\", rpar: \")\", rpargt: \"\\u2994\", rppolint: \"\\u2A12\", rrarr: \"\\u21C9\", Rrightarrow: \"\\u21DB\", rsaquo: \"\\u203A\", rscr: \"\\u{1D4C7}\", Rscr: \"\\u211B\", rsh: \"\\u21B1\", Rsh: \"\\u21B1\", rsqb: \"]\", rsquo: \"\\u2019\", rsquor: \"\\u2019\", rthree: \"\\u22CC\", rtimes: \"\\u22CA\", rtri: \"\\u25B9\", rtrie: \"\\u22B5\", rtrif: \"\\u25B8\", rtriltri: \"\\u29CE\", RuleDelayed: \"\\u29F4\", ruluhar: \"\\u2968\", rx: \"\\u211E\", Sacute: \"\\u015A\", sacute: \"\\u015B\", sbquo: \"\\u201A\", scap: \"\\u2AB8\", Scaron: \"\\u0160\", scaron: \"\\u0161\", Sc: \"\\u2ABC\", sc: \"\\u227B\", sccue: \"\\u227D\", sce: \"\\u2AB0\", scE: \"\\u2AB4\", Scedil: \"\\u015E\", scedil: \"\\u015F\", Scirc: \"\\u015C\", scirc: \"\\u015D\", scnap: \"\\u2ABA\", scnE: \"\\u2AB6\", scnsim: \"\\u22E9\", scpolint: \"\\u2A13\", scsim: \"\\u227F\", Scy: \"\\u0421\", scy: \"\\u0441\", sdotb: \"\\u22A1\", sdot: \"\\u22C5\", sdote: \"\\u2A66\", searhk: \"\\u2925\", searr: \"\\u2198\", seArr: \"\\u21D8\", searrow: \"\\u2198\", sect: \"\\xA7\", semi: \";\", seswar: \"\\u2929\", setminus: \"\\u2216\", setmn: \"\\u2216\", sext: \"\\u2736\", Sfr: \"\\u{1D516}\", sfr: \"\\u{1D530}\", sfrown: \"\\u2322\", sharp: \"\\u266F\", SHCHcy: \"\\u0429\", shchcy: \"\\u0449\", SHcy: \"\\u0428\", shcy: \"\\u0448\", ShortDownArrow: \"\\u2193\", ShortLeftArrow: \"\\u2190\", shortmid: \"\\u2223\", shortparallel: \"\\u2225\", ShortRightArrow: \"\\u2192\", ShortUpArrow: \"\\u2191\", shy: \"\\xAD\", Sigma: \"\\u03A3\", sigma: \"\\u03C3\", sigmaf: \"\\u03C2\", sigmav: \"\\u03C2\", sim: \"\\u223C\", simdot: \"\\u2A6A\", sime: \"\\u2243\", simeq: \"\\u2243\", simg: \"\\u2A9E\", simgE: \"\\u2AA0\", siml: \"\\u2A9D\", simlE: \"\\u2A9F\", simne: \"\\u2246\", simplus: \"\\u2A24\", simrarr: \"\\u2972\", slarr: \"\\u2190\", SmallCircle: \"\\u2218\", smallsetminus: \"\\u2216\", smashp: \"\\u2A33\", smeparsl: \"\\u29E4\", smid: \"\\u2223\", smile: \"\\u2323\", smt: \"\\u2AAA\", smte: \"\\u2AAC\", smtes: \"\\u2AAC\\uFE00\", SOFTcy: \"\\u042C\", softcy: \"\\u044C\", solbar: \"\\u233F\", solb: \"\\u29C4\", sol: \"/\", Sopf: \"\\u{1D54A}\", sopf: \"\\u{1D564}\", spades: \"\\u2660\", spadesuit: \"\\u2660\", spar: \"\\u2225\", sqcap: \"\\u2293\", sqcaps: \"\\u2293\\uFE00\", sqcup: \"\\u2294\", sqcups: \"\\u2294\\uFE00\", Sqrt: \"\\u221A\", sqsub: \"\\u228F\", sqsube: \"\\u2291\", sqsubset: \"\\u228F\", sqsubseteq: \"\\u2291\", sqsup: \"\\u2290\", sqsupe: \"\\u2292\", sqsupset: \"\\u2290\", sqsupseteq: \"\\u2292\", square: \"\\u25A1\", Square: \"\\u25A1\", SquareIntersection: \"\\u2293\", SquareSubset: \"\\u228F\", SquareSubsetEqual: \"\\u2291\", SquareSuperset: \"\\u2290\", SquareSupersetEqual: \"\\u2292\", SquareUnion: \"\\u2294\", squarf: \"\\u25AA\", squ: \"\\u25A1\", squf: \"\\u25AA\", srarr: \"\\u2192\", Sscr: \"\\u{1D4AE}\", sscr: \"\\u{1D4C8}\", ssetmn: \"\\u2216\", ssmile: \"\\u2323\", sstarf: \"\\u22C6\", Star: \"\\u22C6\", star: \"\\u2606\", starf: \"\\u2605\", straightepsilon: \"\\u03F5\", straightphi: \"\\u03D5\", strns: \"\\xAF\", sub: \"\\u2282\", Sub: \"\\u22D0\", subdot: \"\\u2ABD\", subE: \"\\u2AC5\", sube: \"\\u2286\", subedot: \"\\u2AC3\", submult: \"\\u2AC1\", subnE: \"\\u2ACB\", subne: \"\\u228A\", subplus: \"\\u2ABF\", subrarr: \"\\u2979\", subset: \"\\u2282\", Subset: \"\\u22D0\", subseteq: \"\\u2286\", subseteqq: \"\\u2AC5\", SubsetEqual: \"\\u2286\", subsetneq: \"\\u228A\", subsetneqq: \"\\u2ACB\", subsim: \"\\u2AC7\", subsub: \"\\u2AD5\", subsup: \"\\u2AD3\", succapprox: \"\\u2AB8\", succ: \"\\u227B\", succcurlyeq: \"\\u227D\", Succeeds: \"\\u227B\", SucceedsEqual: \"\\u2AB0\", SucceedsSlantEqual: \"\\u227D\", SucceedsTilde: \"\\u227F\", succeq: \"\\u2AB0\", succnapprox: \"\\u2ABA\", succneqq: \"\\u2AB6\", succnsim: \"\\u22E9\", succsim: \"\\u227F\", SuchThat: \"\\u220B\", sum: \"\\u2211\", Sum: \"\\u2211\", sung: \"\\u266A\", sup1: \"\\xB9\", sup2: \"\\xB2\", sup3: \"\\xB3\", sup: \"\\u2283\", Sup: \"\\u22D1\", supdot: \"\\u2ABE\", supdsub: \"\\u2AD8\", supE: \"\\u2AC6\", supe: \"\\u2287\", supedot: \"\\u2AC4\", Superset: \"\\u2283\", SupersetEqual: \"\\u2287\", suphsol: \"\\u27C9\", suphsub: \"\\u2AD7\", suplarr: \"\\u297B\", supmult: \"\\u2AC2\", supnE: \"\\u2ACC\", supne: \"\\u228B\", supplus: \"\\u2AC0\", supset: \"\\u2283\", Supset: \"\\u22D1\", supseteq: \"\\u2287\", supseteqq: \"\\u2AC6\", supsetneq: \"\\u228B\", supsetneqq: \"\\u2ACC\", supsim: \"\\u2AC8\", supsub: \"\\u2AD4\", supsup: \"\\u2AD6\", swarhk: \"\\u2926\", swarr: \"\\u2199\", swArr: \"\\u21D9\", swarrow: \"\\u2199\", swnwar: \"\\u292A\", szlig: \"\\xDF\", Tab: \"\t\", target: \"\\u2316\", Tau: \"\\u03A4\", tau: \"\\u03C4\", tbrk: \"\\u23B4\", Tcaron: \"\\u0164\", tcaron: \"\\u0165\", Tcedil: \"\\u0162\", tcedil: \"\\u0163\", Tcy: \"\\u0422\", tcy: \"\\u0442\", tdot: \"\\u20DB\", telrec: \"\\u2315\", Tfr: \"\\u{1D517}\", tfr: \"\\u{1D531}\", there4: \"\\u2234\", therefore: \"\\u2234\", Therefore: \"\\u2234\", Theta: \"\\u0398\", theta: \"\\u03B8\", thetasym: \"\\u03D1\", thetav: \"\\u03D1\", thickapprox: \"\\u2248\", thicksim: \"\\u223C\", ThickSpace: \"\\u205F\\u200A\", ThinSpace: \"\\u2009\", thinsp: \"\\u2009\", thkap: \"\\u2248\", thksim: \"\\u223C\", THORN: \"\\xDE\", thorn: \"\\xFE\", tilde: \"\\u02DC\", Tilde: \"\\u223C\", TildeEqual: \"\\u2243\", TildeFullEqual: \"\\u2245\", TildeTilde: \"\\u2248\", timesbar: \"\\u2A31\", timesb: \"\\u22A0\", times: \"\\xD7\", timesd: \"\\u2A30\", tint: \"\\u222D\", toea: \"\\u2928\", topbot: \"\\u2336\", topcir: \"\\u2AF1\", top: \"\\u22A4\", Topf: \"\\u{1D54B}\", topf: \"\\u{1D565}\", topfork: \"\\u2ADA\", tosa: \"\\u2929\", tprime: \"\\u2034\", trade: \"\\u2122\", TRADE: \"\\u2122\", triangle: \"\\u25B5\", triangledown: \"\\u25BF\", triangleleft: \"\\u25C3\", trianglelefteq: \"\\u22B4\", triangleq: \"\\u225C\", triangleright: \"\\u25B9\", trianglerighteq: \"\\u22B5\", tridot: \"\\u25EC\", trie: \"\\u225C\", triminus: \"\\u2A3A\", TripleDot: \"\\u20DB\", triplus: \"\\u2A39\", trisb: \"\\u29CD\", tritime: \"\\u2A3B\", trpezium: \"\\u23E2\", Tscr: \"\\u{1D4AF}\", tscr: \"\\u{1D4C9}\", TScy: \"\\u0426\", tscy: \"\\u0446\", TSHcy: \"\\u040B\", tshcy: \"\\u045B\", Tstrok: \"\\u0166\", tstrok: \"\\u0167\", twixt: \"\\u226C\", twoheadleftarrow: \"\\u219E\", twoheadrightarrow: \"\\u21A0\", Uacute: \"\\xDA\", uacute: \"\\xFA\", uarr: \"\\u2191\", Uarr: \"\\u219F\", uArr: \"\\u21D1\", Uarrocir: \"\\u2949\", Ubrcy: \"\\u040E\", ubrcy: \"\\u045E\", Ubreve: \"\\u016C\", ubreve: \"\\u016D\", Ucirc: \"\\xDB\", ucirc: \"\\xFB\", Ucy: \"\\u0423\", ucy: \"\\u0443\", udarr: \"\\u21C5\", Udblac: \"\\u0170\", udblac: \"\\u0171\", udhar: \"\\u296E\", ufisht: \"\\u297E\", Ufr: \"\\u{1D518}\", ufr: \"\\u{1D532}\", Ugrave: \"\\xD9\", ugrave: \"\\xF9\", uHar: \"\\u2963\", uharl: \"\\u21BF\", uharr: \"\\u21BE\", uhblk: \"\\u2580\", ulcorn: \"\\u231C\", ulcorner: \"\\u231C\", ulcrop: \"\\u230F\", ultri: \"\\u25F8\", Umacr: \"\\u016A\", umacr: \"\\u016B\", uml: \"\\xA8\", UnderBar: \"_\", UnderBrace: \"\\u23DF\", UnderBracket: \"\\u23B5\", UnderParenthesis: \"\\u23DD\", Union: \"\\u22C3\", UnionPlus: \"\\u228E\", Uogon: \"\\u0172\", uogon: \"\\u0173\", Uopf: \"\\u{1D54C}\", uopf: \"\\u{1D566}\", UpArrowBar: \"\\u2912\", uparrow: \"\\u2191\", UpArrow: \"\\u2191\", Uparrow: \"\\u21D1\", UpArrowDownArrow: \"\\u21C5\", updownarrow: \"\\u2195\", UpDownArrow: \"\\u2195\", Updownarrow: \"\\u21D5\", UpEquilibrium: \"\\u296E\", upharpoonleft: \"\\u21BF\", upharpoonright: \"\\u21BE\", uplus: \"\\u228E\", UpperLeftArrow: \"\\u2196\", UpperRightArrow: \"\\u2197\", upsi: \"\\u03C5\", Upsi: \"\\u03D2\", upsih: \"\\u03D2\", Upsilon: \"\\u03A5\", upsilon: \"\\u03C5\", UpTeeArrow: \"\\u21A5\", UpTee: \"\\u22A5\", upuparrows: \"\\u21C8\", urcorn: \"\\u231D\", urcorner: \"\\u231D\", urcrop: \"\\u230E\", Uring: \"\\u016E\", uring: \"\\u016F\", urtri: \"\\u25F9\", Uscr: \"\\u{1D4B0}\", uscr: \"\\u{1D4CA}\", utdot: \"\\u22F0\", Utilde: \"\\u0168\", utilde: \"\\u0169\", utri: \"\\u25B5\", utrif: \"\\u25B4\", uuarr: \"\\u21C8\", Uuml: \"\\xDC\", uuml: \"\\xFC\", uwangle: \"\\u29A7\", vangrt: \"\\u299C\", varepsilon: \"\\u03F5\", varkappa: \"\\u03F0\", varnothing: \"\\u2205\", varphi: \"\\u03D5\", varpi: \"\\u03D6\", varpropto: \"\\u221D\", varr: \"\\u2195\", vArr: \"\\u21D5\", varrho: \"\\u03F1\", varsigma: \"\\u03C2\", varsubsetneq: \"\\u228A\\uFE00\", varsubsetneqq: \"\\u2ACB\\uFE00\", varsupsetneq: \"\\u228B\\uFE00\", varsupsetneqq: \"\\u2ACC\\uFE00\", vartheta: \"\\u03D1\", vartriangleleft: \"\\u22B2\", vartriangleright: \"\\u22B3\", vBar: \"\\u2AE8\", Vbar: \"\\u2AEB\", vBarv: \"\\u2AE9\", Vcy: \"\\u0412\", vcy: \"\\u0432\", vdash: \"\\u22A2\", vDash: \"\\u22A8\", Vdash: \"\\u22A9\", VDash: \"\\u22AB\", Vdashl: \"\\u2AE6\", veebar: \"\\u22BB\", vee: \"\\u2228\", Vee: \"\\u22C1\", veeeq: \"\\u225A\", vellip: \"\\u22EE\", verbar: \"|\", Verbar: \"\\u2016\", vert: \"|\", Vert: \"\\u2016\", VerticalBar: \"\\u2223\", VerticalLine: \"|\", VerticalSeparator: \"\\u2758\", VerticalTilde: \"\\u2240\", VeryThinSpace: \"\\u200A\", Vfr: \"\\u{1D519}\", vfr: \"\\u{1D533}\", vltri: \"\\u22B2\", vnsub: \"\\u2282\\u20D2\", vnsup: \"\\u2283\\u20D2\", Vopf: \"\\u{1D54D}\", vopf: \"\\u{1D567}\", vprop: \"\\u221D\", vrtri: \"\\u22B3\", Vscr: \"\\u{1D4B1}\", vscr: \"\\u{1D4CB}\", vsubnE: \"\\u2ACB\\uFE00\", vsubne: \"\\u228A\\uFE00\", vsupnE: \"\\u2ACC\\uFE00\", vsupne: \"\\u228B\\uFE00\", Vvdash: \"\\u22AA\", vzigzag: \"\\u299A\", Wcirc: \"\\u0174\", wcirc: \"\\u0175\", wedbar: \"\\u2A5F\", wedge: \"\\u2227\", Wedge: \"\\u22C0\", wedgeq: \"\\u2259\", weierp: \"\\u2118\", Wfr: \"\\u{1D51A}\", wfr: \"\\u{1D534}\", Wopf: \"\\u{1D54E}\", wopf: \"\\u{1D568}\", wp: \"\\u2118\", wr: \"\\u2240\", wreath: \"\\u2240\", Wscr: \"\\u{1D4B2}\", wscr: \"\\u{1D4CC}\", xcap: \"\\u22C2\", xcirc: \"\\u25EF\", xcup: \"\\u22C3\", xdtri: \"\\u25BD\", Xfr: \"\\u{1D51B}\", xfr: \"\\u{1D535}\", xharr: \"\\u27F7\", xhArr: \"\\u27FA\", Xi: \"\\u039E\", xi: \"\\u03BE\", xlarr: \"\\u27F5\", xlArr: \"\\u27F8\", xmap: \"\\u27FC\", xnis: \"\\u22FB\", xodot: \"\\u2A00\", Xopf: \"\\u{1D54F}\", xopf: \"\\u{1D569}\", xoplus: \"\\u2A01\", xotime: \"\\u2A02\", xrarr: \"\\u27F6\", xrArr: \"\\u27F9\", Xscr: \"\\u{1D4B3}\", xscr: \"\\u{1D4CD}\", xsqcup: \"\\u2A06\", xuplus: \"\\u2A04\", xutri: \"\\u25B3\", xvee: \"\\u22C1\", xwedge: \"\\u22C0\", Yacute: \"\\xDD\", yacute: \"\\xFD\", YAcy: \"\\u042F\", yacy: \"\\u044F\", Ycirc: \"\\u0176\", ycirc: \"\\u0177\", Ycy: \"\\u042B\", ycy: \"\\u044B\", yen: \"\\xA5\", Yfr: \"\\u{1D51C}\", yfr: \"\\u{1D536}\", YIcy: \"\\u0407\", yicy: \"\\u0457\", Yopf: \"\\u{1D550}\", yopf: \"\\u{1D56A}\", Yscr: \"\\u{1D4B4}\", yscr: \"\\u{1D4CE}\", YUcy: \"\\u042E\", yucy: \"\\u044E\", yuml: \"\\xFF\", Yuml: \"\\u0178\", Zacute: \"\\u0179\", zacute: \"\\u017A\", Zcaron: \"\\u017D\", zcaron: \"\\u017E\", Zcy: \"\\u0417\", zcy: \"\\u0437\", Zdot: \"\\u017B\", zdot: \"\\u017C\", zeetrf: \"\\u2128\", ZeroWidthSpace: \"\\u200B\", Zeta: \"\\u0396\", zeta: \"\\u03B6\", zfr: \"\\u{1D537}\", Zfr: \"\\u2128\", ZHcy: \"\\u0416\", zhcy: \"\\u0436\", zigrarr: \"\\u21DD\", zopf: \"\\u{1D56B}\", Zopf: \"\\u2124\", Zscr: \"\\u{1D4B5}\", zscr: \"\\u{1D4CF}\", zwj: \"\\u200D\", zwnj: \"\\u200C\" };\n  }\n});\n\n// node_modules/markdown-it/lib/common/entities.js\nvar require_entities2 = __commonJS({\n  \"node_modules/markdown-it/lib/common/entities.js\"(exports, module) {\n    \"use strict\";\n    module.exports = require_entities();\n  }\n});\n\n// node_modules/uc.micro/categories/P/regex.js\nvar require_regex = __commonJS({\n  \"node_modules/uc.micro/categories/P/regex.js\"(exports, module) {\n    module.exports = /[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4E\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDF55-\\uDF59]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/;\n  }\n});\n\n// node_modules/mdurl/encode.js\nvar require_encode = __commonJS({\n  \"node_modules/mdurl/encode.js\"(exports, module) {\n    \"use strict\";\n    var encodeCache = {};\n    function getEncodeCache(exclude) {\n      var i, ch, cache = encodeCache[exclude];\n      if (cache) {\n        return cache;\n      }\n      cache = encodeCache[exclude] = [];\n      for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        if (/^[0-9a-z]$/i.test(ch)) {\n          cache.push(ch);\n        } else {\n          cache.push(\"%\" + (\"0\" + i.toString(16).toUpperCase()).slice(-2));\n        }\n      }\n      for (i = 0; i < exclude.length; i++) {\n        cache[exclude.charCodeAt(i)] = exclude[i];\n      }\n      return cache;\n    }\n    function encode(string, exclude, keepEscaped) {\n      var i, l, code2, nextCode, cache, result = \"\";\n      if (typeof exclude !== \"string\") {\n        keepEscaped = exclude;\n        exclude = encode.defaultChars;\n      }\n      if (typeof keepEscaped === \"undefined\") {\n        keepEscaped = true;\n      }\n      cache = getEncodeCache(exclude);\n      for (i = 0, l = string.length; i < l; i++) {\n        code2 = string.charCodeAt(i);\n        if (keepEscaped && code2 === 37 && i + 2 < l) {\n          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n            result += string.slice(i, i + 3);\n            i += 2;\n            continue;\n          }\n        }\n        if (code2 < 128) {\n          result += cache[code2];\n          continue;\n        }\n        if (code2 >= 55296 && code2 <= 57343) {\n          if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {\n            nextCode = string.charCodeAt(i + 1);\n            if (nextCode >= 56320 && nextCode <= 57343) {\n              result += encodeURIComponent(string[i] + string[i + 1]);\n              i++;\n              continue;\n            }\n          }\n          result += \"%EF%BF%BD\";\n          continue;\n        }\n        result += encodeURIComponent(string[i]);\n      }\n      return result;\n    }\n    encode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\n    encode.componentChars = \"-_.!~*'()\";\n    module.exports = encode;\n  }\n});\n\n// node_modules/mdurl/decode.js\nvar require_decode = __commonJS({\n  \"node_modules/mdurl/decode.js\"(exports, module) {\n    \"use strict\";\n    var decodeCache = {};\n    function getDecodeCache(exclude) {\n      var i, ch, cache = decodeCache[exclude];\n      if (cache) {\n        return cache;\n      }\n      cache = decodeCache[exclude] = [];\n      for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        cache.push(ch);\n      }\n      for (i = 0; i < exclude.length; i++) {\n        ch = exclude.charCodeAt(i);\n        cache[ch] = \"%\" + (\"0\" + ch.toString(16).toUpperCase()).slice(-2);\n      }\n      return cache;\n    }\n    function decode(string, exclude) {\n      var cache;\n      if (typeof exclude !== \"string\") {\n        exclude = decode.defaultChars;\n      }\n      cache = getDecodeCache(exclude);\n      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n        var i, l, b1, b2, b3, b4, chr, result = \"\";\n        for (i = 0, l = seq.length; i < l; i += 3) {\n          b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n          if (b1 < 128) {\n            result += cache[b1];\n            continue;\n          }\n          if ((b1 & 224) === 192 && i + 3 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            if ((b2 & 192) === 128) {\n              chr = b1 << 6 & 1984 | b2 & 63;\n              if (chr < 128) {\n                result += \"\\uFFFD\\uFFFD\";\n              } else {\n                result += String.fromCharCode(chr);\n              }\n              i += 3;\n              continue;\n            }\n          }\n          if ((b1 & 240) === 224 && i + 6 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n            if ((b2 & 192) === 128 && (b3 & 192) === 128) {\n              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;\n              if (chr < 2048 || chr >= 55296 && chr <= 57343) {\n                result += \"\\uFFFD\\uFFFD\\uFFFD\";\n              } else {\n                result += String.fromCharCode(chr);\n              }\n              i += 6;\n              continue;\n            }\n          }\n          if ((b1 & 248) === 240 && i + 9 < l) {\n            b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n            b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n            b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {\n              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;\n              if (chr < 65536 || chr > 1114111) {\n                result += \"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\";\n              } else {\n                chr -= 65536;\n                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));\n              }\n              i += 9;\n              continue;\n            }\n          }\n          result += \"\\uFFFD\";\n        }\n        return result;\n      });\n    }\n    decode.defaultChars = \";/?:@&=+$,#\";\n    decode.componentChars = \"\";\n    module.exports = decode;\n  }\n});\n\n// node_modules/mdurl/format.js\nvar require_format = __commonJS({\n  \"node_modules/mdurl/format.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function format2(url) {\n      var result = \"\";\n      result += url.protocol || \"\";\n      result += url.slashes ? \"//\" : \"\";\n      result += url.auth ? url.auth + \"@\" : \"\";\n      if (url.hostname && url.hostname.indexOf(\":\") !== -1) {\n        result += \"[\" + url.hostname + \"]\";\n      } else {\n        result += url.hostname || \"\";\n      }\n      result += url.port ? \":\" + url.port : \"\";\n      result += url.pathname || \"\";\n      result += url.search || \"\";\n      result += url.hash || \"\";\n      return result;\n    };\n  }\n});\n\n// node_modules/mdurl/parse.js\nvar require_parse = __commonJS({\n  \"node_modules/mdurl/parse.js\"(exports, module) {\n    \"use strict\";\n    function Url() {\n      this.protocol = null;\n      this.slashes = null;\n      this.auth = null;\n      this.port = null;\n      this.hostname = null;\n      this.hash = null;\n      this.search = null;\n      this.pathname = null;\n    }\n    var protocolPattern = /^([a-z0-9.+-]+:)/i;\n    var portPattern = /:[0-9]*$/;\n    var simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n    var delims = [\"<\", \">\", '\"', \"`\", \" \", \"\\r\", \"\\n\", \"\t\"];\n    var unwise = [\"{\", \"}\", \"|\", \"\\\\\", \"^\", \"`\"].concat(delims);\n    var autoEscape = [\"'\"].concat(unwise);\n    var nonHostChars = [\"%\", \"/\", \"?\", \";\", \"#\"].concat(autoEscape);\n    var hostEndingChars = [\"/\", \"?\", \"#\"];\n    var hostnameMaxLen = 255;\n    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\n    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n    var hostlessProtocol = {\n      \"javascript\": true,\n      \"javascript:\": true\n    };\n    var slashedProtocol = {\n      \"http\": true,\n      \"https\": true,\n      \"ftp\": true,\n      \"gopher\": true,\n      \"file\": true,\n      \"http:\": true,\n      \"https:\": true,\n      \"ftp:\": true,\n      \"gopher:\": true,\n      \"file:\": true\n    };\n    function urlParse(url, slashesDenoteHost) {\n      if (url && url instanceof Url) {\n        return url;\n      }\n      var u = new Url();\n      u.parse(url, slashesDenoteHost);\n      return u;\n    }\n    Url.prototype.parse = function(url, slashesDenoteHost) {\n      var i, l, lowerProto, hec, slashes, rest = url;\n      rest = rest.trim();\n      if (!slashesDenoteHost && url.split(\"#\").length === 1) {\n        var simplePath = simplePathPattern.exec(rest);\n        if (simplePath) {\n          this.pathname = simplePath[1];\n          if (simplePath[2]) {\n            this.search = simplePath[2];\n          }\n          return this;\n        }\n      }\n      var proto = protocolPattern.exec(rest);\n      if (proto) {\n        proto = proto[0];\n        lowerProto = proto.toLowerCase();\n        this.protocol = proto;\n        rest = rest.substr(proto.length);\n      }\n      if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n        slashes = rest.substr(0, 2) === \"//\";\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n          rest = rest.substr(2);\n          this.slashes = true;\n        }\n      }\n      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n        var hostEnd = -1;\n        for (i = 0; i < hostEndingChars.length; i++) {\n          hec = rest.indexOf(hostEndingChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n            hostEnd = hec;\n          }\n        }\n        var auth, atSign;\n        if (hostEnd === -1) {\n          atSign = rest.lastIndexOf(\"@\");\n        } else {\n          atSign = rest.lastIndexOf(\"@\", hostEnd);\n        }\n        if (atSign !== -1) {\n          auth = rest.slice(0, atSign);\n          rest = rest.slice(atSign + 1);\n          this.auth = auth;\n        }\n        hostEnd = -1;\n        for (i = 0; i < nonHostChars.length; i++) {\n          hec = rest.indexOf(nonHostChars[i]);\n          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n            hostEnd = hec;\n          }\n        }\n        if (hostEnd === -1) {\n          hostEnd = rest.length;\n        }\n        if (rest[hostEnd - 1] === \":\") {\n          hostEnd--;\n        }\n        var host = rest.slice(0, hostEnd);\n        rest = rest.slice(hostEnd);\n        this.parseHost(host);\n        this.hostname = this.hostname || \"\";\n        var ipv6Hostname = this.hostname[0] === \"[\" && this.hostname[this.hostname.length - 1] === \"]\";\n        if (!ipv6Hostname) {\n          var hostparts = this.hostname.split(/\\./);\n          for (i = 0, l = hostparts.length; i < l; i++) {\n            var part = hostparts[i];\n            if (!part) {\n              continue;\n            }\n            if (!part.match(hostnamePartPattern)) {\n              var newpart = \"\";\n              for (var j = 0, k = part.length; j < k; j++) {\n                if (part.charCodeAt(j) > 127) {\n                  newpart += \"x\";\n                } else {\n                  newpart += part[j];\n                }\n              }\n              if (!newpart.match(hostnamePartPattern)) {\n                var validParts = hostparts.slice(0, i);\n                var notHost = hostparts.slice(i + 1);\n                var bit = part.match(hostnamePartStart);\n                if (bit) {\n                  validParts.push(bit[1]);\n                  notHost.unshift(bit[2]);\n                }\n                if (notHost.length) {\n                  rest = notHost.join(\".\") + rest;\n                }\n                this.hostname = validParts.join(\".\");\n                break;\n              }\n            }\n          }\n        }\n        if (this.hostname.length > hostnameMaxLen) {\n          this.hostname = \"\";\n        }\n        if (ipv6Hostname) {\n          this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n        }\n      }\n      var hash = rest.indexOf(\"#\");\n      if (hash !== -1) {\n        this.hash = rest.substr(hash);\n        rest = rest.slice(0, hash);\n      }\n      var qm = rest.indexOf(\"?\");\n      if (qm !== -1) {\n        this.search = rest.substr(qm);\n        rest = rest.slice(0, qm);\n      }\n      if (rest) {\n        this.pathname = rest;\n      }\n      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n        this.pathname = \"\";\n      }\n      return this;\n    };\n    Url.prototype.parseHost = function(host) {\n      var port = portPattern.exec(host);\n      if (port) {\n        port = port[0];\n        if (port !== \":\") {\n          this.port = port.substr(1);\n        }\n        host = host.substr(0, host.length - port.length);\n      }\n      if (host) {\n        this.hostname = host;\n      }\n    };\n    module.exports = urlParse;\n  }\n});\n\n// node_modules/mdurl/index.js\nvar require_mdurl = __commonJS({\n  \"node_modules/mdurl/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports.encode = require_encode();\n    module.exports.decode = require_decode();\n    module.exports.format = require_format();\n    module.exports.parse = require_parse();\n  }\n});\n\n// node_modules/uc.micro/properties/Any/regex.js\nvar require_regex2 = __commonJS({\n  \"node_modules/uc.micro/properties/Any/regex.js\"(exports, module) {\n    module.exports = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Cc/regex.js\nvar require_regex3 = __commonJS({\n  \"node_modules/uc.micro/categories/Cc/regex.js\"(exports, module) {\n    module.exports = /[\\0-\\x1F\\x7F-\\x9F]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Cf/regex.js\nvar require_regex4 = __commonJS({\n  \"node_modules/uc.micro/categories/Cf/regex.js\"(exports, module) {\n    module.exports = /[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/;\n  }\n});\n\n// node_modules/uc.micro/categories/Z/regex.js\nvar require_regex5 = __commonJS({\n  \"node_modules/uc.micro/categories/Z/regex.js\"(exports, module) {\n    module.exports = /[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n  }\n});\n\n// node_modules/uc.micro/index.js\nvar require_uc = __commonJS({\n  \"node_modules/uc.micro/index.js\"(exports) {\n    \"use strict\";\n    exports.Any = require_regex2();\n    exports.Cc = require_regex3();\n    exports.Cf = require_regex4();\n    exports.P = require_regex();\n    exports.Z = require_regex5();\n  }\n});\n\n// node_modules/markdown-it/lib/common/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/markdown-it/lib/common/utils.js\"(exports) {\n    \"use strict\";\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function isString(obj) {\n      return _class(obj) === \"[object String]\";\n    }\n    var _hasOwnProperty = Object.prototype.hasOwnProperty;\n    function has(object, key) {\n      return _hasOwnProperty.call(object, key);\n    }\n    function assign(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      sources.forEach(function(source) {\n        if (!source) {\n          return;\n        }\n        if (typeof source !== \"object\") {\n          throw new TypeError(source + \"must be object\");\n        }\n        Object.keys(source).forEach(function(key) {\n          obj[key] = source[key];\n        });\n      });\n      return obj;\n    }\n    function arrayReplaceAt(src, pos, newElements) {\n      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));\n    }\n    function isValidEntityCode(c) {\n      if (c >= 55296 && c <= 57343) {\n        return false;\n      }\n      if (c >= 64976 && c <= 65007) {\n        return false;\n      }\n      if ((c & 65535) === 65535 || (c & 65535) === 65534) {\n        return false;\n      }\n      if (c >= 0 && c <= 8) {\n        return false;\n      }\n      if (c === 11) {\n        return false;\n      }\n      if (c >= 14 && c <= 31) {\n        return false;\n      }\n      if (c >= 127 && c <= 159) {\n        return false;\n      }\n      if (c > 1114111) {\n        return false;\n      }\n      return true;\n    }\n    function fromCodePoint(c) {\n      if (c > 65535) {\n        c -= 65536;\n        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);\n        return String.fromCharCode(surrogate1, surrogate2);\n      }\n      return String.fromCharCode(c);\n    }\n    var UNESCAPE_MD_RE = /\\\\([!\"#$%&'()*+,\\-.\\/:;<=>?@[\\\\\\]^_`{|}~])/g;\n    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\n    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + \"|\" + ENTITY_RE.source, \"gi\");\n    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n    var entities = require_entities2();\n    function replaceEntityPattern(match, name) {\n      var code2 = 0;\n      if (has(entities, name)) {\n        return entities[name];\n      }\n      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {\n        code2 = name[1].toLowerCase() === \"x\" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n        if (isValidEntityCode(code2)) {\n          return fromCodePoint(code2);\n        }\n      }\n      return match;\n    }\n    function unescapeMd(str) {\n      if (str.indexOf(\"\\\\\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_MD_RE, \"$1\");\n    }\n    function unescapeAll(str) {\n      if (str.indexOf(\"\\\\\") < 0 && str.indexOf(\"&\") < 0) {\n        return str;\n      }\n      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {\n        if (escaped) {\n          return escaped;\n        }\n        return replaceEntityPattern(match, entity);\n      });\n    }\n    var HTML_ESCAPE_TEST_RE = /[&<>\"]/;\n    var HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\n    var HTML_REPLACEMENTS = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\"\n    };\n    function replaceUnsafeChar(ch) {\n      return HTML_REPLACEMENTS[ch];\n    }\n    function escapeHtml2(str) {\n      if (HTML_ESCAPE_TEST_RE.test(str)) {\n        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n      }\n      return str;\n    }\n    var REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g;\n    function escapeRE(str) {\n      return str.replace(REGEXP_ESCAPE_RE, \"\\\\$&\");\n    }\n    function isSpace(code2) {\n      switch (code2) {\n        case 9:\n        case 32:\n          return true;\n      }\n      return false;\n    }\n    function isWhiteSpace(code2) {\n      if (code2 >= 8192 && code2 <= 8202) {\n        return true;\n      }\n      switch (code2) {\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 32:\n        case 160:\n        case 5760:\n        case 8239:\n        case 8287:\n        case 12288:\n          return true;\n      }\n      return false;\n    }\n    var UNICODE_PUNCT_RE = require_regex();\n    function isPunctChar(ch) {\n      return UNICODE_PUNCT_RE.test(ch);\n    }\n    function isMdAsciiPunct(ch) {\n      switch (ch) {\n        case 33:\n        case 34:\n        case 35:\n        case 36:\n        case 37:\n        case 38:\n        case 39:\n        case 40:\n        case 41:\n        case 42:\n        case 43:\n        case 44:\n        case 45:\n        case 46:\n        case 47:\n        case 58:\n        case 59:\n        case 60:\n        case 61:\n        case 62:\n        case 63:\n        case 64:\n        case 91:\n        case 92:\n        case 93:\n        case 94:\n        case 95:\n        case 96:\n        case 123:\n        case 124:\n        case 125:\n        case 126:\n          return true;\n        default:\n          return false;\n      }\n    }\n    function normalizeReference(str) {\n      str = str.trim().replace(/\\s+/g, \" \");\n      if (\"\\u1E9E\".toLowerCase() === \"\\u1E7E\") {\n        str = str.replace(/ẞ/g, \"\\xDF\");\n      }\n      return str.toLowerCase().toUpperCase();\n    }\n    exports.lib = {};\n    exports.lib.mdurl = require_mdurl();\n    exports.lib.ucmicro = require_uc();\n    exports.assign = assign;\n    exports.isString = isString;\n    exports.has = has;\n    exports.unescapeMd = unescapeMd;\n    exports.unescapeAll = unescapeAll;\n    exports.isValidEntityCode = isValidEntityCode;\n    exports.fromCodePoint = fromCodePoint;\n    exports.escapeHtml = escapeHtml2;\n    exports.arrayReplaceAt = arrayReplaceAt;\n    exports.isSpace = isSpace;\n    exports.isWhiteSpace = isWhiteSpace;\n    exports.isMdAsciiPunct = isMdAsciiPunct;\n    exports.isPunctChar = isPunctChar;\n    exports.escapeRE = escapeRE;\n    exports.normalizeReference = normalizeReference;\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_label.js\nvar require_parse_link_label = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_label.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function parseLinkLabel(state, start, disableNested) {\n      var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;\n      state.pos = start + 1;\n      level = 1;\n      while (state.pos < max2) {\n        marker = state.src.charCodeAt(state.pos);\n        if (marker === 93) {\n          level--;\n          if (level === 0) {\n            found = true;\n            break;\n          }\n        }\n        prevPos = state.pos;\n        state.md.inline.skipToken(state);\n        if (marker === 91) {\n          if (prevPos === state.pos - 1) {\n            level++;\n          } else if (disableNested) {\n            state.pos = oldPos;\n            return -1;\n          }\n        }\n      }\n      if (found) {\n        labelEnd = state.pos;\n      }\n      state.pos = oldPos;\n      return labelEnd;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_destination.js\nvar require_parse_link_destination = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_destination.js\"(exports, module) {\n    \"use strict\";\n    var unescapeAll = require_utils().unescapeAll;\n    module.exports = function parseLinkDestination(str, pos, max2) {\n      var code2, level, lines = 0, start = pos, result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: \"\"\n      };\n      if (str.charCodeAt(pos) === 60) {\n        pos++;\n        while (pos < max2) {\n          code2 = str.charCodeAt(pos);\n          if (code2 === 10) {\n            return result;\n          }\n          if (code2 === 60) {\n            return result;\n          }\n          if (code2 === 62) {\n            result.pos = pos + 1;\n            result.str = unescapeAll(str.slice(start + 1, pos));\n            result.ok = true;\n            return result;\n          }\n          if (code2 === 92 && pos + 1 < max2) {\n            pos += 2;\n            continue;\n          }\n          pos++;\n        }\n        return result;\n      }\n      level = 0;\n      while (pos < max2) {\n        code2 = str.charCodeAt(pos);\n        if (code2 === 32) {\n          break;\n        }\n        if (code2 < 32 || code2 === 127) {\n          break;\n        }\n        if (code2 === 92 && pos + 1 < max2) {\n          if (str.charCodeAt(pos + 1) === 32) {\n            break;\n          }\n          pos += 2;\n          continue;\n        }\n        if (code2 === 40) {\n          level++;\n          if (level > 32) {\n            return result;\n          }\n        }\n        if (code2 === 41) {\n          if (level === 0) {\n            break;\n          }\n          level--;\n        }\n        pos++;\n      }\n      if (start === pos) {\n        return result;\n      }\n      if (level !== 0) {\n        return result;\n      }\n      result.str = unescapeAll(str.slice(start, pos));\n      result.lines = lines;\n      result.pos = pos;\n      result.ok = true;\n      return result;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/parse_link_title.js\nvar require_parse_link_title = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/parse_link_title.js\"(exports, module) {\n    \"use strict\";\n    var unescapeAll = require_utils().unescapeAll;\n    module.exports = function parseLinkTitle(str, pos, max2) {\n      var code2, marker, lines = 0, start = pos, result = {\n        ok: false,\n        pos: 0,\n        lines: 0,\n        str: \"\"\n      };\n      if (pos >= max2) {\n        return result;\n      }\n      marker = str.charCodeAt(pos);\n      if (marker !== 34 && marker !== 39 && marker !== 40) {\n        return result;\n      }\n      pos++;\n      if (marker === 40) {\n        marker = 41;\n      }\n      while (pos < max2) {\n        code2 = str.charCodeAt(pos);\n        if (code2 === marker) {\n          result.pos = pos + 1;\n          result.lines = lines;\n          result.str = unescapeAll(str.slice(start + 1, pos));\n          result.ok = true;\n          return result;\n        } else if (code2 === 40 && marker === 41) {\n          return result;\n        } else if (code2 === 10) {\n          lines++;\n        } else if (code2 === 92 && pos + 1 < max2) {\n          pos++;\n          if (str.charCodeAt(pos) === 10) {\n            lines++;\n          }\n        }\n        pos++;\n      }\n      return result;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/helpers/index.js\nvar require_helpers = __commonJS({\n  \"node_modules/markdown-it/lib/helpers/index.js\"(exports) {\n    \"use strict\";\n    exports.parseLinkLabel = require_parse_link_label();\n    exports.parseLinkDestination = require_parse_link_destination();\n    exports.parseLinkTitle = require_parse_link_title();\n  }\n});\n\n// node_modules/markdown-it/lib/renderer.js\nvar require_renderer = __commonJS({\n  \"node_modules/markdown-it/lib/renderer.js\"(exports, module) {\n    \"use strict\";\n    var assign = require_utils().assign;\n    var unescapeAll = require_utils().unescapeAll;\n    var escapeHtml2 = require_utils().escapeHtml;\n    var default_rules = {};\n    default_rules.code_inline = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      return \"<code\" + slf.renderAttrs(token) + \">\" + escapeHtml2(tokens[idx].content) + \"</code>\";\n    };\n    default_rules.code_block = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      return \"<pre\" + slf.renderAttrs(token) + \"><code>\" + escapeHtml2(tokens[idx].content) + \"</code></pre>\\n\";\n    };\n    default_rules.fence = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : \"\", langName = \"\", langAttrs = \"\", highlighted, i, arr, tmpAttrs, tmpToken;\n      if (info) {\n        arr = info.split(/(\\s+)/g);\n        langName = arr[0];\n        langAttrs = arr.slice(2).join(\"\");\n      }\n      if (options.highlight) {\n        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);\n      } else {\n        highlighted = escapeHtml2(token.content);\n      }\n      if (highlighted.indexOf(\"<pre\") === 0) {\n        return highlighted + \"\\n\";\n      }\n      if (info) {\n        i = token.attrIndex(\"class\");\n        tmpAttrs = token.attrs ? token.attrs.slice() : [];\n        if (i < 0) {\n          tmpAttrs.push([\"class\", options.langPrefix + langName]);\n        } else {\n          tmpAttrs[i] = tmpAttrs[i].slice();\n          tmpAttrs[i][1] += \" \" + options.langPrefix + langName;\n        }\n        tmpToken = {\n          attrs: tmpAttrs\n        };\n        return \"<pre><code\" + slf.renderAttrs(tmpToken) + \">\" + highlighted + \"</code></pre>\\n\";\n      }\n      return \"<pre><code\" + slf.renderAttrs(token) + \">\" + highlighted + \"</code></pre>\\n\";\n    };\n    default_rules.image = function(tokens, idx, options, env, slf) {\n      var token = tokens[idx];\n      token.attrs[token.attrIndex(\"alt\")][1] = slf.renderInlineAsText(token.children, options, env);\n      return slf.renderToken(tokens, idx, options);\n    };\n    default_rules.hardbreak = function(tokens, idx, options) {\n      return options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\";\n    };\n    default_rules.softbreak = function(tokens, idx, options) {\n      return options.breaks ? options.xhtmlOut ? \"<br />\\n\" : \"<br>\\n\" : \"\\n\";\n    };\n    default_rules.text = function(tokens, idx) {\n      return escapeHtml2(tokens[idx].content);\n    };\n    default_rules.html_block = function(tokens, idx) {\n      return tokens[idx].content;\n    };\n    default_rules.html_inline = function(tokens, idx) {\n      return tokens[idx].content;\n    };\n    function Renderer() {\n      this.rules = assign({}, default_rules);\n    }\n    Renderer.prototype.renderAttrs = function renderAttrs(token) {\n      var i, l, result;\n      if (!token.attrs) {\n        return \"\";\n      }\n      result = \"\";\n      for (i = 0, l = token.attrs.length; i < l; i++) {\n        result += \" \" + escapeHtml2(token.attrs[i][0]) + '=\"' + escapeHtml2(token.attrs[i][1]) + '\"';\n      }\n      return result;\n    };\n    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n      var nextToken, result = \"\", needLf = false, token = tokens[idx];\n      if (token.hidden) {\n        return \"\";\n      }\n      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n        result += \"\\n\";\n      }\n      result += (token.nesting === -1 ? \"</\" : \"<\") + token.tag;\n      result += this.renderAttrs(token);\n      if (token.nesting === 0 && options.xhtmlOut) {\n        result += \" /\";\n      }\n      if (token.block) {\n        needLf = true;\n        if (token.nesting === 1) {\n          if (idx + 1 < tokens.length) {\n            nextToken = tokens[idx + 1];\n            if (nextToken.type === \"inline\" || nextToken.hidden) {\n              needLf = false;\n            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n              needLf = false;\n            }\n          }\n        }\n      }\n      result += needLf ? \">\\n\" : \">\";\n      return result;\n    };\n    Renderer.prototype.renderInline = function(tokens, options, env) {\n      var type, result = \"\", rules = this.rules;\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n        if (typeof rules[type] !== \"undefined\") {\n          result += rules[type](tokens, i, options, env, this);\n        } else {\n          result += this.renderToken(tokens, i, options);\n        }\n      }\n      return result;\n    };\n    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {\n      var result = \"\";\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        if (tokens[i].type === \"text\") {\n          result += tokens[i].content;\n        } else if (tokens[i].type === \"image\") {\n          result += this.renderInlineAsText(tokens[i].children, options, env);\n        } else if (tokens[i].type === \"softbreak\") {\n          result += \"\\n\";\n        }\n      }\n      return result;\n    };\n    Renderer.prototype.render = function(tokens, options, env) {\n      var i, len, type, result = \"\", rules = this.rules;\n      for (i = 0, len = tokens.length; i < len; i++) {\n        type = tokens[i].type;\n        if (type === \"inline\") {\n          result += this.renderInline(tokens[i].children, options, env);\n        } else if (typeof rules[type] !== \"undefined\") {\n          result += rules[tokens[i].type](tokens, i, options, env, this);\n        } else {\n          result += this.renderToken(tokens, i, options, env);\n        }\n      }\n      return result;\n    };\n    module.exports = Renderer;\n  }\n});\n\n// node_modules/markdown-it/lib/ruler.js\nvar require_ruler = __commonJS({\n  \"node_modules/markdown-it/lib/ruler.js\"(exports, module) {\n    \"use strict\";\n    function Ruler() {\n      this.__rules__ = [];\n      this.__cache__ = null;\n    }\n    Ruler.prototype.__find__ = function(name) {\n      for (var i = 0; i < this.__rules__.length; i++) {\n        if (this.__rules__[i].name === name) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    Ruler.prototype.__compile__ = function() {\n      var self = this;\n      var chains = [\"\"];\n      self.__rules__.forEach(function(rule) {\n        if (!rule.enabled) {\n          return;\n        }\n        rule.alt.forEach(function(altName) {\n          if (chains.indexOf(altName) < 0) {\n            chains.push(altName);\n          }\n        });\n      });\n      self.__cache__ = {};\n      chains.forEach(function(chain) {\n        self.__cache__[chain] = [];\n        self.__rules__.forEach(function(rule) {\n          if (!rule.enabled) {\n            return;\n          }\n          if (chain && rule.alt.indexOf(chain) < 0) {\n            return;\n          }\n          self.__cache__[chain].push(rule.fn);\n        });\n      });\n    };\n    Ruler.prototype.at = function(name, fn, options) {\n      var index = this.__find__(name);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + name);\n      }\n      this.__rules__[index].fn = fn;\n      this.__rules__[index].alt = opt.alt || [];\n      this.__cache__ = null;\n    };\n    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {\n      var index = this.__find__(beforeName);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + beforeName);\n      }\n      this.__rules__.splice(index, 0, {\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.after = function(afterName, ruleName, fn, options) {\n      var index = this.__find__(afterName);\n      var opt = options || {};\n      if (index === -1) {\n        throw new Error(\"Parser rule not found: \" + afterName);\n      }\n      this.__rules__.splice(index + 1, 0, {\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.push = function(ruleName, fn, options) {\n      var opt = options || {};\n      this.__rules__.push({\n        name: ruleName,\n        enabled: true,\n        fn,\n        alt: opt.alt || []\n      });\n      this.__cache__ = null;\n    };\n    Ruler.prototype.enable = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      var result = [];\n      list2.forEach(function(name) {\n        var idx = this.__find__(name);\n        if (idx < 0) {\n          if (ignoreInvalid) {\n            return;\n          }\n          throw new Error(\"Rules manager: invalid rule name \" + name);\n        }\n        this.__rules__[idx].enabled = true;\n        result.push(name);\n      }, this);\n      this.__cache__ = null;\n      return result;\n    };\n    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      this.__rules__.forEach(function(rule) {\n        rule.enabled = false;\n      });\n      this.enable(list2, ignoreInvalid);\n    };\n    Ruler.prototype.disable = function(list2, ignoreInvalid) {\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      var result = [];\n      list2.forEach(function(name) {\n        var idx = this.__find__(name);\n        if (idx < 0) {\n          if (ignoreInvalid) {\n            return;\n          }\n          throw new Error(\"Rules manager: invalid rule name \" + name);\n        }\n        this.__rules__[idx].enabled = false;\n        result.push(name);\n      }, this);\n      this.__cache__ = null;\n      return result;\n    };\n    Ruler.prototype.getRules = function(chainName) {\n      if (this.__cache__ === null) {\n        this.__compile__();\n      }\n      return this.__cache__[chainName] || [];\n    };\n    module.exports = Ruler;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/normalize.js\nvar require_normalize = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/normalize.js\"(exports, module) {\n    \"use strict\";\n    var NEWLINES_RE = /\\r\\n?|\\n/g;\n    var NULL_RE = /\\0/g;\n    module.exports = function normalize(state) {\n      var str;\n      str = state.src.replace(NEWLINES_RE, \"\\n\");\n      str = str.replace(NULL_RE, \"\\uFFFD\");\n      state.src = str;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/block.js\nvar require_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/block.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function block3(state) {\n      var token;\n      if (state.inlineMode) {\n        token = new state.Token(\"inline\", \"\", 0);\n        token.content = state.src;\n        token.map = [0, 1];\n        token.children = [];\n        state.tokens.push(token);\n      } else {\n        state.md.block.parse(state.src, state.md, state.env, state.tokens);\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/inline.js\nvar require_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/inline.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function inline3(state) {\n      var tokens = state.tokens, tok, i, l;\n      for (i = 0, l = tokens.length; i < l; i++) {\n        tok = tokens[i];\n        if (tok.type === \"inline\") {\n          state.md.inline.parse(tok.content, state.md, state.env, tok.children);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/linkify.js\nvar require_linkify = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/linkify.js\"(exports, module) {\n    \"use strict\";\n    var arrayReplaceAt = require_utils().arrayReplaceAt;\n    function isLinkOpen(str) {\n      return /^<a[>\\s]/i.test(str);\n    }\n    function isLinkClose(str) {\n      return /^<\\/a\\s*>/i.test(str);\n    }\n    module.exports = function linkify(state) {\n      var i, j, l, tokens, token, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;\n      if (!state.md.options.linkify) {\n        return;\n      }\n      for (j = 0, l = blockTokens.length; j < l; j++) {\n        if (blockTokens[j].type !== \"inline\" || !state.md.linkify.pretest(blockTokens[j].content)) {\n          continue;\n        }\n        tokens = blockTokens[j].children;\n        htmlLinkLevel = 0;\n        for (i = tokens.length - 1; i >= 0; i--) {\n          currentToken = tokens[i];\n          if (currentToken.type === \"link_close\") {\n            i--;\n            while (tokens[i].level !== currentToken.level && tokens[i].type !== \"link_open\") {\n              i--;\n            }\n            continue;\n          }\n          if (currentToken.type === \"html_inline\") {\n            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n              htmlLinkLevel--;\n            }\n            if (isLinkClose(currentToken.content)) {\n              htmlLinkLevel++;\n            }\n          }\n          if (htmlLinkLevel > 0) {\n            continue;\n          }\n          if (currentToken.type === \"text\" && state.md.linkify.test(currentToken.content)) {\n            text2 = currentToken.content;\n            links = state.md.linkify.match(text2);\n            nodes = [];\n            level = currentToken.level;\n            lastPos = 0;\n            for (ln = 0; ln < links.length; ln++) {\n              url = links[ln].url;\n              fullUrl = state.md.normalizeLink(url);\n              if (!state.md.validateLink(fullUrl)) {\n                continue;\n              }\n              urlText = links[ln].text;\n              if (!links[ln].schema) {\n                urlText = state.md.normalizeLinkText(\"http://\" + urlText).replace(/^http:\\/\\//, \"\");\n              } else if (links[ln].schema === \"mailto:\" && !/^mailto:/i.test(urlText)) {\n                urlText = state.md.normalizeLinkText(\"mailto:\" + urlText).replace(/^mailto:/, \"\");\n              } else {\n                urlText = state.md.normalizeLinkText(urlText);\n              }\n              pos = links[ln].index;\n              if (pos > lastPos) {\n                token = new state.Token(\"text\", \"\", 0);\n                token.content = text2.slice(lastPos, pos);\n                token.level = level;\n                nodes.push(token);\n              }\n              token = new state.Token(\"link_open\", \"a\", 1);\n              token.attrs = [[\"href\", fullUrl]];\n              token.level = level++;\n              token.markup = \"linkify\";\n              token.info = \"auto\";\n              nodes.push(token);\n              token = new state.Token(\"text\", \"\", 0);\n              token.content = urlText;\n              token.level = level;\n              nodes.push(token);\n              token = new state.Token(\"link_close\", \"a\", -1);\n              token.level = --level;\n              token.markup = \"linkify\";\n              token.info = \"auto\";\n              nodes.push(token);\n              lastPos = links[ln].lastIndex;\n            }\n            if (lastPos < text2.length) {\n              token = new state.Token(\"text\", \"\", 0);\n              token.content = text2.slice(lastPos);\n              token.level = level;\n              nodes.push(token);\n            }\n            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n          }\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/replacements.js\nvar require_replacements = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/replacements.js\"(exports, module) {\n    \"use strict\";\n    var RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\n    var SCOPED_ABBR_TEST_RE = /\\((c|tm|r|p)\\)/i;\n    var SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\n    var SCOPED_ABBR = {\n      c: \"\\xA9\",\n      r: \"\\xAE\",\n      p: \"\\xA7\",\n      tm: \"\\u2122\"\n    };\n    function replaceFn(match, name) {\n      return SCOPED_ABBR[name.toLowerCase()];\n    }\n    function replace_scoped(inlineTokens) {\n      var i, token, inside_autolink = 0;\n      for (i = inlineTokens.length - 1; i >= 0; i--) {\n        token = inlineTokens[i];\n        if (token.type === \"text\" && !inside_autolink) {\n          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);\n        }\n        if (token.type === \"link_open\" && token.info === \"auto\") {\n          inside_autolink--;\n        }\n        if (token.type === \"link_close\" && token.info === \"auto\") {\n          inside_autolink++;\n        }\n      }\n    }\n    function replace_rare(inlineTokens) {\n      var i, token, inside_autolink = 0;\n      for (i = inlineTokens.length - 1; i >= 0; i--) {\n        token = inlineTokens[i];\n        if (token.type === \"text\" && !inside_autolink) {\n          if (RARE_RE.test(token.content)) {\n            token.content = token.content.replace(/\\+-/g, \"\\xB1\").replace(/\\.{2,}/g, \"\\u2026\").replace(/([?!])…/g, \"$1..\").replace(/([?!]){4,}/g, \"$1$1$1\").replace(/,{2,}/g, \",\").replace(/(^|[^-])---(?=[^-]|$)/mg, \"$1\\u2014\").replace(/(^|\\s)--(?=\\s|$)/mg, \"$1\\u2013\").replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, \"$1\\u2013\");\n          }\n        }\n        if (token.type === \"link_open\" && token.info === \"auto\") {\n          inside_autolink--;\n        }\n        if (token.type === \"link_close\" && token.info === \"auto\") {\n          inside_autolink++;\n        }\n      }\n    }\n    module.exports = function replace(state) {\n      var blkIdx;\n      if (!state.md.options.typographer) {\n        return;\n      }\n      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n        if (state.tokens[blkIdx].type !== \"inline\") {\n          continue;\n        }\n        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n          replace_scoped(state.tokens[blkIdx].children);\n        }\n        if (RARE_RE.test(state.tokens[blkIdx].content)) {\n          replace_rare(state.tokens[blkIdx].children);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/smartquotes.js\nvar require_smartquotes = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/smartquotes.js\"(exports, module) {\n    \"use strict\";\n    var isWhiteSpace = require_utils().isWhiteSpace;\n    var isPunctChar = require_utils().isPunctChar;\n    var isMdAsciiPunct = require_utils().isMdAsciiPunct;\n    var QUOTE_TEST_RE = /['\"]/;\n    var QUOTE_RE = /['\"]/g;\n    var APOSTROPHE = \"\\u2019\";\n    function replaceAt(str, index, ch) {\n      return str.substr(0, index) + ch + str.substr(index + 1);\n    }\n    function process_inlines(tokens, state) {\n      var i, token, text2, t, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n      stack = [];\n      for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        thisLevel = tokens[i].level;\n        for (j = stack.length - 1; j >= 0; j--) {\n          if (stack[j].level <= thisLevel) {\n            break;\n          }\n        }\n        stack.length = j + 1;\n        if (token.type !== \"text\") {\n          continue;\n        }\n        text2 = token.content;\n        pos = 0;\n        max2 = text2.length;\n        OUTER:\n          while (pos < max2) {\n            QUOTE_RE.lastIndex = pos;\n            t = QUOTE_RE.exec(text2);\n            if (!t) {\n              break;\n            }\n            canOpen = canClose = true;\n            pos = t.index + 1;\n            isSingle = t[0] === \"'\";\n            lastChar = 32;\n            if (t.index - 1 >= 0) {\n              lastChar = text2.charCodeAt(t.index - 1);\n            } else {\n              for (j = i - 1; j >= 0; j--) {\n                if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n                  break;\n                if (!tokens[j].content)\n                  continue;\n                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n                break;\n              }\n            }\n            nextChar = 32;\n            if (pos < max2) {\n              nextChar = text2.charCodeAt(pos);\n            } else {\n              for (j = i + 1; j < tokens.length; j++) {\n                if (tokens[j].type === \"softbreak\" || tokens[j].type === \"hardbreak\")\n                  break;\n                if (!tokens[j].content)\n                  continue;\n                nextChar = tokens[j].content.charCodeAt(0);\n                break;\n              }\n            }\n            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n            isLastWhiteSpace = isWhiteSpace(lastChar);\n            isNextWhiteSpace = isWhiteSpace(nextChar);\n            if (isNextWhiteSpace) {\n              canOpen = false;\n            } else if (isNextPunctChar) {\n              if (!(isLastWhiteSpace || isLastPunctChar)) {\n                canOpen = false;\n              }\n            }\n            if (isLastWhiteSpace) {\n              canClose = false;\n            } else if (isLastPunctChar) {\n              if (!(isNextWhiteSpace || isNextPunctChar)) {\n                canClose = false;\n              }\n            }\n            if (nextChar === 34 && t[0] === '\"') {\n              if (lastChar >= 48 && lastChar <= 57) {\n                canClose = canOpen = false;\n              }\n            }\n            if (canOpen && canClose) {\n              canOpen = isLastPunctChar;\n              canClose = isNextPunctChar;\n            }\n            if (!canOpen && !canClose) {\n              if (isSingle) {\n                token.content = replaceAt(token.content, t.index, APOSTROPHE);\n              }\n              continue;\n            }\n            if (canClose) {\n              for (j = stack.length - 1; j >= 0; j--) {\n                item2 = stack[j];\n                if (stack[j].level < thisLevel) {\n                  break;\n                }\n                if (item2.single === isSingle && stack[j].level === thisLevel) {\n                  item2 = stack[j];\n                  if (isSingle) {\n                    openQuote = state.md.options.quotes[2];\n                    closeQuote = state.md.options.quotes[3];\n                  } else {\n                    openQuote = state.md.options.quotes[0];\n                    closeQuote = state.md.options.quotes[1];\n                  }\n                  token.content = replaceAt(token.content, t.index, closeQuote);\n                  tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);\n                  pos += closeQuote.length - 1;\n                  if (item2.token === i) {\n                    pos += openQuote.length - 1;\n                  }\n                  text2 = token.content;\n                  max2 = text2.length;\n                  stack.length = j;\n                  continue OUTER;\n                }\n              }\n            }\n            if (canOpen) {\n              stack.push({\n                token: i,\n                pos: t.index,\n                single: isSingle,\n                level: thisLevel\n              });\n            } else if (canClose && isSingle) {\n              token.content = replaceAt(token.content, t.index, APOSTROPHE);\n            }\n          }\n      }\n    }\n    module.exports = function smartquotes(state) {\n      var blkIdx;\n      if (!state.md.options.typographer) {\n        return;\n      }\n      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n        if (state.tokens[blkIdx].type !== \"inline\" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n          continue;\n        }\n        process_inlines(state.tokens[blkIdx].children, state);\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/token.js\nvar require_token = __commonJS({\n  \"node_modules/markdown-it/lib/token.js\"(exports, module) {\n    \"use strict\";\n    function Token(type, tag, nesting) {\n      this.type = type;\n      this.tag = tag;\n      this.attrs = null;\n      this.map = null;\n      this.nesting = nesting;\n      this.level = 0;\n      this.children = null;\n      this.content = \"\";\n      this.markup = \"\";\n      this.info = \"\";\n      this.meta = null;\n      this.block = false;\n      this.hidden = false;\n    }\n    Token.prototype.attrIndex = function attrIndex(name) {\n      var attrs, i, len;\n      if (!this.attrs) {\n        return -1;\n      }\n      attrs = this.attrs;\n      for (i = 0, len = attrs.length; i < len; i++) {\n        if (attrs[i][0] === name) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    Token.prototype.attrPush = function attrPush(attrData) {\n      if (this.attrs) {\n        this.attrs.push(attrData);\n      } else {\n        this.attrs = [attrData];\n      }\n    };\n    Token.prototype.attrSet = function attrSet(name, value) {\n      var idx = this.attrIndex(name), attrData = [name, value];\n      if (idx < 0) {\n        this.attrPush(attrData);\n      } else {\n        this.attrs[idx] = attrData;\n      }\n    };\n    Token.prototype.attrGet = function attrGet(name) {\n      var idx = this.attrIndex(name), value = null;\n      if (idx >= 0) {\n        value = this.attrs[idx][1];\n      }\n      return value;\n    };\n    Token.prototype.attrJoin = function attrJoin(name, value) {\n      var idx = this.attrIndex(name);\n      if (idx < 0) {\n        this.attrPush([name, value]);\n      } else {\n        this.attrs[idx][1] = this.attrs[idx][1] + \" \" + value;\n      }\n    };\n    module.exports = Token;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_core/state_core.js\nvar require_state_core = __commonJS({\n  \"node_modules/markdown-it/lib/rules_core/state_core.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    function StateCore(src, md, env) {\n      this.src = src;\n      this.env = env;\n      this.tokens = [];\n      this.inlineMode = false;\n      this.md = md;\n    }\n    StateCore.prototype.Token = Token;\n    module.exports = StateCore;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_core.js\nvar require_parser_core = __commonJS({\n  \"node_modules/markdown-it/lib/parser_core.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"normalize\", require_normalize()],\n      [\"block\", require_block()],\n      [\"inline\", require_inline()],\n      [\"linkify\", require_linkify()],\n      [\"replacements\", require_replacements()],\n      [\"smartquotes\", require_smartquotes()]\n    ];\n    function Core() {\n      this.ruler = new Ruler();\n      for (var i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1]);\n      }\n    }\n    Core.prototype.process = function(state) {\n      var i, l, rules;\n      rules = this.ruler.getRules(\"\");\n      for (i = 0, l = rules.length; i < l; i++) {\n        rules[i](state);\n      }\n    };\n    Core.prototype.State = require_state_core();\n    module.exports = Core;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/table.js\nvar require_table = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/table.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    function getLine2(state, line) {\n      var pos = state.bMarks[line] + state.tShift[line], max2 = state.eMarks[line];\n      return state.src.substr(pos, max2 - pos);\n    }\n    function escapedSplit(str) {\n      var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = \"\";\n      ch = str.charCodeAt(pos);\n      while (pos < max2) {\n        if (ch === 124) {\n          if (!isEscaped) {\n            result.push(current + str.substring(lastPos, pos));\n            current = \"\";\n            lastPos = pos + 1;\n          } else {\n            current += str.substring(lastPos, pos - 1);\n            lastPos = pos;\n          }\n        }\n        isEscaped = ch === 92;\n        pos++;\n        ch = str.charCodeAt(pos);\n      }\n      result.push(current + str.substring(lastPos));\n      return result;\n    }\n    module.exports = function table3(state, startLine, endLine, silent) {\n      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;\n      if (startLine + 2 > endLine) {\n        return false;\n      }\n      nextLine = startLine + 1;\n      if (state.sCount[nextLine] < state.blkIndent) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      if (pos >= state.eMarks[nextLine]) {\n        return false;\n      }\n      firstCh = state.src.charCodeAt(pos++);\n      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {\n        return false;\n      }\n      if (pos >= state.eMarks[nextLine]) {\n        return false;\n      }\n      secondCh = state.src.charCodeAt(pos++);\n      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {\n        return false;\n      }\n      if (firstCh === 45 && isSpace(secondCh)) {\n        return false;\n      }\n      while (pos < state.eMarks[nextLine]) {\n        ch = state.src.charCodeAt(pos);\n        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {\n          return false;\n        }\n        pos++;\n      }\n      lineText = getLine2(state, startLine + 1);\n      columns = lineText.split(\"|\");\n      aligns = [];\n      for (i = 0; i < columns.length; i++) {\n        t = columns[i].trim();\n        if (!t) {\n          if (i === 0 || i === columns.length - 1) {\n            continue;\n          } else {\n            return false;\n          }\n        }\n        if (!/^:?-+:?$/.test(t)) {\n          return false;\n        }\n        if (t.charCodeAt(t.length - 1) === 58) {\n          aligns.push(t.charCodeAt(0) === 58 ? \"center\" : \"right\");\n        } else if (t.charCodeAt(0) === 58) {\n          aligns.push(\"left\");\n        } else {\n          aligns.push(\"\");\n        }\n      }\n      lineText = getLine2(state, startLine).trim();\n      if (lineText.indexOf(\"|\") === -1) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      columns = escapedSplit(lineText);\n      if (columns.length && columns[0] === \"\")\n        columns.shift();\n      if (columns.length && columns[columns.length - 1] === \"\")\n        columns.pop();\n      columnCount = columns.length;\n      if (columnCount === 0 || columnCount !== aligns.length) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      oldParentType = state.parentType;\n      state.parentType = \"table\";\n      terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n      token = state.push(\"table_open\", \"table\", 1);\n      token.map = tableLines = [startLine, 0];\n      token = state.push(\"thead_open\", \"thead\", 1);\n      token.map = [startLine, startLine + 1];\n      token = state.push(\"tr_open\", \"tr\", 1);\n      token.map = [startLine, startLine + 1];\n      for (i = 0; i < columns.length; i++) {\n        token = state.push(\"th_open\", \"th\", 1);\n        if (aligns[i]) {\n          token.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n        }\n        token = state.push(\"inline\", \"\", 0);\n        token.content = columns[i].trim();\n        token.children = [];\n        token = state.push(\"th_close\", \"th\", -1);\n      }\n      token = state.push(\"tr_close\", \"tr\", -1);\n      token = state.push(\"thead_close\", \"thead\", -1);\n      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n        lineText = getLine2(state, nextLine).trim();\n        if (!lineText) {\n          break;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n          break;\n        }\n        columns = escapedSplit(lineText);\n        if (columns.length && columns[0] === \"\")\n          columns.shift();\n        if (columns.length && columns[columns.length - 1] === \"\")\n          columns.pop();\n        if (nextLine === startLine + 2) {\n          token = state.push(\"tbody_open\", \"tbody\", 1);\n          token.map = tbodyLines = [startLine + 2, 0];\n        }\n        token = state.push(\"tr_open\", \"tr\", 1);\n        token.map = [nextLine, nextLine + 1];\n        for (i = 0; i < columnCount; i++) {\n          token = state.push(\"td_open\", \"td\", 1);\n          if (aligns[i]) {\n            token.attrs = [[\"style\", \"text-align:\" + aligns[i]]];\n          }\n          token = state.push(\"inline\", \"\", 0);\n          token.content = columns[i] ? columns[i].trim() : \"\";\n          token.children = [];\n          token = state.push(\"td_close\", \"td\", -1);\n        }\n        token = state.push(\"tr_close\", \"tr\", -1);\n      }\n      if (tbodyLines) {\n        token = state.push(\"tbody_close\", \"tbody\", -1);\n        tbodyLines[1] = nextLine;\n      }\n      token = state.push(\"table_close\", \"table\", -1);\n      tableLines[1] = nextLine;\n      state.parentType = oldParentType;\n      state.line = nextLine;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/code.js\nvar require_code = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/code.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function code2(state, startLine, endLine) {\n      if (state.md.options.allowIndentation) {\n        return false;\n      }\n      var nextLine, last, token;\n      if (state.sCount[startLine] - state.blkIndent < 4) {\n        return false;\n      }\n      last = nextLine = startLine + 1;\n      while (nextLine < endLine) {\n        if (state.isEmpty(nextLine)) {\n          nextLine++;\n          continue;\n        }\n        if (state.sCount[nextLine] - state.blkIndent >= 4) {\n          nextLine++;\n          last = nextLine;\n          continue;\n        }\n        break;\n      }\n      state.line = last;\n      token = state.push(\"code_block\", \"code\", 0);\n      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + \"\\n\";\n      token.map = [startLine, state.line];\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/fence.js\nvar require_fence = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/fence.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function fence3(state, startLine, endLine, silent) {\n      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (pos + 3 > max2) {\n        return false;\n      }\n      marker = state.src.charCodeAt(pos);\n      if (marker !== 126 && marker !== 96) {\n        return false;\n      }\n      mem = pos;\n      pos = state.skipChars(pos, marker);\n      len = pos - mem;\n      if (len < 3) {\n        return false;\n      }\n      markup = state.src.slice(mem, pos);\n      params = state.src.slice(pos, max2);\n      if (marker === 96) {\n        if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n          return false;\n        }\n      }\n      if (silent) {\n        return true;\n      }\n      nextLine = startLine;\n      for (; ; ) {\n        nextLine++;\n        if (nextLine >= endLine) {\n          break;\n        }\n        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n        max2 = state.eMarks[nextLine];\n        if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        if (state.src.charCodeAt(pos) !== marker) {\n          continue;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {\n          continue;\n        }\n        pos = state.skipChars(pos, marker);\n        if (pos - mem < len) {\n          continue;\n        }\n        pos = state.skipSpaces(pos);\n        if (pos < max2) {\n          continue;\n        }\n        haveEndMarker = true;\n        break;\n      }\n      len = state.sCount[startLine];\n      state.line = nextLine + (haveEndMarker ? 1 : 0);\n      token = state.push(\"fence\", \"code\", 0);\n      token.info = params;\n      token.content = state.getLines(startLine + 1, nextLine, len, true);\n      token.markup = markup;\n      token.map = [startLine, state.line];\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/blockquote.js\nvar require_blockquote = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/blockquote.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function blockquote2(state, startLine, endLine, silent) {\n      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos++) !== 62) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      initial = offset = state.sCount[startLine] + 1;\n      if (state.src.charCodeAt(pos) === 32) {\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 9) {\n        spaceAfterMarker = true;\n        if ((state.bsCount[startLine] + offset) % 4 === 3) {\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n      oldBMarks = [state.bMarks[startLine]];\n      state.bMarks[startLine] = pos;\n      while (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (isSpace(ch)) {\n          if (ch === 9) {\n            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n        pos++;\n      }\n      oldBSCount = [state.bsCount[startLine]];\n      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n      lastLineEmpty = pos >= max2;\n      oldSCount = [state.sCount[startLine]];\n      state.sCount[startLine] = offset - initial;\n      oldTShift = [state.tShift[startLine]];\n      state.tShift[startLine] = pos - state.bMarks[startLine];\n      terminatorRules = state.md.block.ruler.getRules(\"blockquote\");\n      oldParentType = state.parentType;\n      state.parentType = \"blockquote\";\n      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n        isOutdented = state.sCount[nextLine] < state.blkIndent;\n        pos = state.bMarks[nextLine] + state.tShift[nextLine];\n        max2 = state.eMarks[nextLine];\n        if (pos >= max2) {\n          break;\n        }\n        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {\n          initial = offset = state.sCount[nextLine] + 1;\n          if (state.src.charCodeAt(pos) === 32) {\n            pos++;\n            initial++;\n            offset++;\n            adjustTab = false;\n            spaceAfterMarker = true;\n          } else if (state.src.charCodeAt(pos) === 9) {\n            spaceAfterMarker = true;\n            if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n              pos++;\n              initial++;\n              offset++;\n              adjustTab = false;\n            } else {\n              adjustTab = true;\n            }\n          } else {\n            spaceAfterMarker = false;\n          }\n          oldBMarks.push(state.bMarks[nextLine]);\n          state.bMarks[nextLine] = pos;\n          while (pos < max2) {\n            ch = state.src.charCodeAt(pos);\n            if (isSpace(ch)) {\n              if (ch === 9) {\n                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n              } else {\n                offset++;\n              }\n            } else {\n              break;\n            }\n            pos++;\n          }\n          lastLineEmpty = pos >= max2;\n          oldBSCount.push(state.bsCount[nextLine]);\n          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] = offset - initial;\n          oldTShift.push(state.tShift[nextLine]);\n          state.tShift[nextLine] = pos - state.bMarks[nextLine];\n          continue;\n        }\n        if (lastLineEmpty) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          state.lineMax = nextLine;\n          if (state.blkIndent !== 0) {\n            oldBMarks.push(state.bMarks[nextLine]);\n            oldBSCount.push(state.bsCount[nextLine]);\n            oldTShift.push(state.tShift[nextLine]);\n            oldSCount.push(state.sCount[nextLine]);\n            state.sCount[nextLine] -= state.blkIndent;\n          }\n          break;\n        }\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = -1;\n      }\n      oldIndent = state.blkIndent;\n      state.blkIndent = 0;\n      token = state.push(\"blockquote_open\", \"blockquote\", 1);\n      token.markup = \">\";\n      token.map = lines = [startLine, 0];\n      state.md.block.tokenize(state, startLine, nextLine);\n      token = state.push(\"blockquote_close\", \"blockquote\", -1);\n      token.markup = \">\";\n      state.lineMax = oldLineMax;\n      state.parentType = oldParentType;\n      lines[1] = state.line;\n      for (i = 0; i < oldTShift.length; i++) {\n        state.bMarks[i + startLine] = oldBMarks[i];\n        state.tShift[i + startLine] = oldTShift[i];\n        state.sCount[i + startLine] = oldSCount[i];\n        state.bsCount[i + startLine] = oldBSCount[i];\n      }\n      state.blkIndent = oldIndent;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/hr.js\nvar require_hr = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/hr.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function hr2(state, startLine, endLine, silent) {\n      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      marker = state.src.charCodeAt(pos++);\n      if (marker !== 42 && marker !== 45 && marker !== 95) {\n        return false;\n      }\n      cnt = 1;\n      while (pos < max2) {\n        ch = state.src.charCodeAt(pos++);\n        if (ch !== marker && !isSpace(ch)) {\n          return false;\n        }\n        if (ch === marker) {\n          cnt++;\n        }\n      }\n      if (cnt < 3) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      state.line = startLine + 1;\n      token = state.push(\"hr\", \"hr\", 0);\n      token.map = [startLine, state.line];\n      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/list.js\nvar require_list = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/list.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    function skipBulletListMarker(state, startLine) {\n      var marker, pos, max2, ch;\n      pos = state.bMarks[startLine] + state.tShift[startLine];\n      max2 = state.eMarks[startLine];\n      marker = state.src.charCodeAt(pos++);\n      if (marker !== 42 && marker !== 45 && marker !== 43) {\n        return -1;\n      }\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          return -1;\n        }\n      }\n      return pos;\n    }\n    function skipOrderedListMarker(state, startLine) {\n      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max2 = state.eMarks[startLine];\n      if (pos + 1 >= max2) {\n        return -1;\n      }\n      ch = state.src.charCodeAt(pos++);\n      if (ch < 48 || ch > 57) {\n        return -1;\n      }\n      for (; ; ) {\n        if (pos >= max2) {\n          return -1;\n        }\n        ch = state.src.charCodeAt(pos++);\n        if (ch >= 48 && ch <= 57) {\n          if (pos - start >= 10) {\n            return -1;\n          }\n          continue;\n        }\n        if (ch === 41 || ch === 46) {\n          break;\n        }\n        return -1;\n      }\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          return -1;\n        }\n      }\n      return pos;\n    }\n    function markTightParagraphs(state, idx) {\n      var i, l, level = state.level + 2;\n      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n        if (state.tokens[i].level === level && state.tokens[i].type === \"paragraph_open\") {\n          state.tokens[i + 2].hidden = true;\n          state.tokens[i].hidden = true;\n          i += 2;\n        }\n      }\n    }\n    module.exports = function list2(state, startLine, endLine, silent) {\n      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n        return false;\n      }\n      if (silent && state.parentType === \"paragraph\") {\n        if (state.sCount[startLine] >= state.blkIndent) {\n          isTerminatingParagraph = true;\n        }\n      }\n      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n        isOrdered = true;\n        start = state.bMarks[startLine] + state.tShift[startLine];\n        markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n        if (isTerminatingParagraph && markerValue !== 1)\n          return false;\n      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n        isOrdered = false;\n      } else {\n        return false;\n      }\n      if (isTerminatingParagraph) {\n        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])\n          return false;\n      }\n      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n      if (silent) {\n        return true;\n      }\n      listTokIdx = state.tokens.length;\n      if (isOrdered) {\n        token = state.push(\"ordered_list_open\", \"ol\", 1);\n        if (markerValue !== 1) {\n          token.attrs = [[\"start\", markerValue]];\n        }\n      } else {\n        token = state.push(\"bullet_list_open\", \"ul\", 1);\n      }\n      token.map = listLines = [startLine, 0];\n      token.markup = String.fromCharCode(markerCharCode);\n      nextLine = startLine;\n      prevEmptyEnd = false;\n      terminatorRules = state.md.block.ruler.getRules(\"list\");\n      oldParentType = state.parentType;\n      state.parentType = \"list\";\n      while (nextLine < endLine) {\n        pos = posAfterMarker;\n        max2 = state.eMarks[nextLine];\n        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n        while (pos < max2) {\n          ch = state.src.charCodeAt(pos);\n          if (ch === 9) {\n            offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n          } else if (ch === 32) {\n            offset++;\n          } else {\n            break;\n          }\n          pos++;\n        }\n        contentStart = pos;\n        if (contentStart >= max2) {\n          indentAfterMarker = 1;\n        } else {\n          indentAfterMarker = offset - initial;\n        }\n        if (!state.md.options.allowIndentation && indentAfterMarker > 4) {\n          indentAfterMarker = 1;\n        }\n        indent = initial + indentAfterMarker;\n        token = state.push(\"list_item_open\", \"li\", 1);\n        token.markup = String.fromCharCode(markerCharCode);\n        token.map = itemLines = [startLine, 0];\n        if (isOrdered) {\n          token.info = state.src.slice(start, posAfterMarker - 1);\n        }\n        oldTight = state.tight;\n        oldTShift = state.tShift[startLine];\n        oldSCount = state.sCount[startLine];\n        oldListIndent = state.listIndent;\n        state.listIndent = state.blkIndent;\n        state.blkIndent = indent;\n        state.tight = true;\n        state.tShift[startLine] = contentStart - state.bMarks[startLine];\n        state.sCount[startLine] = offset;\n        if (contentStart >= max2 && state.isEmpty(startLine + 1)) {\n          state.line = Math.min(state.line + 2, endLine);\n        } else {\n          state.md.block.tokenize(state, startLine, endLine, true);\n        }\n        if (!state.tight || prevEmptyEnd) {\n          tight = false;\n        }\n        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n        state.blkIndent = state.listIndent;\n        state.listIndent = oldListIndent;\n        state.tShift[startLine] = oldTShift;\n        state.sCount[startLine] = oldSCount;\n        state.tight = oldTight;\n        token = state.push(\"list_item_close\", \"li\", -1);\n        token.markup = String.fromCharCode(markerCharCode);\n        nextLine = startLine = state.line;\n        itemLines[1] = nextLine;\n        contentStart = state.bMarks[startLine];\n        if (nextLine >= endLine) {\n          break;\n        }\n        if (state.sCount[nextLine] < state.blkIndent) {\n          break;\n        }\n        if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n          break;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n        if (isOrdered) {\n          posAfterMarker = skipOrderedListMarker(state, nextLine);\n          if (posAfterMarker < 0) {\n            break;\n          }\n          start = state.bMarks[nextLine] + state.tShift[nextLine];\n        } else {\n          posAfterMarker = skipBulletListMarker(state, nextLine);\n          if (posAfterMarker < 0) {\n            break;\n          }\n        }\n        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n          break;\n        }\n      }\n      if (isOrdered) {\n        token = state.push(\"ordered_list_close\", \"ol\", -1);\n      } else {\n        token = state.push(\"bullet_list_close\", \"ul\", -1);\n      }\n      token.markup = String.fromCharCode(markerCharCode);\n      listLines[1] = nextLine;\n      state.line = nextLine;\n      state.parentType = oldParentType;\n      if (tight) {\n        markTightParagraphs(state, listTokIdx);\n      }\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/reference.js\nvar require_reference = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/reference.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function reference(state, startLine, _endLine, silent) {\n      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) !== 91) {\n        return false;\n      }\n      while (++pos < max2) {\n        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {\n          if (pos + 1 === max2) {\n            return false;\n          }\n          if (state.src.charCodeAt(pos + 1) !== 58) {\n            return false;\n          }\n          break;\n        }\n      }\n      endLine = state.lineMax;\n      terminatorRules = state.md.block.ruler.getRules(\"reference\");\n      oldParentType = state.parentType;\n      state.parentType = \"reference\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      max2 = str.length;\n      for (pos = 1; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 91) {\n          return false;\n        } else if (ch === 93) {\n          labelEnd = pos;\n          break;\n        } else if (ch === 10) {\n          lines++;\n        } else if (ch === 92) {\n          pos++;\n          if (pos < max2 && str.charCodeAt(pos) === 10) {\n            lines++;\n          }\n        }\n      }\n      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {\n        return false;\n      }\n      for (pos = labelEnd + 2; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 10) {\n          lines++;\n        } else if (isSpace(ch)) {\n        } else {\n          break;\n        }\n      }\n      res = state.md.helpers.parseLinkDestination(str, pos, max2);\n      if (!res.ok) {\n        return false;\n      }\n      href = state.md.normalizeLink(res.str);\n      if (!state.md.validateLink(href)) {\n        return false;\n      }\n      pos = res.pos;\n      lines += res.lines;\n      destEndPos = pos;\n      destEndLineNo = lines;\n      start = pos;\n      for (; pos < max2; pos++) {\n        ch = str.charCodeAt(pos);\n        if (ch === 10) {\n          lines++;\n        } else if (isSpace(ch)) {\n        } else {\n          break;\n        }\n      }\n      res = state.md.helpers.parseLinkTitle(str, pos, max2);\n      if (pos < max2 && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n        lines += res.lines;\n      } else {\n        title = \"\";\n        pos = destEndPos;\n        lines = destEndLineNo;\n      }\n      while (pos < max2) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n        pos++;\n      }\n      if (pos < max2 && str.charCodeAt(pos) !== 10) {\n        if (title) {\n          title = \"\";\n          pos = destEndPos;\n          lines = destEndLineNo;\n          while (pos < max2) {\n            ch = str.charCodeAt(pos);\n            if (!isSpace(ch)) {\n              break;\n            }\n            pos++;\n          }\n        }\n      }\n      if (pos < max2 && str.charCodeAt(pos) !== 10) {\n        return false;\n      }\n      label = normalizeReference(str.slice(1, labelEnd));\n      if (!label) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      if (typeof state.env.references === \"undefined\") {\n        state.env.references = {};\n      }\n      if (typeof state.env.references[label] === \"undefined\") {\n        state.env.references[label] = { title, href };\n      }\n      state.parentType = oldParentType;\n      state.line = startLine + lines + 1;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/common/html_blocks.js\nvar require_html_blocks = __commonJS({\n  \"node_modules/markdown-it/lib/common/html_blocks.js\"(exports, module) {\n    \"use strict\";\n    module.exports = [\n      \"address\",\n      \"article\",\n      \"aside\",\n      \"base\",\n      \"basefont\",\n      \"blockquote\",\n      \"body\",\n      \"caption\",\n      \"center\",\n      \"col\",\n      \"colgroup\",\n      \"dd\",\n      \"details\",\n      \"dialog\",\n      \"dir\",\n      \"div\",\n      \"dl\",\n      \"dt\",\n      \"fieldset\",\n      \"figcaption\",\n      \"figure\",\n      \"footer\",\n      \"form\",\n      \"frame\",\n      \"frameset\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"head\",\n      \"header\",\n      \"hr\",\n      \"html\",\n      \"iframe\",\n      \"legend\",\n      \"li\",\n      \"link\",\n      \"main\",\n      \"menu\",\n      \"menuitem\",\n      \"nav\",\n      \"noframes\",\n      \"ol\",\n      \"optgroup\",\n      \"option\",\n      \"p\",\n      \"param\",\n      \"section\",\n      \"source\",\n      \"summary\",\n      \"table\",\n      \"tbody\",\n      \"td\",\n      \"tfoot\",\n      \"th\",\n      \"thead\",\n      \"title\",\n      \"tr\",\n      \"track\",\n      \"ul\"\n    ];\n  }\n});\n\n// node_modules/markdown-it/lib/common/html_re.js\nvar require_html_re = __commonJS({\n  \"node_modules/markdown-it/lib/common/html_re.js\"(exports, module) {\n    \"use strict\";\n    var attr_name = \"[a-zA-Z_:][a-zA-Z0-9:._-]*\";\n    var unquoted = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\n    var single_quoted = \"'[^']*'\";\n    var double_quoted = '\"[^\"]*\"';\n    var attr_value = \"(?:\" + unquoted + \"|\" + single_quoted + \"|\" + double_quoted + \")\";\n    var attribute = \"(?:\\\\s+\" + attr_name + \"(?:\\\\s*=\\\\s*\" + attr_value + \")?)\";\n    var open_tag = \"<[A-Za-z][A-Za-z0-9\\\\-]*\" + attribute + \"*\\\\s*\\\\/?>\";\n    var close_tag = \"<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>\";\n    var comment = \"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->\";\n    var processing = \"<[?][\\\\s\\\\S]*?[?]>\";\n    var declaration = \"<![A-Z]+\\\\s+[^>]*>\";\n    var cdata = \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\";\n    var HTML_TAG_RE = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \"|\" + comment + \"|\" + processing + \"|\" + declaration + \"|\" + cdata + \")\");\n    var HTML_OPEN_CLOSE_TAG_RE = new RegExp(\"^(?:\" + open_tag + \"|\" + close_tag + \")\");\n    module.exports.HTML_TAG_RE = HTML_TAG_RE;\n    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/html_block.js\nvar require_html_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/html_block.js\"(exports, module) {\n    \"use strict\";\n    var block_names = require_html_blocks();\n    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;\n    var HTML_SEQUENCES = [\n      [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n      [/^<!--/, /-->/, true],\n      [/^<\\?/, /\\?>/, true],\n      [/^<![A-Z]/, />/, true],\n      [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n      [new RegExp(\"^</?(\" + block_names.join(\"|\") + \")(?=(\\\\s|/?>|$))\", \"i\"), /^$/, true],\n      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + \"\\\\s*$\"), /^$/, false]\n    ];\n    module.exports = function html_block(state, startLine, endLine, silent) {\n      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      if (!state.md.options.html) {\n        return false;\n      }\n      if (state.src.charCodeAt(pos) !== 60) {\n        return false;\n      }\n      lineText = state.src.slice(pos, max2);\n      for (i = 0; i < HTML_SEQUENCES.length; i++) {\n        if (HTML_SEQUENCES[i][0].test(lineText)) {\n          break;\n        }\n      }\n      if (i === HTML_SEQUENCES.length) {\n        return false;\n      }\n      if (silent) {\n        return HTML_SEQUENCES[i][2];\n      }\n      nextLine = startLine + 1;\n      if (!HTML_SEQUENCES[i][1].test(lineText)) {\n        for (; nextLine < endLine; nextLine++) {\n          if (state.sCount[nextLine] < state.blkIndent) {\n            break;\n          }\n          pos = state.bMarks[nextLine] + state.tShift[nextLine];\n          max2 = state.eMarks[nextLine];\n          lineText = state.src.slice(pos, max2);\n          if (HTML_SEQUENCES[i][1].test(lineText)) {\n            if (lineText.length !== 0) {\n              nextLine++;\n            }\n            break;\n          }\n        }\n      }\n      state.line = nextLine;\n      token = state.push(\"html_block\", \"\", 0);\n      token.map = [startLine, nextLine];\n      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/heading.js\nvar require_heading = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/heading.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function heading2(state, startLine, endLine, silent) {\n      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      ch = state.src.charCodeAt(pos);\n      if (ch !== 35 || pos >= max2) {\n        return false;\n      }\n      level = 1;\n      ch = state.src.charCodeAt(++pos);\n      while (ch === 35 && pos < max2 && level <= 6) {\n        level++;\n        ch = state.src.charCodeAt(++pos);\n      }\n      if (level > 6 || pos < max2 && !isSpace(ch)) {\n        return false;\n      }\n      if (silent) {\n        return true;\n      }\n      max2 = state.skipSpacesBack(max2, pos);\n      tmp = state.skipCharsBack(max2, 35, pos);\n      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {\n        max2 = tmp;\n      }\n      state.line = startLine + 1;\n      token = state.push(\"heading_open\", \"h\" + String(level), 1);\n      token.markup = \"########\".slice(0, level);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = state.src.slice(pos, max2).trim();\n      token.map = [startLine, state.line];\n      token.children = [];\n      token = state.push(\"heading_close\", \"h\" + String(level), -1);\n      token.markup = \"########\".slice(0, level);\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/lheading.js\nvar require_lheading = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/lheading.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function lheading(state, startLine, endLine) {\n      var content, terminate, i, l, token, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules(\"paragraph\");\n      if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {\n        return false;\n      }\n      oldParentType = state.parentType;\n      state.parentType = \"paragraph\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] >= state.blkIndent) {\n          pos = state.bMarks[nextLine] + state.tShift[nextLine];\n          max2 = state.eMarks[nextLine];\n          if (pos < max2) {\n            marker = state.src.charCodeAt(pos);\n            if (marker === 45 || marker === 61) {\n              pos = state.skipChars(pos, marker);\n              pos = state.skipSpaces(pos);\n              if (pos >= max2) {\n                level = marker === 61 ? 1 : 2;\n                break;\n              }\n            }\n          }\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      if (!level) {\n        return false;\n      }\n      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      state.line = nextLine + 1;\n      token = state.push(\"heading_open\", \"h\" + String(level), 1);\n      token.markup = String.fromCharCode(marker);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = content;\n      token.map = [startLine, state.line - 1];\n      token.children = [];\n      token = state.push(\"heading_close\", \"h\" + String(level), -1);\n      token.markup = String.fromCharCode(marker);\n      state.parentType = oldParentType;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/paragraph.js\nvar require_paragraph = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/paragraph.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function paragraph2(state, startLine) {\n      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules(\"paragraph\"), endLine = state.lineMax;\n      oldParentType = state.parentType;\n      state.parentType = \"paragraph\";\n      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n        if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {\n          continue;\n        }\n        if (state.sCount[nextLine] < 0) {\n          continue;\n        }\n        terminate = false;\n        for (i = 0, l = terminatorRules.length; i < l; i++) {\n          if (terminatorRules[i](state, nextLine, endLine, true)) {\n            terminate = true;\n            break;\n          }\n        }\n        if (terminate) {\n          break;\n        }\n      }\n      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n      state.line = nextLine;\n      token = state.push(\"paragraph_open\", \"p\", 1);\n      token.map = [startLine, state.line];\n      token = state.push(\"inline\", \"\", 0);\n      token.content = content;\n      token.map = [startLine, state.line];\n      token.children = [];\n      token = state.push(\"paragraph_close\", \"p\", -1);\n      state.parentType = oldParentType;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_block/state_block.js\nvar require_state_block = __commonJS({\n  \"node_modules/markdown-it/lib/rules_block/state_block.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    var isSpace = require_utils().isSpace;\n    function StateBlock(src, md, env, tokens) {\n      var ch, s2, start, pos, len, indent, offset, indent_found;\n      this.src = src;\n      this.md = md;\n      this.env = env;\n      this.tokens = tokens;\n      this.bMarks = [];\n      this.eMarks = [];\n      this.tShift = [];\n      this.sCount = [];\n      this.bsCount = [];\n      this.blkIndent = 0;\n      this.line = 0;\n      this.lineMax = 0;\n      this.tight = false;\n      this.ddIndent = -1;\n      this.listIndent = -1;\n      this.parentType = \"root\";\n      this.level = 0;\n      this.result = \"\";\n      s2 = this.src;\n      indent_found = false;\n      for (start = pos = indent = offset = 0, len = s2.length; pos < len; pos++) {\n        ch = s2.charCodeAt(pos);\n        if (!indent_found) {\n          if (isSpace(ch)) {\n            indent++;\n            if (ch === 9) {\n              offset += 4 - offset % 4;\n            } else {\n              offset++;\n            }\n            continue;\n          } else {\n            indent_found = true;\n          }\n        }\n        if (ch === 10 || pos === len - 1) {\n          if (ch !== 10) {\n            pos++;\n          }\n          this.bMarks.push(start);\n          this.eMarks.push(pos);\n          this.tShift.push(indent);\n          this.sCount.push(offset);\n          this.bsCount.push(0);\n          indent_found = false;\n          indent = 0;\n          offset = 0;\n          start = pos + 1;\n        }\n      }\n      this.bMarks.push(s2.length);\n      this.eMarks.push(s2.length);\n      this.tShift.push(0);\n      this.sCount.push(0);\n      this.bsCount.push(0);\n      this.lineMax = this.bMarks.length - 1;\n    }\n    StateBlock.prototype.push = function(type, tag, nesting) {\n      var token = new Token(type, tag, nesting);\n      token.block = true;\n      if (nesting < 0)\n        this.level--;\n      token.level = this.level;\n      if (nesting > 0)\n        this.level++;\n      this.tokens.push(token);\n      return token;\n    };\n    StateBlock.prototype.isEmpty = function isEmpty(line) {\n      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n    };\n    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n      for (var max2 = this.lineMax; from < max2; from++) {\n        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n          break;\n        }\n      }\n      return from;\n    };\n    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n      var ch;\n      for (var max2 = this.src.length; pos < max2; pos++) {\n        ch = this.src.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n      if (pos <= min) {\n        return pos;\n      }\n      while (pos > min) {\n        if (!isSpace(this.src.charCodeAt(--pos))) {\n          return pos + 1;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipChars = function skipChars(pos, code2) {\n      for (var max2 = this.src.length; pos < max2; pos++) {\n        if (this.src.charCodeAt(pos) !== code2) {\n          break;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {\n      if (pos <= min) {\n        return pos;\n      }\n      while (pos > min) {\n        if (code2 !== this.src.charCodeAt(--pos)) {\n          return pos + 1;\n        }\n      }\n      return pos;\n    };\n    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;\n      if (begin >= end) {\n        return \"\";\n      }\n      queue = new Array(end - begin);\n      for (i = 0; line < end; line++, i++) {\n        lineIndent = 0;\n        lineStart = first = this.bMarks[line];\n        if (line + 1 < end || keepLastLF) {\n          last = this.eMarks[line] + 1;\n        } else {\n          last = this.eMarks[line];\n        }\n        while (first < last && lineIndent < indent) {\n          ch = this.src.charCodeAt(first);\n          if (isSpace(ch)) {\n            if (ch === 9) {\n              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n            } else {\n              lineIndent++;\n            }\n          } else if (first - lineStart < this.tShift[line]) {\n            lineIndent++;\n          } else {\n            break;\n          }\n          first++;\n        }\n        if (lineIndent > indent) {\n          queue[i] = new Array(lineIndent - indent + 1).join(\" \") + this.src.slice(first, last);\n        } else {\n          queue[i] = this.src.slice(first, last);\n        }\n      }\n      return queue.join(\"\");\n    };\n    StateBlock.prototype.Token = Token;\n    module.exports = StateBlock;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_block.js\nvar require_parser_block = __commonJS({\n  \"node_modules/markdown-it/lib/parser_block.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"table\", require_table(), [\"paragraph\", \"reference\"]],\n      [\"code\", require_code()],\n      [\"fence\", require_fence(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"blockquote\", require_blockquote(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"hr\", require_hr(), [\"paragraph\", \"reference\", \"blockquote\", \"list\"]],\n      [\"list\", require_list(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"reference\", require_reference()],\n      [\"html_block\", require_html_block(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"heading\", require_heading(), [\"paragraph\", \"reference\", \"blockquote\"]],\n      [\"lheading\", require_lheading()],\n      [\"paragraph\", require_paragraph()]\n    ];\n    function ParserBlock() {\n      this.ruler = new Ruler();\n      for (var i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n      }\n    }\n    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {\n      var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;\n      while (line < endLine) {\n        state.line = line = state.skipEmptyLines(line);\n        if (line >= endLine) {\n          break;\n        }\n        if (state.sCount[line] < state.blkIndent) {\n          break;\n        }\n        if (state.level >= maxNesting) {\n          state.line = endLine;\n          break;\n        }\n        for (i = 0; i < len; i++) {\n          ok = rules[i](state, line, endLine, false);\n          if (ok) {\n            break;\n          }\n        }\n        state.tight = !hasEmptyLines;\n        if (state.isEmpty(state.line - 1)) {\n          hasEmptyLines = true;\n        }\n        line = state.line;\n        if (line < endLine && state.isEmpty(line)) {\n          hasEmptyLines = true;\n          line++;\n          state.line = line;\n        }\n      }\n    };\n    ParserBlock.prototype.parse = function(src, md, env, outTokens) {\n      var state;\n      if (!src) {\n        return;\n      }\n      state = new this.State(src, md, env, outTokens);\n      this.tokenize(state, state.line, state.lineMax);\n    };\n    ParserBlock.prototype.State = require_state_block();\n    module.exports = ParserBlock;\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/text.js\nvar require_text = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/text.js\"(exports, module) {\n    \"use strict\";\n    function isTerminatorChar(ch) {\n      switch (ch) {\n        case 10:\n        case 33:\n        case 35:\n        case 36:\n        case 37:\n        case 38:\n        case 42:\n        case 43:\n        case 45:\n        case 58:\n        case 60:\n        case 61:\n        case 62:\n        case 64:\n        case 91:\n        case 92:\n        case 93:\n        case 94:\n        case 95:\n        case 96:\n        case 123:\n        case 125:\n        case 126:\n          return true;\n        default:\n          return false;\n      }\n    }\n    module.exports = function text2(state, silent) {\n      var pos = state.pos;\n      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n        pos++;\n      }\n      if (pos === state.pos) {\n        return false;\n      }\n      if (!silent) {\n        state.pending += state.src.slice(state.pos, pos);\n      }\n      state.pos = pos;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/newline.js\nvar require_newline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/newline.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    module.exports = function newline(state, silent) {\n      var pmax, max2, ws, pos = state.pos;\n      if (state.src.charCodeAt(pos) !== 10) {\n        return false;\n      }\n      pmax = state.pending.length - 1;\n      max2 = state.posMax;\n      if (!silent) {\n        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {\n          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {\n            ws = pmax - 1;\n            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)\n              ws--;\n            state.pending = state.pending.slice(0, ws);\n            state.push(\"hardbreak\", \"br\", 0);\n          } else {\n            state.pending = state.pending.slice(0, -1);\n            state.push(\"softbreak\", \"br\", 0);\n          }\n        } else {\n          state.push(\"softbreak\", \"br\", 0);\n        }\n      }\n      pos++;\n      while (pos < max2 && isSpace(state.src.charCodeAt(pos))) {\n        pos++;\n      }\n      state.pos = pos;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/escape.js\nvar require_escape = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/escape.js\"(exports, module) {\n    \"use strict\";\n    var isSpace = require_utils().isSpace;\n    var ESCAPED = [];\n    for (i = 0; i < 256; i++) {\n      ESCAPED.push(0);\n    }\n    var i;\n    \"\\\\!\\\"#$%&'()*+,./:;<=>?@[]^_`{|}~-\".split(\"\").forEach(function(ch) {\n      ESCAPED[ch.charCodeAt(0)] = 1;\n    });\n    module.exports = function escape(state, silent) {\n      var ch, pos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 92) {\n        return false;\n      }\n      pos++;\n      if (pos < max2) {\n        ch = state.src.charCodeAt(pos);\n        if (ch < 256 && ESCAPED[ch] !== 0) {\n          if (!silent) {\n            state.pending += state.src[pos];\n          }\n          state.pos += 2;\n          return true;\n        }\n        if (ch === 10) {\n          if (!silent) {\n            state.push(\"hardbreak\", \"br\", 0);\n          }\n          pos++;\n          while (pos < max2) {\n            ch = state.src.charCodeAt(pos);\n            if (!isSpace(ch)) {\n              break;\n            }\n            pos++;\n          }\n          state.pos = pos;\n          return true;\n        }\n      }\n      if (!silent) {\n        state.pending += \"\\\\\";\n      }\n      state.pos++;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/backticks.js\nvar require_backticks = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/backticks.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function backtick(state, silent) {\n      var start, max2, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);\n      if (ch !== 96) {\n        return false;\n      }\n      start = pos;\n      pos++;\n      max2 = state.posMax;\n      while (pos < max2 && state.src.charCodeAt(pos) === 96) {\n        pos++;\n      }\n      marker = state.src.slice(start, pos);\n      openerLength = marker.length;\n      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n        if (!silent)\n          state.pending += marker;\n        state.pos += openerLength;\n        return true;\n      }\n      matchStart = matchEnd = pos;\n      while ((matchStart = state.src.indexOf(\"`\", matchEnd)) !== -1) {\n        matchEnd = matchStart + 1;\n        while (matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96) {\n          matchEnd++;\n        }\n        closerLength = matchEnd - matchStart;\n        if (closerLength === openerLength) {\n          if (!silent) {\n            token = state.push(\"code_inline\", \"code\", 0);\n            token.markup = marker;\n            token.content = state.src.slice(pos, matchStart).replace(/\\n/g, \" \").replace(/^ (.+) $/, \"$1\");\n          }\n          state.pos = matchEnd;\n          return true;\n        }\n        state.backticks[closerLength] = matchStart;\n      }\n      state.backticksScanned = true;\n      if (!silent)\n        state.pending += marker;\n      state.pos += openerLength;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/strikethrough.js\nvar require_strikethrough = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/strikethrough.js\"(exports, module) {\n    \"use strict\";\n    module.exports.tokenize = function strikethrough(state, silent) {\n      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);\n      if (silent) {\n        return false;\n      }\n      if (marker !== 126) {\n        return false;\n      }\n      scanned = state.scanDelims(state.pos, true);\n      len = scanned.length;\n      ch = String.fromCharCode(marker);\n      if (len < 2) {\n        return false;\n      }\n      if (len % 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch;\n        len--;\n      }\n      for (i = 0; i < len; i += 2) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = ch + ch;\n        state.delimiters.push({\n          marker,\n          length: 0,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close\n        });\n      }\n      state.pos += scanned.length;\n      return true;\n    };\n    function postProcess(state, delimiters) {\n      var i, j, startDelim, endDelim, token, loneMarkers = [], max2 = delimiters.length;\n      for (i = 0; i < max2; i++) {\n        startDelim = delimiters[i];\n        if (startDelim.marker !== 126) {\n          continue;\n        }\n        if (startDelim.end === -1) {\n          continue;\n        }\n        endDelim = delimiters[startDelim.end];\n        token = state.tokens[startDelim.token];\n        token.type = \"s_open\";\n        token.tag = \"s\";\n        token.nesting = 1;\n        token.markup = \"~~\";\n        token.content = \"\";\n        token = state.tokens[endDelim.token];\n        token.type = \"s_close\";\n        token.tag = \"s\";\n        token.nesting = -1;\n        token.markup = \"~~\";\n        token.content = \"\";\n        if (state.tokens[endDelim.token - 1].type === \"text\" && state.tokens[endDelim.token - 1].content === \"~\") {\n          loneMarkers.push(endDelim.token - 1);\n        }\n      }\n      while (loneMarkers.length) {\n        i = loneMarkers.pop();\n        j = i + 1;\n        while (j < state.tokens.length && state.tokens[j].type === \"s_close\") {\n          j++;\n        }\n        j--;\n        if (i !== j) {\n          token = state.tokens[j];\n          state.tokens[j] = state.tokens[i];\n          state.tokens[i] = token;\n        }\n      }\n    }\n    module.exports.postProcess = function strikethrough(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      postProcess(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          postProcess(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/emphasis.js\nvar require_emphasis = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/emphasis.js\"(exports, module) {\n    \"use strict\";\n    module.exports.tokenize = function emphasis(state, silent) {\n      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);\n      if (silent) {\n        return false;\n      }\n      if (marker !== 95 && marker !== 42) {\n        return false;\n      }\n      scanned = state.scanDelims(state.pos, marker === 42);\n      for (i = 0; i < scanned.length; i++) {\n        token = state.push(\"text\", \"\", 0);\n        token.content = String.fromCharCode(marker);\n        state.delimiters.push({\n          marker,\n          length: scanned.length,\n          token: state.tokens.length - 1,\n          end: -1,\n          open: scanned.can_open,\n          close: scanned.can_close\n        });\n      }\n      state.pos += scanned.length;\n      return true;\n    };\n    function postProcess(state, delimiters) {\n      var i, startDelim, endDelim, token, ch, isStrong, max2 = delimiters.length;\n      for (i = max2 - 1; i >= 0; i--) {\n        startDelim = delimiters[i];\n        if (startDelim.marker !== 95 && startDelim.marker !== 42) {\n          continue;\n        }\n        if (startDelim.end === -1) {\n          continue;\n        }\n        endDelim = delimiters[startDelim.end];\n        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;\n        ch = String.fromCharCode(startDelim.marker);\n        token = state.tokens[startDelim.token];\n        token.type = isStrong ? \"strong_open\" : \"em_open\";\n        token.tag = isStrong ? \"strong\" : \"em\";\n        token.nesting = 1;\n        token.markup = isStrong ? ch + ch : ch;\n        token.content = \"\";\n        token = state.tokens[endDelim.token];\n        token.type = isStrong ? \"strong_close\" : \"em_close\";\n        token.tag = isStrong ? \"strong\" : \"em\";\n        token.nesting = -1;\n        token.markup = isStrong ? ch + ch : ch;\n        token.content = \"\";\n        if (isStrong) {\n          state.tokens[delimiters[i - 1].token].content = \"\";\n          state.tokens[delimiters[startDelim.end + 1].token].content = \"\";\n          i--;\n        }\n      }\n    }\n    module.exports.postProcess = function emphasis(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      postProcess(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          postProcess(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/link.js\nvar require_link = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/link.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function link2(state, silent) {\n      var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token, href = \"\", title = \"\", oldPos = state.pos, max2 = state.posMax, start = state.pos, parseReference = true;\n      if (state.src.charCodeAt(state.pos) !== 91) {\n        return false;\n      }\n      labelStart = state.pos + 1;\n      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n      if (labelEnd < 0) {\n        return false;\n      }\n      pos = labelEnd + 1;\n      if (pos < max2 && state.src.charCodeAt(pos) === 40) {\n        parseReference = false;\n        pos++;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        if (pos >= max2) {\n          return false;\n        }\n        start = pos;\n        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n        if (res.ok) {\n          href = state.md.normalizeLink(res.str);\n          if (state.md.validateLink(href)) {\n            pos = res.pos;\n          } else {\n            href = \"\";\n          }\n          start = pos;\n          for (; pos < max2; pos++) {\n            code2 = state.src.charCodeAt(pos);\n            if (!isSpace(code2) && code2 !== 10) {\n              break;\n            }\n          }\n          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n          if (pos < max2 && start !== pos && res.ok) {\n            title = res.str;\n            pos = res.pos;\n            for (; pos < max2; pos++) {\n              code2 = state.src.charCodeAt(pos);\n              if (!isSpace(code2) && code2 !== 10) {\n                break;\n              }\n            }\n          }\n        }\n        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {\n          parseReference = true;\n        }\n        pos++;\n      }\n      if (parseReference) {\n        if (typeof state.env.references === \"undefined\") {\n          return false;\n        }\n        if (pos < max2 && state.src.charCodeAt(pos) === 91) {\n          start = pos + 1;\n          pos = state.md.helpers.parseLinkLabel(state, pos);\n          if (pos >= 0) {\n            label = state.src.slice(start, pos++);\n          } else {\n            pos = labelEnd + 1;\n          }\n        } else {\n          pos = labelEnd + 1;\n        }\n        if (!label) {\n          label = state.src.slice(labelStart, labelEnd);\n        }\n        ref = state.env.references[normalizeReference(label)];\n        if (!ref) {\n          state.pos = oldPos;\n          return false;\n        }\n        href = ref.href;\n        title = ref.title;\n      }\n      if (!silent) {\n        state.pos = labelStart;\n        state.posMax = labelEnd;\n        token = state.push(\"link_open\", \"a\", 1);\n        token.attrs = attrs = [[\"href\", href]];\n        if (title) {\n          attrs.push([\"title\", title]);\n        }\n        state.md.inline.tokenize(state);\n        token = state.push(\"link_close\", \"a\", -1);\n      }\n      state.pos = pos;\n      state.posMax = max2;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/image.js\nvar require_image = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/image.js\"(exports, module) {\n    \"use strict\";\n    var normalizeReference = require_utils().normalizeReference;\n    var isSpace = require_utils().isSpace;\n    module.exports = function image2(state, silent) {\n      var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = \"\", oldPos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(state.pos) !== 33) {\n        return false;\n      }\n      if (state.src.charCodeAt(state.pos + 1) !== 91) {\n        return false;\n      }\n      labelStart = state.pos + 2;\n      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n      if (labelEnd < 0) {\n        return false;\n      }\n      pos = labelEnd + 1;\n      if (pos < max2 && state.src.charCodeAt(pos) === 40) {\n        pos++;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        if (pos >= max2) {\n          return false;\n        }\n        start = pos;\n        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n        if (res.ok) {\n          href = state.md.normalizeLink(res.str);\n          if (state.md.validateLink(href)) {\n            pos = res.pos;\n          } else {\n            href = \"\";\n          }\n        }\n        start = pos;\n        for (; pos < max2; pos++) {\n          code2 = state.src.charCodeAt(pos);\n          if (!isSpace(code2) && code2 !== 10) {\n            break;\n          }\n        }\n        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n        if (pos < max2 && start !== pos && res.ok) {\n          title = res.str;\n          pos = res.pos;\n          for (; pos < max2; pos++) {\n            code2 = state.src.charCodeAt(pos);\n            if (!isSpace(code2) && code2 !== 10) {\n              break;\n            }\n          }\n        } else {\n          title = \"\";\n        }\n        if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {\n          state.pos = oldPos;\n          return false;\n        }\n        pos++;\n      } else {\n        if (typeof state.env.references === \"undefined\") {\n          return false;\n        }\n        if (pos < max2 && state.src.charCodeAt(pos) === 91) {\n          start = pos + 1;\n          pos = state.md.helpers.parseLinkLabel(state, pos);\n          if (pos >= 0) {\n            label = state.src.slice(start, pos++);\n          } else {\n            pos = labelEnd + 1;\n          }\n        } else {\n          pos = labelEnd + 1;\n        }\n        if (!label) {\n          label = state.src.slice(labelStart, labelEnd);\n        }\n        ref = state.env.references[normalizeReference(label)];\n        if (!ref) {\n          state.pos = oldPos;\n          return false;\n        }\n        href = ref.href;\n        title = ref.title;\n      }\n      if (!silent) {\n        content = state.src.slice(labelStart, labelEnd);\n        state.md.inline.parse(content, state.md, state.env, tokens = []);\n        token = state.push(\"image\", \"img\", 0);\n        token.attrs = attrs = [[\"src\", href], [\"alt\", \"\"]];\n        token.children = tokens;\n        token.content = content;\n        if (title) {\n          attrs.push([\"title\", title]);\n        }\n      }\n      state.pos = pos;\n      state.posMax = max2;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/autolink.js\nvar require_autolink = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/autolink.js\"(exports, module) {\n    \"use strict\";\n    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;\n    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\\-]{1,31}):([^<>\\x00-\\x20]*)$/;\n    module.exports = function autolink(state, silent) {\n      var url, fullUrl, token, ch, start, max2, pos = state.pos;\n      if (state.src.charCodeAt(pos) !== 60) {\n        return false;\n      }\n      start = state.pos;\n      max2 = state.posMax;\n      for (; ; ) {\n        if (++pos >= max2)\n          return false;\n        ch = state.src.charCodeAt(pos);\n        if (ch === 60)\n          return false;\n        if (ch === 62)\n          break;\n      }\n      url = state.src.slice(start + 1, pos);\n      if (AUTOLINK_RE.test(url)) {\n        fullUrl = state.md.normalizeLink(url);\n        if (!state.md.validateLink(fullUrl)) {\n          return false;\n        }\n        if (!silent) {\n          token = state.push(\"link_open\", \"a\", 1);\n          token.attrs = [[\"href\", fullUrl]];\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n          token = state.push(\"text\", \"\", 0);\n          token.content = state.md.normalizeLinkText(url);\n          token = state.push(\"link_close\", \"a\", -1);\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n        }\n        state.pos += url.length + 2;\n        return true;\n      }\n      if (EMAIL_RE.test(url)) {\n        fullUrl = state.md.normalizeLink(\"mailto:\" + url);\n        if (!state.md.validateLink(fullUrl)) {\n          return false;\n        }\n        if (!silent) {\n          token = state.push(\"link_open\", \"a\", 1);\n          token.attrs = [[\"href\", fullUrl]];\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n          token = state.push(\"text\", \"\", 0);\n          token.content = state.md.normalizeLinkText(url);\n          token = state.push(\"link_close\", \"a\", -1);\n          token.markup = \"autolink\";\n          token.info = \"auto\";\n        }\n        state.pos += url.length + 2;\n        return true;\n      }\n      return false;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/html_inline.js\nvar require_html_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/html_inline.js\"(exports, module) {\n    \"use strict\";\n    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;\n    function isLetter(ch) {\n      var lc = ch | 32;\n      return lc >= 97 && lc <= 122;\n    }\n    module.exports = function html_inline(state, silent) {\n      var ch, match, max2, token, pos = state.pos;\n      if (!state.md.options.html) {\n        return false;\n      }\n      max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {\n        return false;\n      }\n      ch = state.src.charCodeAt(pos + 1);\n      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {\n        return false;\n      }\n      match = state.src.slice(pos).match(HTML_TAG_RE);\n      if (!match) {\n        return false;\n      }\n      if (!silent) {\n        token = state.push(\"html_inline\", \"\", 0);\n        token.content = state.src.slice(pos, pos + match[0].length);\n      }\n      state.pos += match[0].length;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/entity.js\nvar require_entity = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/entity.js\"(exports, module) {\n    \"use strict\";\n    var entities = require_entities2();\n    var has = require_utils().has;\n    var isValidEntityCode = require_utils().isValidEntityCode;\n    var fromCodePoint = require_utils().fromCodePoint;\n    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;\n    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n    module.exports = function entity(state, silent) {\n      var ch, code2, match, pos = state.pos, max2 = state.posMax;\n      if (state.src.charCodeAt(pos) !== 38) {\n        return false;\n      }\n      if (pos + 1 < max2) {\n        ch = state.src.charCodeAt(pos + 1);\n        if (ch === 35) {\n          match = state.src.slice(pos).match(DIGITAL_RE);\n          if (match) {\n            if (!silent) {\n              code2 = match[1][0].toLowerCase() === \"x\" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n              state.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);\n            }\n            state.pos += match[0].length;\n            return true;\n          }\n        } else {\n          match = state.src.slice(pos).match(NAMED_RE);\n          if (match) {\n            if (has(entities, match[1])) {\n              if (!silent) {\n                state.pending += entities[match[1]];\n              }\n              state.pos += match[0].length;\n              return true;\n            }\n          }\n        }\n      }\n      if (!silent) {\n        state.pending += \"&\";\n      }\n      state.pos++;\n      return true;\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/balance_pairs.js\nvar require_balance_pairs = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/balance_pairs.js\"(exports, module) {\n    \"use strict\";\n    function processDelimiters(state, delimiters) {\n      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;\n      if (!max2)\n        return;\n      var headerIdx = 0;\n      var lastTokenIdx = -2;\n      var jumps = [];\n      for (closerIdx = 0; closerIdx < max2; closerIdx++) {\n        closer = delimiters[closerIdx];\n        jumps.push(0);\n        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n          headerIdx = closerIdx;\n        }\n        lastTokenIdx = closer.token;\n        closer.length = closer.length || 0;\n        if (!closer.close)\n          continue;\n        if (!openersBottom.hasOwnProperty(closer.marker)) {\n          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n        }\n        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n        openerIdx = headerIdx - jumps[headerIdx] - 1;\n        newMinOpenerIdx = openerIdx;\n        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n          opener = delimiters[openerIdx];\n          if (opener.marker !== closer.marker)\n            continue;\n          if (opener.open && opener.end < 0) {\n            isOddMatch = false;\n            if (opener.close || closer.open) {\n              if ((opener.length + closer.length) % 3 === 0) {\n                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n                  isOddMatch = true;\n                }\n              }\n            }\n            if (!isOddMatch) {\n              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n              jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n              jumps[openerIdx] = lastJump;\n              closer.open = false;\n              opener.end = closerIdx;\n              opener.close = false;\n              newMinOpenerIdx = -1;\n              lastTokenIdx = -2;\n              break;\n            }\n          }\n        }\n        if (newMinOpenerIdx !== -1) {\n          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n        }\n      }\n    }\n    module.exports = function link_pairs(state) {\n      var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;\n      processDelimiters(state, state.delimiters);\n      for (curr = 0; curr < max2; curr++) {\n        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n          processDelimiters(state, tokens_meta[curr].delimiters);\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/text_collapse.js\nvar require_text_collapse = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/text_collapse.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function text_collapse(state) {\n      var curr, last, level = 0, tokens = state.tokens, max2 = state.tokens.length;\n      for (curr = last = 0; curr < max2; curr++) {\n        if (tokens[curr].nesting < 0)\n          level--;\n        tokens[curr].level = level;\n        if (tokens[curr].nesting > 0)\n          level++;\n        if (tokens[curr].type === \"text\" && curr + 1 < max2 && tokens[curr + 1].type === \"text\") {\n          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n        } else {\n          if (curr !== last) {\n            tokens[last] = tokens[curr];\n          }\n          last++;\n        }\n      }\n      if (curr !== last) {\n        tokens.length = last;\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/rules_inline/state_inline.js\nvar require_state_inline = __commonJS({\n  \"node_modules/markdown-it/lib/rules_inline/state_inline.js\"(exports, module) {\n    \"use strict\";\n    var Token = require_token();\n    var isWhiteSpace = require_utils().isWhiteSpace;\n    var isPunctChar = require_utils().isPunctChar;\n    var isMdAsciiPunct = require_utils().isMdAsciiPunct;\n    function StateInline(src, md, env, outTokens) {\n      this.src = src;\n      this.env = env;\n      this.md = md;\n      this.tokens = outTokens;\n      this.tokens_meta = Array(outTokens.length);\n      this.pos = 0;\n      this.posMax = this.src.length;\n      this.level = 0;\n      this.pending = \"\";\n      this.pendingLevel = 0;\n      this.cache = {};\n      this.delimiters = [];\n      this._prev_delimiters = [];\n      this.backticks = {};\n      this.backticksScanned = false;\n    }\n    StateInline.prototype.pushPending = function() {\n      var token = new Token(\"text\", \"\", 0);\n      token.content = this.pending;\n      token.level = this.pendingLevel;\n      this.tokens.push(token);\n      this.pending = \"\";\n      return token;\n    };\n    StateInline.prototype.push = function(type, tag, nesting) {\n      if (this.pending) {\n        this.pushPending();\n      }\n      var token = new Token(type, tag, nesting);\n      var token_meta = null;\n      if (nesting < 0) {\n        this.level--;\n        this.delimiters = this._prev_delimiters.pop();\n      }\n      token.level = this.level;\n      if (nesting > 0) {\n        this.level++;\n        this._prev_delimiters.push(this.delimiters);\n        this.delimiters = [];\n        token_meta = { delimiters: this.delimiters };\n      }\n      this.pendingLevel = this.level;\n      this.tokens.push(token);\n      this.tokens_meta.push(token_meta);\n      return token;\n    };\n    StateInline.prototype.scanDelims = function(start, canSplitWord) {\n      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start);\n      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;\n      while (pos < max2 && this.src.charCodeAt(pos) === marker) {\n        pos++;\n      }\n      count = pos - start;\n      nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n      if (isNextWhiteSpace) {\n        left_flanking = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          left_flanking = false;\n        }\n      }\n      if (isLastWhiteSpace) {\n        right_flanking = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          right_flanking = false;\n        }\n      }\n      if (!canSplitWord) {\n        can_open = left_flanking && (!right_flanking || isLastPunctChar);\n        can_close = right_flanking && (!left_flanking || isNextPunctChar);\n      } else {\n        can_open = left_flanking;\n        can_close = right_flanking;\n      }\n      return {\n        can_open,\n        can_close,\n        length: count\n      };\n    };\n    StateInline.prototype.Token = Token;\n    module.exports = StateInline;\n  }\n});\n\n// node_modules/markdown-it/lib/parser_inline.js\nvar require_parser_inline = __commonJS({\n  \"node_modules/markdown-it/lib/parser_inline.js\"(exports, module) {\n    \"use strict\";\n    var Ruler = require_ruler();\n    var _rules = [\n      [\"text\", require_text()],\n      [\"newline\", require_newline()],\n      [\"escape\", require_escape()],\n      [\"backticks\", require_backticks()],\n      [\"strikethrough\", require_strikethrough().tokenize],\n      [\"emphasis\", require_emphasis().tokenize],\n      [\"link\", require_link()],\n      [\"image\", require_image()],\n      [\"autolink\", require_autolink()],\n      [\"html_inline\", require_html_inline()],\n      [\"entity\", require_entity()]\n    ];\n    var _rules2 = [\n      [\"balance_pairs\", require_balance_pairs()],\n      [\"strikethrough\", require_strikethrough().postProcess],\n      [\"emphasis\", require_emphasis().postProcess],\n      [\"text_collapse\", require_text_collapse()]\n    ];\n    function ParserInline() {\n      var i;\n      this.ruler = new Ruler();\n      for (i = 0; i < _rules.length; i++) {\n        this.ruler.push(_rules[i][0], _rules[i][1]);\n      }\n      this.ruler2 = new Ruler();\n      for (i = 0; i < _rules2.length; i++) {\n        this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n      }\n    }\n    ParserInline.prototype.skipToken = function(state) {\n      var ok, i, pos = state.pos, rules = this.ruler.getRules(\"\"), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;\n      if (typeof cache[pos] !== \"undefined\") {\n        state.pos = cache[pos];\n        return;\n      }\n      if (state.level < maxNesting) {\n        for (i = 0; i < len; i++) {\n          state.level++;\n          ok = rules[i](state, true);\n          state.level--;\n          if (ok) {\n            break;\n          }\n        }\n      } else {\n        state.pos = state.posMax;\n      }\n      if (!ok) {\n        state.pos++;\n      }\n      cache[pos] = state.pos;\n    };\n    ParserInline.prototype.tokenize = function(state) {\n      var ok, i, rules = this.ruler.getRules(\"\"), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;\n      while (state.pos < end) {\n        if (state.level < maxNesting) {\n          for (i = 0; i < len; i++) {\n            ok = rules[i](state, false);\n            if (ok) {\n              break;\n            }\n          }\n        }\n        if (ok) {\n          if (state.pos >= end) {\n            break;\n          }\n          continue;\n        }\n        state.pending += state.src[state.pos++];\n      }\n      if (state.pending) {\n        state.pushPending();\n      }\n    };\n    ParserInline.prototype.parse = function(str, md, env, outTokens) {\n      var i, rules, len;\n      var state = new this.State(str, md, env, outTokens);\n      this.tokenize(state);\n      rules = this.ruler2.getRules(\"\");\n      len = rules.length;\n      for (i = 0; i < len; i++) {\n        rules[i](state);\n      }\n    };\n    ParserInline.prototype.State = require_state_inline();\n    module.exports = ParserInline;\n  }\n});\n\n// node_modules/linkify-it/lib/re.js\nvar require_re = __commonJS({\n  \"node_modules/linkify-it/lib/re.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function(opts) {\n      var re = {};\n      re.src_Any = require_regex2().source;\n      re.src_Cc = require_regex3().source;\n      re.src_Z = require_regex5().source;\n      re.src_P = require_regex().source;\n      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join(\"|\");\n      re.src_ZCc = [re.src_Z, re.src_Cc].join(\"|\");\n      var text_separators = \"[><\\uFF5C]\";\n      re.src_pseudo_letter = \"(?:(?!\" + text_separators + \"|\" + re.src_ZPCc + \")\" + re.src_Any + \")\";\n      re.src_ip4 = \"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\";\n      re.src_auth = \"(?:(?:(?!\" + re.src_ZCc + \"|[@/\\\\[\\\\]()]).)+@)?\";\n      re.src_port = \"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\";\n      re.src_host_terminator = \"(?=$|\" + text_separators + \"|\" + re.src_ZPCc + \")(?!-|_|:\\\\d|\\\\.-|\\\\.(?!$|\" + re.src_ZPCc + \"))\";\n      re.src_path = \"(?:[/?#](?:(?!\" + re.src_ZCc + \"|\" + text_separators + `|[()[\\\\]{}.,\"'?!\\\\-;]).|\\\\[(?:(?!` + re.src_ZCc + \"|\\\\]).)*\\\\]|\\\\((?:(?!\" + re.src_ZCc + \"|[)]).)*\\\\)|\\\\{(?:(?!\" + re.src_ZCc + '|[}]).)*\\\\}|\\\\\"(?:(?!' + re.src_ZCc + `|[\"]).)+\\\\\"|\\\\'(?:(?!` + re.src_ZCc + \"|[']).)+\\\\'|\\\\'(?=\" + re.src_pseudo_letter + \"|[-]).|\\\\.{2,}[a-zA-Z0-9%/&]|\\\\.(?!\" + re.src_ZCc + \"|[.]).|\" + (opts && opts[\"---\"] ? \"\\\\-(?!--(?:[^-]|$))(?:-*)|\" : \"\\\\-+|\") + \",(?!\" + re.src_ZCc + \").|;(?!\" + re.src_ZCc + \").|\\\\!+(?!\" + re.src_ZCc + \"|[!]).|\\\\?(?!\" + re.src_ZCc + \"|[?]).)+|\\\\/)?\";\n      re.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n      re.src_xn = \"xn--[a-z0-9\\\\-]{1,59}\";\n      re.src_domain_root = \"(?:\" + re.src_xn + \"|\" + re.src_pseudo_letter + \"{1,63})\";\n      re.src_domain = \"(?:\" + re.src_xn + \"|(?:\" + re.src_pseudo_letter + \")|(?:\" + re.src_pseudo_letter + \"(?:-|\" + re.src_pseudo_letter + \"){0,61}\" + re.src_pseudo_letter + \"))\";\n      re.src_host = \"(?:(?:(?:(?:\" + re.src_domain + \")\\\\.)*\" + re.src_domain + \"))\";\n      re.tpl_host_fuzzy = \"(?:\" + re.src_ip4 + \"|(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%)))\";\n      re.tpl_host_no_ip_fuzzy = \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\";\n      re.src_host_strict = re.src_host + re.src_host_terminator;\n      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;\n      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;\n      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n      re.tpl_host_fuzzy_test = \"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\" + re.src_ZPCc + \"|>|$))\";\n      re.tpl_email_fuzzy = \"(^|\" + text_separators + '|\"|\\\\(|' + re.src_ZCc + \")(\" + re.src_email_name + \"@\" + re.tpl_host_fuzzy_strict + \")\";\n      re.tpl_link_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re.tpl_host_port_fuzzy_strict + re.src_path + \")\";\n      re.tpl_link_no_ip_fuzzy = \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uFF5C]|\" + re.src_ZPCc + \"))((?![$+<=>^`|\\uFF5C])\" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + \")\";\n      return re;\n    };\n  }\n});\n\n// node_modules/linkify-it/index.js\nvar require_linkify_it = __commonJS({\n  \"node_modules/linkify-it/index.js\"(exports, module) {\n    \"use strict\";\n    function assign(obj) {\n      var sources = Array.prototype.slice.call(arguments, 1);\n      sources.forEach(function(source) {\n        if (!source) {\n          return;\n        }\n        Object.keys(source).forEach(function(key) {\n          obj[key] = source[key];\n        });\n      });\n      return obj;\n    }\n    function _class(obj) {\n      return Object.prototype.toString.call(obj);\n    }\n    function isString(obj) {\n      return _class(obj) === \"[object String]\";\n    }\n    function isObject(obj) {\n      return _class(obj) === \"[object Object]\";\n    }\n    function isRegExp(obj) {\n      return _class(obj) === \"[object RegExp]\";\n    }\n    function isFunction2(obj) {\n      return _class(obj) === \"[object Function]\";\n    }\n    function escapeRE(str) {\n      return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n    }\n    var defaultOptions = {\n      fuzzyLink: true,\n      fuzzyEmail: true,\n      fuzzyIP: false\n    };\n    function isOptionsObj(obj) {\n      return Object.keys(obj || {}).reduce(function(acc, k) {\n        return acc || defaultOptions.hasOwnProperty(k);\n      }, false);\n    }\n    var defaultSchemas = {\n      \"http:\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.http) {\n            self.re.http = new RegExp(\"^\\\\/\\\\/\" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, \"i\");\n          }\n          if (self.re.http.test(tail)) {\n            return tail.match(self.re.http)[0].length;\n          }\n          return 0;\n        }\n      },\n      \"https:\": \"http:\",\n      \"ftp:\": \"http:\",\n      \"//\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.no_http) {\n            self.re.no_http = new RegExp(\"^\" + self.re.src_auth + \"(?:localhost|(?:(?:\" + self.re.src_domain + \")\\\\.)+\" + self.re.src_domain_root + \")\" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, \"i\");\n          }\n          if (self.re.no_http.test(tail)) {\n            if (pos >= 3 && text2[pos - 3] === \":\") {\n              return 0;\n            }\n            if (pos >= 3 && text2[pos - 3] === \"/\") {\n              return 0;\n            }\n            return tail.match(self.re.no_http)[0].length;\n          }\n          return 0;\n        }\n      },\n      \"mailto:\": {\n        validate: function(text2, pos, self) {\n          var tail = text2.slice(pos);\n          if (!self.re.mailto) {\n            self.re.mailto = new RegExp(\"^\" + self.re.src_email_name + \"@\" + self.re.src_host_strict, \"i\");\n          }\n          if (self.re.mailto.test(tail)) {\n            return tail.match(self.re.mailto)[0].length;\n          }\n          return 0;\n        }\n      }\n    };\n    var tlds_2ch_src_re = \"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\";\n    var tlds_default = \"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\\u0440\\u0444\".split(\"|\");\n    function resetScanCache(self) {\n      self.__index__ = -1;\n      self.__text_cache__ = \"\";\n    }\n    function createValidator(re) {\n      return function(text2, pos) {\n        var tail = text2.slice(pos);\n        if (re.test(tail)) {\n          return tail.match(re)[0].length;\n        }\n        return 0;\n      };\n    }\n    function createNormalizer() {\n      return function(match, self) {\n        self.normalize(match);\n      };\n    }\n    function compile(self) {\n      var re = self.re = require_re()(self.__opts__);\n      var tlds = self.__tlds__.slice();\n      self.onCompile();\n      if (!self.__tlds_replaced__) {\n        tlds.push(tlds_2ch_src_re);\n      }\n      tlds.push(re.src_xn);\n      re.src_tlds = tlds.join(\"|\");\n      function untpl(tpl) {\n        return tpl.replace(\"%TLDS%\", re.src_tlds);\n      }\n      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), \"i\");\n      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), \"i\");\n      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), \"i\");\n      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), \"i\");\n      var aliases = [];\n      self.__compiled__ = {};\n      function schemaError(name, val) {\n        throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n      }\n      Object.keys(self.__schemas__).forEach(function(name) {\n        var val = self.__schemas__[name];\n        if (val === null) {\n          return;\n        }\n        var compiled = { validate: null, link: null };\n        self.__compiled__[name] = compiled;\n        if (isObject(val)) {\n          if (isRegExp(val.validate)) {\n            compiled.validate = createValidator(val.validate);\n          } else if (isFunction2(val.validate)) {\n            compiled.validate = val.validate;\n          } else {\n            schemaError(name, val);\n          }\n          if (isFunction2(val.normalize)) {\n            compiled.normalize = val.normalize;\n          } else if (!val.normalize) {\n            compiled.normalize = createNormalizer();\n          } else {\n            schemaError(name, val);\n          }\n          return;\n        }\n        if (isString(val)) {\n          aliases.push(name);\n          return;\n        }\n        schemaError(name, val);\n      });\n      aliases.forEach(function(alias) {\n        if (!self.__compiled__[self.__schemas__[alias]]) {\n          return;\n        }\n        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;\n        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;\n      });\n      self.__compiled__[\"\"] = { validate: null, normalize: createNormalizer() };\n      var slist = Object.keys(self.__compiled__).filter(function(name) {\n        return name.length > 0 && self.__compiled__[name];\n      }).map(escapeRE).join(\"|\");\n      self.re.schema_test = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"i\");\n      self.re.schema_search = RegExp(\"(^|(?!_)(?:[><\\uFF5C]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"ig\");\n      self.re.pretest = RegExp(\"(\" + self.re.schema_test.source + \")|(\" + self.re.host_fuzzy_test.source + \")|@\", \"i\");\n      resetScanCache(self);\n    }\n    function Match(self, shift) {\n      var start = self.__index__, end = self.__last_index__, text2 = self.__text_cache__.slice(start, end);\n      this.schema = self.__schema__.toLowerCase();\n      this.index = start + shift;\n      this.lastIndex = end + shift;\n      this.raw = text2;\n      this.text = text2;\n      this.url = text2;\n    }\n    function createMatch(self, shift) {\n      var match = new Match(self, shift);\n      self.__compiled__[match.schema].normalize(match, self);\n      return match;\n    }\n    function LinkifyIt(schemas, options) {\n      if (!(this instanceof LinkifyIt)) {\n        return new LinkifyIt(schemas, options);\n      }\n      if (!options) {\n        if (isOptionsObj(schemas)) {\n          options = schemas;\n          schemas = {};\n        }\n      }\n      this.__opts__ = assign({}, defaultOptions, options);\n      this.__index__ = -1;\n      this.__last_index__ = -1;\n      this.__schema__ = \"\";\n      this.__text_cache__ = \"\";\n      this.__schemas__ = assign({}, defaultSchemas, schemas);\n      this.__compiled__ = {};\n      this.__tlds__ = tlds_default;\n      this.__tlds_replaced__ = false;\n      this.re = {};\n      compile(this);\n    }\n    LinkifyIt.prototype.add = function add(schema, definition) {\n      this.__schemas__[schema] = definition;\n      compile(this);\n      return this;\n    };\n    LinkifyIt.prototype.set = function set(options) {\n      this.__opts__ = assign(this.__opts__, options);\n      return this;\n    };\n    LinkifyIt.prototype.test = function test(text2) {\n      this.__text_cache__ = text2;\n      this.__index__ = -1;\n      if (!text2.length) {\n        return false;\n      }\n      var m, ml, me, len, shift, next, re, tld_pos, at_pos;\n      if (this.re.schema_test.test(text2)) {\n        re = this.re.schema_search;\n        re.lastIndex = 0;\n        while ((m = re.exec(text2)) !== null) {\n          len = this.testSchemaAt(text2, m[2], re.lastIndex);\n          if (len) {\n            this.__schema__ = m[2];\n            this.__index__ = m.index + m[1].length;\n            this.__last_index__ = m.index + m[0].length + len;\n            break;\n          }\n        }\n      }\n      if (this.__opts__.fuzzyLink && this.__compiled__[\"http:\"]) {\n        tld_pos = text2.search(this.re.host_fuzzy_test);\n        if (tld_pos >= 0) {\n          if (this.__index__ < 0 || tld_pos < this.__index__) {\n            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n              shift = ml.index + ml[1].length;\n              if (this.__index__ < 0 || shift < this.__index__) {\n                this.__schema__ = \"\";\n                this.__index__ = shift;\n                this.__last_index__ = ml.index + ml[0].length;\n              }\n            }\n          }\n        }\n      }\n      if (this.__opts__.fuzzyEmail && this.__compiled__[\"mailto:\"]) {\n        at_pos = text2.indexOf(\"@\");\n        if (at_pos >= 0) {\n          if ((me = text2.match(this.re.email_fuzzy)) !== null) {\n            shift = me.index + me[1].length;\n            next = me.index + me[0].length;\n            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n              this.__schema__ = \"mailto:\";\n              this.__index__ = shift;\n              this.__last_index__ = next;\n            }\n          }\n        }\n      }\n      return this.__index__ >= 0;\n    };\n    LinkifyIt.prototype.pretest = function pretest(text2) {\n      return this.re.pretest.test(text2);\n    };\n    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {\n      if (!this.__compiled__[schema.toLowerCase()]) {\n        return 0;\n      }\n      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);\n    };\n    LinkifyIt.prototype.match = function match(text2) {\n      var shift = 0, result = [];\n      if (this.__index__ >= 0 && this.__text_cache__ === text2) {\n        result.push(createMatch(this, shift));\n        shift = this.__last_index__;\n      }\n      var tail = shift ? text2.slice(shift) : text2;\n      while (this.test(tail)) {\n        result.push(createMatch(this, shift));\n        tail = tail.slice(this.__last_index__);\n        shift += this.__last_index__;\n      }\n      if (result.length) {\n        return result;\n      }\n      return null;\n    };\n    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {\n      list2 = Array.isArray(list2) ? list2 : [list2];\n      if (!keepOld) {\n        this.__tlds__ = list2.slice();\n        this.__tlds_replaced__ = true;\n        compile(this);\n        return this;\n      }\n      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {\n        return el !== arr[idx - 1];\n      }).reverse();\n      compile(this);\n      return this;\n    };\n    LinkifyIt.prototype.normalize = function normalize(match) {\n      if (!match.schema) {\n        match.url = \"http://\" + match.url;\n      }\n      if (match.schema === \"mailto:\" && !/^mailto:/i.test(match.url)) {\n        match.url = \"mailto:\" + match.url;\n      }\n    };\n    LinkifyIt.prototype.onCompile = function onCompile() {\n    };\n    module.exports = LinkifyIt;\n  }\n});\n\n// node_modules/punycode/punycode.js\nvar require_punycode = __commonJS({\n  \"node_modules/punycode/punycode.js\"(exports, module) {\n    \"use strict\";\n    var maxInt = 2147483647;\n    var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128;\n    var delimiter = \"-\";\n    var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/;\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\n    var errors = {\n      \"overflow\": \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    };\n    var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    function error2(type) {\n      throw new RangeError(errors[type]);\n    }\n    function map(array, fn) {\n      const result = [];\n      let length = array.length;\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n      return result;\n    }\n    function mapDomain(string, fn) {\n      const parts = string.split(\"@\");\n      let result = \"\";\n      if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n      }\n      string = string.replace(regexSeparators, \".\");\n      const labels = string.split(\".\");\n      const encoded = map(labels, fn).join(\".\");\n      return result + encoded;\n    }\n    function ucs2decode(string) {\n      const output = [];\n      let counter = 0;\n      const length = string.length;\n      while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 55296 && value <= 56319 && counter < length) {\n          const extra = string.charCodeAt(counter++);\n          if ((extra & 64512) == 56320) {\n            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n          } else {\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n      return output;\n    }\n    var ucs2encode = (array) => String.fromCodePoint(...array);\n    var basicToDigit = function(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n      return base;\n    };\n    var digitToBasic = function(digit, flag) {\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    var adapt = function(delta, numPoints, firstTime) {\n      let k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n      for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    var decode = function(input) {\n      const output = [];\n      const inputLength = input.length;\n      let i = 0;\n      let n = initialN;\n      let bias = initialBias;\n      let basic = input.lastIndexOf(delimiter);\n      if (basic < 0) {\n        basic = 0;\n      }\n      for (let j = 0; j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n          error2(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n      }\n      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n        let oldi = i;\n        for (let w = 1, k = base; ; k += base) {\n          if (index >= inputLength) {\n            error2(\"invalid-input\");\n          }\n          const digit = basicToDigit(input.charCodeAt(index++));\n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error2(\"overflow\");\n          }\n          i += digit * w;\n          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (digit < t) {\n            break;\n          }\n          const baseMinusT = base - t;\n          if (w > floor(maxInt / baseMinusT)) {\n            error2(\"overflow\");\n          }\n          w *= baseMinusT;\n        }\n        const out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n          error2(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n      }\n      return String.fromCodePoint(...output);\n    };\n    var encode = function(input) {\n      const output = [];\n      input = ucs2decode(input);\n      let inputLength = input.length;\n      let n = initialN;\n      let delta = 0;\n      let bias = initialBias;\n      for (const currentValue of input) {\n        if (currentValue < 128) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n      let basicLength = output.length;\n      let handledCPCount = basicLength;\n      if (basicLength) {\n        output.push(delimiter);\n      }\n      while (handledCPCount < inputLength) {\n        let m = maxInt;\n        for (const currentValue of input) {\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        }\n        const handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error2(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        for (const currentValue of input) {\n          if (currentValue < n && ++delta > maxInt) {\n            error2(\"overflow\");\n          }\n          if (currentValue == n) {\n            let q = delta;\n            for (let k = base; ; k += base) {\n              const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n              if (q < t) {\n                break;\n              }\n              const qMinusT = q - t;\n              const baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n        ++delta;\n        ++n;\n      }\n      return output.join(\"\");\n    };\n    var toUnicode = function(input) {\n      return mapDomain(input, function(string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n      });\n    };\n    var toASCII = function(input) {\n      return mapDomain(input, function(string) {\n        return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n      });\n    };\n    var punycode = {\n      \"version\": \"2.1.0\",\n      \"ucs2\": {\n        \"decode\": ucs2decode,\n        \"encode\": ucs2encode\n      },\n      \"decode\": decode,\n      \"encode\": encode,\n      \"toASCII\": toASCII,\n      \"toUnicode\": toUnicode\n    };\n    module.exports = punycode;\n  }\n});\n\n// node_modules/markdown-it/lib/presets/default.js\nvar require_default = __commonJS({\n  \"node_modules/markdown-it/lib/presets/default.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: false,\n        xhtmlOut: false,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 100\n      },\n      components: {\n        core: {},\n        block: {},\n        inline: {}\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/presets/zero.js\nvar require_zero = __commonJS({\n  \"node_modules/markdown-it/lib/presets/zero.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: false,\n        xhtmlOut: false,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 20\n      },\n      components: {\n        core: {\n          rules: [\n            \"normalize\",\n            \"block\",\n            \"inline\"\n          ]\n        },\n        block: {\n          rules: [\n            \"paragraph\"\n          ]\n        },\n        inline: {\n          rules: [\n            \"text\"\n          ],\n          rules2: [\n            \"balance_pairs\",\n            \"text_collapse\"\n          ]\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/presets/commonmark.js\nvar require_commonmark = __commonJS({\n  \"node_modules/markdown-it/lib/presets/commonmark.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      options: {\n        html: true,\n        xhtmlOut: true,\n        breaks: false,\n        langPrefix: \"language-\",\n        linkify: false,\n        typographer: false,\n        quotes: \"\\u201C\\u201D\\u2018\\u2019\",\n        highlight: null,\n        maxNesting: 20\n      },\n      components: {\n        core: {\n          rules: [\n            \"normalize\",\n            \"block\",\n            \"inline\"\n          ]\n        },\n        block: {\n          rules: [\n            \"blockquote\",\n            \"code\",\n            \"fence\",\n            \"heading\",\n            \"hr\",\n            \"html_block\",\n            \"lheading\",\n            \"list\",\n            \"reference\",\n            \"paragraph\"\n          ]\n        },\n        inline: {\n          rules: [\n            \"autolink\",\n            \"backticks\",\n            \"emphasis\",\n            \"entity\",\n            \"escape\",\n            \"html_inline\",\n            \"image\",\n            \"link\",\n            \"newline\",\n            \"text\"\n          ],\n          rules2: [\n            \"balance_pairs\",\n            \"emphasis\",\n            \"text_collapse\"\n          ]\n        }\n      }\n    };\n  }\n});\n\n// node_modules/markdown-it/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/markdown-it/lib/index.js\"(exports, module) {\n    \"use strict\";\n    var utils = require_utils();\n    var helpers = require_helpers();\n    var Renderer = require_renderer();\n    var ParserCore = require_parser_core();\n    var ParserBlock = require_parser_block();\n    var ParserInline = require_parser_inline();\n    var LinkifyIt = require_linkify_it();\n    var mdurl = require_mdurl();\n    var punycode = require_punycode();\n    var config = {\n      default: require_default(),\n      zero: require_zero(),\n      commonmark: require_commonmark()\n    };\n    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\n    var GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n    function validateLink(url) {\n      var str = url.trim().toLowerCase();\n      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;\n    }\n    var RECODE_HOSTNAME_FOR = [\"http:\", \"https:\", \"mailto:\"];\n    function normalizeLink(url) {\n      var parsed = mdurl.parse(url, true);\n      if (parsed.hostname) {\n        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n          try {\n            parsed.hostname = punycode.toASCII(parsed.hostname);\n          } catch (er) {\n          }\n        }\n      }\n      return mdurl.encode(mdurl.format(parsed));\n    }\n    function normalizeLinkText(url) {\n      var parsed = mdurl.parse(url, true);\n      if (parsed.hostname) {\n        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n          try {\n            parsed.hostname = punycode.toUnicode(parsed.hostname);\n          } catch (er) {\n          }\n        }\n      }\n      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + \"%\");\n    }\n    function MarkdownIt3(presetName, options) {\n      if (!(this instanceof MarkdownIt3)) {\n        return new MarkdownIt3(presetName, options);\n      }\n      if (!options) {\n        if (!utils.isString(presetName)) {\n          options = presetName || {};\n          presetName = \"default\";\n        }\n      }\n      this.inline = new ParserInline();\n      this.block = new ParserBlock();\n      this.core = new ParserCore();\n      this.renderer = new Renderer();\n      this.linkify = new LinkifyIt();\n      this.validateLink = validateLink;\n      this.normalizeLink = normalizeLink;\n      this.normalizeLinkText = normalizeLinkText;\n      this.utils = utils;\n      this.helpers = utils.assign({}, helpers);\n      this.options = {};\n      this.configure(presetName);\n      if (options) {\n        this.set(options);\n      }\n    }\n    MarkdownIt3.prototype.set = function(options) {\n      utils.assign(this.options, options);\n      return this;\n    };\n    MarkdownIt3.prototype.configure = function(presets) {\n      var self = this, presetName;\n      if (utils.isString(presets)) {\n        presetName = presets;\n        presets = config[presetName];\n        if (!presets) {\n          throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name');\n        }\n      }\n      if (!presets) {\n        throw new Error(\"Wrong `markdown-it` preset, can't be empty\");\n      }\n      if (presets.options) {\n        self.set(presets.options);\n      }\n      if (presets.components) {\n        Object.keys(presets.components).forEach(function(name) {\n          if (presets.components[name].rules) {\n            self[name].ruler.enableOnly(presets.components[name].rules);\n          }\n          if (presets.components[name].rules2) {\n            self[name].ruler2.enableOnly(presets.components[name].rules2);\n          }\n        });\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {\n      var result = [];\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n        result = result.concat(this[chain].ruler.enable(list2, true));\n      }, this);\n      result = result.concat(this.inline.ruler2.enable(list2, true));\n      var missed = list2.filter(function(name) {\n        return result.indexOf(name) < 0;\n      });\n      if (missed.length && !ignoreInvalid) {\n        throw new Error(\"MarkdownIt. Failed to enable unknown rule(s): \" + missed);\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {\n      var result = [];\n      if (!Array.isArray(list2)) {\n        list2 = [list2];\n      }\n      [\"core\", \"block\", \"inline\"].forEach(function(chain) {\n        result = result.concat(this[chain].ruler.disable(list2, true));\n      }, this);\n      result = result.concat(this.inline.ruler2.disable(list2, true));\n      var missed = list2.filter(function(name) {\n        return result.indexOf(name) < 0;\n      });\n      if (missed.length && !ignoreInvalid) {\n        throw new Error(\"MarkdownIt. Failed to disable unknown rule(s): \" + missed);\n      }\n      return this;\n    };\n    MarkdownIt3.prototype.use = function(plugin3) {\n      var args = [this].concat(Array.prototype.slice.call(arguments, 1));\n      plugin3.apply(plugin3, args);\n      return this;\n    };\n    MarkdownIt3.prototype.parse = function(src, env) {\n      if (typeof src !== \"string\") {\n        throw new Error(\"Input data should be a String\");\n      }\n      var state = new this.core.State(src, this, env);\n      this.core.process(state);\n      return state.tokens;\n    };\n    MarkdownIt3.prototype.render = function(src, env) {\n      env = env || {};\n      return this.renderer.render(this.parse(src, env), this.options, env);\n    };\n    MarkdownIt3.prototype.parseInline = function(src, env) {\n      var state = new this.core.State(src, this, env);\n      state.inlineMode = true;\n      this.core.process(state);\n      return state.tokens;\n    };\n    MarkdownIt3.prototype.renderInline = function(src, env) {\n      env = env || {};\n      return this.renderer.render(this.parseInline(src, env), this.options, env);\n    };\n    module.exports = MarkdownIt3;\n  }\n});\n\n// node_modules/markdown-it/index.js\nvar require_markdown_it = __commonJS({\n  \"node_modules/markdown-it/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = require_lib();\n  }\n});\n\n// src/ast/base.ts\nvar base_exports = {};\n__export(base_exports, {\n  getAstValues: () => getAstValues,\n  isAst: () => isAst,\n  isFunction: () => isFunction,\n  isVariable: () => isVariable,\n  resolve: () => resolve\n});\nfunction isAst(value) {\n  return !!value?.$$mdtype;\n}\nfunction isFunction(value) {\n  return !!(value?.$$mdtype === \"Function\");\n}\nfunction isVariable(value) {\n  return !!(value?.$$mdtype === \"Variable\");\n}\nfunction* getAstValues(value) {\n  if (value == null || typeof value !== \"object\")\n    return;\n  if (Array.isArray(value))\n    for (const v of value)\n      yield* getAstValues(v);\n  if (isAst(value))\n    yield value;\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    return;\n  for (const v of Object.values(value))\n    yield* getAstValues(v);\n}\nfunction resolve(value, config = {}) {\n  if (value == null || typeof value !== \"object\")\n    return value;\n  if (Array.isArray(value))\n    return value.map((item2) => resolve(item2, config));\n  if (isAst(value) && value?.resolve instanceof Function)\n    return value.resolve(config);\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    return value;\n  const output = {};\n  for (const [k, v] of Object.entries(value))\n    output[k] = resolve(v, config);\n  return output;\n}\n\n// src/tag.ts\nvar Tag = class {\n  constructor(name = \"div\", attributes = {}, children = []) {\n    this.$$mdtype = \"Tag\";\n    this.name = name;\n    this.attributes = attributes;\n    this.children = children;\n  }\n};\n\n// src/schema-types/class.ts\nvar Class = class {\n  validate(value) {\n    if (typeof value === \"string\" || typeof value === \"object\")\n      return [];\n    return [\n      {\n        id: \"attribute-type-invalid\",\n        level: \"error\",\n        message: `Attribute 'class' must be type 'string | object'`\n      }\n    ];\n  }\n  transform(value) {\n    if (!value || typeof value === \"string\")\n      return value;\n    const classes = [];\n    for (const [k, v] of Object.entries(value ?? {}))\n      if (v)\n        classes.push(k);\n    return classes.join(\" \");\n  }\n};\n\n// src/utils.ts\nvar import_tag = __toModule(require_tag());\n\n// src/ast/variable.ts\nvar Variable = class {\n  constructor(path = []) {\n    this.$$mdtype = \"Variable\";\n    this.path = path;\n  }\n  resolve({ variables } = {}) {\n    return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key) => obj[key], variables);\n  }\n};\n\n// src/ast/function.ts\nvar Function2 = class {\n  constructor(name, parameters) {\n    this.$$mdtype = \"Function\";\n    this.name = name;\n    this.parameters = parameters;\n  }\n  resolve(config = {}) {\n    const fn = config?.functions?.[this.name];\n    if (!fn)\n      return null;\n    const parameters = resolve(this.parameters, config);\n    return fn.transform?.(parameters, config);\n  }\n};\n\n// src/utils.ts\nvar STATES;\n(function(STATES2) {\n  STATES2[STATES2[\"normal\"] = 0] = \"normal\";\n  STATES2[STATES2[\"string\"] = 1] = \"string\";\n  STATES2[STATES2[\"escape\"] = 2] = \"escape\";\n})(STATES || (STATES = {}));\nvar OPEN = \"{%\";\nvar CLOSE = \"%}\";\nfunction isPromise(a) {\n  return a && typeof a === \"object\" && typeof a.then === \"function\";\n}\nfunction findTagEnd(content, start = 0) {\n  let state = 0;\n  for (let pos = start; pos < content.length; pos++) {\n    const char = content[pos];\n    switch (state) {\n      case 1:\n        switch (char) {\n          case '\"':\n            state = 0;\n            break;\n          case \"\\\\\":\n            state = 2;\n            break;\n        }\n        break;\n      case 2:\n        state = 1;\n        break;\n      case 0:\n        if (char === '\"')\n          state = 1;\n        else if (content.startsWith(CLOSE, pos))\n          return pos;\n    }\n  }\n  return null;\n}\nfunction parseTag(content, line, contentStart) {\n  try {\n    return (0, import_tag.parse)(content, { Variable, Function: Function2 });\n  } catch (error2) {\n    if (!(error2 instanceof import_tag.SyntaxError))\n      throw error2;\n    const {\n      message,\n      location: { start, end }\n    } = error2;\n    const location = {\n      start: { line, character: start.offset + contentStart },\n      end: { line: line + 1, character: end.offset + contentStart }\n    };\n    return { type: \"error\", meta: { error: { message, location } } };\n  }\n}\nfunction parseTags(content, firstLine = 0) {\n  let line = firstLine + 1;\n  const output = [];\n  let start = 0;\n  for (let pos = 0; pos < content.length; pos++) {\n    if (content[pos] === \"\\n\") {\n      line++;\n      continue;\n    }\n    if (!content.startsWith(OPEN, pos))\n      continue;\n    const end = findTagEnd(content, pos);\n    if (end == null) {\n      pos = pos + OPEN.length;\n      continue;\n    }\n    const text2 = content.slice(pos, end + CLOSE.length);\n    const inner = content.slice(pos + OPEN.length, end);\n    const lineStart = content.lastIndexOf(\"\\n\", pos);\n    const lineEnd = content.indexOf(\"\\n\", end);\n    const lineContent = content.slice(lineStart, lineEnd);\n    const tag = parseTag(inner.trim(), line, pos - lineStart);\n    const precedingTextEnd = lineContent.trim() === text2 ? lineStart : pos;\n    const precedingText = content.slice(start, precedingTextEnd);\n    output.push({\n      type: \"text\",\n      start,\n      end: pos - 1,\n      content: precedingText\n    });\n    output.push({\n      map: [line, line + 1],\n      position: {\n        start: pos - lineStart,\n        end: pos - lineStart + text2.length\n      },\n      start: pos,\n      end: pos + text2.length - 1,\n      info: text2,\n      ...tag\n    });\n    start = end + CLOSE.length;\n    pos = start - 1;\n  }\n  output.push({\n    type: \"text\",\n    start,\n    end: content.length - 1,\n    content: content.slice(start)\n  });\n  return output;\n}\n\n// src/transformer.ts\nvar globalAttributes = {\n  class: { type: Class, render: true },\n  id: { type: String, render: true }\n};\nvar transformer_default = {\n  findSchema(node2, { nodes = {}, tags = {} } = {}) {\n    return node2.tag ? tags[node2.tag] : nodes[node2.type];\n  },\n  attributes(node2, config = {}) {\n    const schema = this.findSchema(node2, config) ?? {};\n    const output = {};\n    const attrs = { ...globalAttributes, ...schema.attributes };\n    for (const [key, attr] of Object.entries(attrs)) {\n      if (attr.render == false)\n        continue;\n      const name = typeof attr.render === \"string\" ? attr.render : key;\n      let value = node2.attributes[key];\n      if (typeof attr.type === \"function\") {\n        const instance = new attr.type();\n        if (instance.transform) {\n          value = instance.transform(value, config);\n        }\n      }\n      value = value === void 0 ? attr.default : value;\n      if (value === void 0)\n        continue;\n      output[name] = value;\n    }\n    return output;\n  },\n  children(node2, config = {}) {\n    const children = node2.children.flatMap((child) => this.node(child, config));\n    if (children.some(isPromise)) {\n      return Promise.all(children);\n    }\n    return children;\n  },\n  node(node2, config = {}) {\n    const schema = this.findSchema(node2, config) ?? {};\n    if (schema && schema.transform instanceof Function)\n      return schema.transform(node2, config);\n    const children = this.children(node2, config);\n    if (!schema || !schema.render)\n      return children;\n    const attributes = this.attributes(node2, config);\n    if (isPromise(attributes) || isPromise(children)) {\n      return Promise.all([attributes, children]).then((values) => new Tag(schema.render, ...values));\n    }\n    return new Tag(schema.render, attributes, children);\n  }\n};\n\n// src/ast/node.ts\nvar Node = class {\n  constructor(type = \"node\", attributes = {}, children = [], tag) {\n    this.$$mdtype = \"Node\";\n    this.errors = [];\n    this.lines = [];\n    this.inline = false;\n    this.attributes = attributes;\n    this.children = children;\n    this.type = type;\n    this.tag = tag;\n    this.annotations = [];\n  }\n  *walk() {\n    for (const child of this.children) {\n      yield child;\n      yield* child.walk();\n    }\n  }\n  push(node2) {\n    this.children.push(node2);\n  }\n  resolve(config = {}) {\n    return Object.assign(new Node(), this, {\n      children: this.children.map((child) => child.resolve(config)),\n      attributes: resolve(this.attributes, config)\n    });\n  }\n  findSchema(config = {}) {\n    return transformer_default.findSchema(this, config);\n  }\n  transformAttributes(config = {}) {\n    return transformer_default.attributes(this, config);\n  }\n  transformChildren(config) {\n    return transformer_default.children(this, config);\n  }\n  transform(config) {\n    return transformer_default.node(this, config);\n  }\n};\n\n// src/ast/index.ts\nvar AstTypes = {\n  Function: Function2,\n  Node,\n  Variable\n};\nfunction reviver(_, value) {\n  if (!value)\n    return value;\n  const klass = AstTypes[value.$$mdtype];\n  return klass ? Object.assign(new klass(), value) : value;\n}\nfunction fromJSON(text2) {\n  return JSON.parse(text2, reviver);\n}\nvar ast_default = {\n  ...AstTypes,\n  ...base_exports,\n  fromJSON\n};\n\n// src/formatter.ts\nvar SPACE = \" \";\nvar SEP = \", \";\nvar NL = \"\\n\";\nvar OL = \"1. \";\nvar UL = \"- \";\nvar MAX_TAG_OPENING_WIDTH = 80;\nvar max = (a, b) => Math.max(a, b);\nvar increment = (o, n = 2) => ({\n  ...o,\n  indent: (o.indent || 0) + n\n});\nfunction* formatChildren(a, options) {\n  for (const child of a.children) {\n    yield* formatValue(child, options);\n  }\n}\nfunction* formatTableRow(items) {\n  yield `| ${items.join(\" | \")} |`;\n}\nfunction formatScalar(v) {\n  if (ast_default.isAst(v)) {\n    return format(v);\n  }\n  if (v === null) {\n    return \"\";\n  }\n  if (Array.isArray(v)) {\n    return \"[\" + v.map(formatScalar).join(SEP) + \"]\";\n  }\n  if (typeof v === \"object\") {\n    return \"{\" + Object.entries(v).map(([key, value]) => `${key}: ${formatScalar(value)}`).join(SEP) + \"}\";\n  }\n  return JSON.stringify(v);\n}\nfunction formatAnnotationValue(a) {\n  if (a.name === \"primary\")\n    return formatScalar(a.value);\n  if (a.name === \"id\" && typeof a.value === \"string\")\n    return \"#\" + a.value;\n  if (a.type === \"class\")\n    return \".\" + a.name;\n  return `${a.name}=${formatScalar(a.value)}`;\n}\nfunction* formatAttributes(n) {\n  for (const [key, value] of Object.entries(n.attributes)) {\n    if (key === \"class\" && !ast_default.isAst(value))\n      for (const name of Object.keys(value)) {\n        yield formatAnnotationValue({ type: \"class\", name, value });\n      }\n    else\n      yield formatAnnotationValue({ type: \"attribute\", name: key, value });\n  }\n}\nfunction* formatAnnotations(n) {\n  if (n.annotations.length) {\n    yield OPEN + SPACE;\n    yield n.annotations.map(formatAnnotationValue).join(SPACE);\n    yield SPACE + CLOSE;\n  }\n}\nfunction* formatVariable(v) {\n  yield \"$\";\n  yield v.path.join(\".\");\n}\nfunction* formatFunction(f) {\n  yield f.name;\n  yield \"(\";\n  yield Object.values(f.parameters).map(formatScalar).join(SEP);\n  yield \")\";\n}\nfunction* trimStart(g) {\n  let n;\n  do {\n    n = g.next().value.trimStart();\n  } while (!n.length);\n  yield n;\n  yield* g;\n}\nfunction* formatNode(n, o = {}) {\n  const no = { ...o, parent: n };\n  const indent = SPACE.repeat(no.indent || 0);\n  switch (n.type) {\n    case \"document\": {\n      if (n.attributes.frontmatter && n.attributes.frontmatter.length) {\n        yield \"---\" + NL + n.attributes.frontmatter + NL + \"---\" + NL + NL;\n      }\n      yield* trimStart(formatChildren(n, no));\n      break;\n    }\n    case \"heading\": {\n      yield NL;\n      yield indent;\n      yield \"#\".repeat(n.attributes.level || 1);\n      yield SPACE;\n      yield* formatChildren(n, no);\n      yield* formatAnnotations(n);\n      yield NL;\n      break;\n    }\n    case \"paragraph\": {\n      yield NL;\n      yield indent;\n      yield* formatChildren(n, no);\n      yield* formatAnnotations(n);\n      yield NL;\n      break;\n    }\n    case \"inline\": {\n      yield* formatChildren(n, no);\n      break;\n    }\n    case \"link\": {\n      yield \"[\";\n      yield* formatChildren(n, no);\n      yield \"]\";\n      yield \"(\";\n      yield* formatValue(n.attributes.href, no);\n      yield \")\";\n      break;\n    }\n    case \"text\": {\n      if (ast_default.isAst(n.attributes.content))\n        yield OPEN + SPACE;\n      yield* formatValue(n.attributes.content, no);\n      if (ast_default.isAst(n.attributes.content))\n        yield SPACE + CLOSE;\n      break;\n    }\n    case \"blockquote\": {\n      yield NL;\n      yield indent;\n      yield \"> \";\n      yield* trimStart(formatChildren(n, no));\n      break;\n    }\n    case \"hr\": {\n      yield NL;\n      yield indent;\n      yield \"---\";\n      yield NL;\n      break;\n    }\n    case \"image\": {\n      yield \"!\";\n      yield \"[\";\n      yield* formatValue(n.attributes.alt, no);\n      yield \"]\";\n      yield \"(\";\n      yield* formatValue(n.attributes.src, no);\n      yield \")\";\n      break;\n    }\n    case \"fence\": {\n      yield NL;\n      yield indent;\n      yield \"```\";\n      yield (n.attributes.language || \"\").toLowerCase();\n      if (n.annotations.length)\n        yield SPACE;\n      yield* formatAnnotations(n);\n      yield NL;\n      yield indent;\n      yield* formatChildren(n, no);\n      yield indent;\n      yield \"```\";\n      yield NL;\n      break;\n    }\n    case \"tag\": {\n      if (!n.inline) {\n        yield NL;\n        yield indent;\n      }\n      const open = OPEN + SPACE;\n      const tag = [open + n.tag, ...formatAttributes(n)];\n      const inlineTag = tag.join(SPACE);\n      const isLongTagOpening = inlineTag.length + open.length * 2 > (o.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);\n      yield (isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent) : inlineTag) + SPACE + (n.children.length ? \"\" : \"/\") + CLOSE;\n      if (n.children.length) {\n        yield* formatChildren(n, no.allowIndentation ? increment(no) : no);\n        if (!n.inline) {\n          yield indent;\n        }\n        yield OPEN + SPACE + \"/\" + n.tag + SPACE + CLOSE;\n      }\n      if (!n.inline) {\n        yield NL;\n      }\n      break;\n    }\n    case \"list\": {\n      const prefix = n.attributes.ordered ? OL : UL;\n      yield NL;\n      for (const child of n.children) {\n        const d = format(child, increment(no, prefix.length)).trim();\n        yield indent + prefix + d;\n        yield NL;\n      }\n      break;\n    }\n    case \"item\": {\n      yield* formatChildren(n, no);\n      yield* formatAnnotations(n);\n      break;\n    }\n    case \"strong\": {\n      yield \"**\";\n      yield* formatChildren(n, no);\n      yield \"**\";\n      break;\n    }\n    case \"em\": {\n      yield \"_\";\n      yield* formatChildren(n, no);\n      yield \"_\";\n      break;\n    }\n    case \"code\": {\n      yield \"`\";\n      yield* formatValue(n.attributes.content, no);\n      yield \"`\";\n      break;\n    }\n    case \"s\": {\n      yield \"~~\";\n      yield* formatChildren(n, no);\n      yield \"~~\";\n      break;\n    }\n    case \"hardbreak\": {\n      yield \"\\\\\" + NL;\n      yield indent;\n      break;\n    }\n    case \"softbreak\": {\n      yield NL;\n      yield indent;\n      break;\n    }\n    case \"table\": {\n      const table3 = [...formatChildren(n, increment(no))];\n      if (o.parent && o.parent.type === \"tag\" && o.parent.tag === \"table\") {\n        for (let i = 0; i < table3.length; i++) {\n          const row = table3[i];\n          if (typeof row === \"string\") {\n            if (row.trim().length) {\n              yield NL;\n              yield row;\n            }\n          } else {\n            if (i !== 0) {\n              yield NL;\n              yield indent + \"---\";\n            }\n            for (let j = 0; j < row.length; j++) {\n              const d = row[j];\n              yield NL;\n              yield indent + UL + d.trim();\n            }\n          }\n        }\n        yield NL;\n      } else {\n        yield NL;\n        const [head, ...rows] = table3;\n        const ml = table3.map((arr) => arr.map((s2) => s2.length).reduce(max)).reduce(max);\n        yield* formatTableRow(head.map((h) => h + SPACE.repeat(ml - h.length)));\n        yield NL;\n        yield* formatTableRow(head.map(() => \"-\".repeat(ml)));\n        yield NL;\n        for (const row of rows) {\n          yield* formatTableRow(row.map((r) => r + SPACE.repeat(ml - r.length)));\n          yield NL;\n        }\n      }\n      break;\n    }\n    case \"thead\": {\n      const [head] = [...formatChildren(n, no)];\n      yield head || [];\n      break;\n    }\n    case \"tr\": {\n      yield [...formatChildren(n, no)];\n      break;\n    }\n    case \"td\":\n    case \"th\": {\n      yield [...formatChildren(n, no), ...formatAnnotations(n)].join(\"\");\n      break;\n    }\n    case \"tbody\": {\n      yield* formatChildren(n, no);\n      break;\n    }\n    case \"error\": {\n      console.error(n);\n      break;\n    }\n    case \"node\":\n      break;\n  }\n}\nfunction* formatValue(v, o = {}) {\n  switch (typeof v) {\n    case \"undefined\":\n      break;\n    case \"boolean\":\n    case \"number\":\n    case \"string\": {\n      yield v.toString();\n      break;\n    }\n    case \"object\": {\n      if (v === null)\n        break;\n      if (Array.isArray(v)) {\n        for (const n of v)\n          yield* formatValue(n, o);\n        break;\n      }\n      switch (v.$$mdtype) {\n        case \"Function\": {\n          yield* formatFunction(v);\n          break;\n        }\n        case \"Node\":\n          yield* formatNode(v, o);\n          break;\n        case \"Variable\": {\n          yield* formatVariable(v);\n          break;\n        }\n        default:\n          throw new Error(`Unimplemented: \"${v.$$mdtype}\"`);\n      }\n      break;\n    }\n  }\n}\nfunction format(v, options) {\n  let doc = \"\";\n  for (const s2 of formatValue(v, options))\n    doc += s2;\n  return doc.trimStart();\n}\n\n// src/tags/conditional.ts\nfunction truthy(value) {\n  return value !== false && value !== void 0 && value !== null;\n}\nfunction renderConditions(node2) {\n  const conditions = [\n    { condition: node2.attributes.primary, children: [] }\n  ];\n  for (const child of node2.children) {\n    if (child.type === \"tag\" && child.tag === \"else\")\n      conditions.push({\n        condition: \"primary\" in child.attributes ? child.attributes.primary : true,\n        children: []\n      });\n    else\n      conditions[conditions.length - 1].children.push(child);\n  }\n  return conditions;\n}\nvar tagIf = {\n  attributes: {\n    primary: { type: Object, render: false }\n  },\n  transform(node2, config) {\n    const conditions = renderConditions(node2);\n    for (const { condition, children } of conditions)\n      if (truthy(condition)) {\n        const nodes = children.flatMap((child) => child.transform(config));\n        if (nodes.some(isPromise)) {\n          return Promise.all(nodes).then((nodes2) => nodes2.flat());\n        }\n        return nodes;\n      }\n    return [];\n  }\n};\nvar tagElse = {\n  selfClosing: true,\n  attributes: {\n    primary: { type: Object, render: false }\n  }\n};\n\n// src/functions/index.ts\nvar and = {\n  transform(parameters) {\n    return Object.values(parameters).every((x) => truthy(x));\n  }\n};\nvar or = {\n  transform(parameters) {\n    return Object.values(parameters).find((x) => truthy(x)) !== void 0;\n  }\n};\nvar not = {\n  parameters: {\n    0: { required: true }\n  },\n  transform(parameters) {\n    return !truthy(parameters[0]);\n  }\n};\nvar equals = {\n  transform(parameters) {\n    const values = Object.values(parameters);\n    return values.every((v) => v === values[0]);\n  }\n};\nvar debug = {\n  transform(parameters) {\n    return JSON.stringify(parameters[0], null, 2);\n  }\n};\nvar defaultFn = {\n  transform(parameters) {\n    return parameters[0] === void 0 ? parameters[1] : parameters[0];\n  }\n};\nvar functions_default = { and, or, not, equals, default: defaultFn, debug };\n\n// src/transforms/table.ts\nfunction convertToRow(node2, cellType = \"td\") {\n  node2.type = \"tr\";\n  node2.attributes = {};\n  for (const cell of node2.children)\n    cell.type = cellType;\n  return node2;\n}\nfunction transform(document2) {\n  for (const node2 of document2.walk()) {\n    if (node2.type !== \"tag\" || node2.tag !== \"table\")\n      continue;\n    const [first, ...rest] = node2.children;\n    if (!first || first.type === \"table\")\n      continue;\n    const table3 = new ast_default.Node(\"table\", node2.attributes, [\n      new ast_default.Node(\"thead\"),\n      new ast_default.Node(\"tbody\")\n    ]);\n    const [thead2, tbody2] = table3.children;\n    if (first.type === \"list\")\n      thead2.push(convertToRow(first, \"th\"));\n    for (const row of rest) {\n      if (row.type === \"list\")\n        convertToRow(row);\n      else if (row.type === \"tag\" && row.tag === \"if\") {\n        const children = [];\n        for (const child of row.children) {\n          if (child.type === \"hr\")\n            continue;\n          if (child.type === \"list\")\n            convertToRow(child);\n          children.push(child);\n        }\n        row.children = children;\n      } else\n        continue;\n      tbody2.push(row);\n    }\n    node2.children = [table3];\n  }\n}\n\n// src/transforms/index.ts\nvar transforms_default = [transform];\n\n// src/parser.ts\nvar mappings = {\n  ordered_list: \"list\",\n  bullet_list: \"list\",\n  code_inline: \"code\",\n  list_item: \"item\",\n  variable: \"text\"\n};\nfunction annotate(node2, attributes) {\n  for (const attribute of attributes) {\n    node2.annotations.push(attribute);\n    const { name, value, type } = attribute;\n    if (type === \"attribute\")\n      node2.attributes[name] = value;\n    else if (type === \"class\")\n      if (node2.attributes.class)\n        node2.attributes.class[name] = value;\n      else\n        node2.attributes.class = { [name]: value };\n  }\n}\nfunction handleAttrs(token, type) {\n  switch (type) {\n    case \"heading\":\n      return { level: Number(token.tag.replace(\"h\", \"\")) };\n    case \"list\":\n      return { ordered: token.type.startsWith(\"ordered\") };\n    case \"link\": {\n      const attrs = Object.fromEntries(token.attrs);\n      return attrs.title ? { href: attrs.href, title: attrs.title } : { href: attrs.href };\n    }\n    case \"image\": {\n      const attrs = Object.fromEntries(token.attrs);\n      return attrs.title ? { alt: token.content, src: attrs.src, title: attrs.title } : { alt: token.content, src: attrs.src };\n    }\n    case \"text\":\n    case \"code\":\n      return { content: (token.meta || {}).variable || token.content };\n    case \"fence\": {\n      const [language] = token.info.split(\" \", 1);\n      return language === \"\" ? { content: token.content } : { content: token.content, language };\n    }\n    case \"td\":\n    case \"th\": {\n      if (token.attrs) {\n        const attrs = Object.fromEntries(token.attrs);\n        let align;\n        if (attrs.style) {\n          if (attrs.style.includes(\"left\")) {\n            align = \"left\";\n          } else if (attrs.style.includes(\"center\")) {\n            align = \"center\";\n          } else if (attrs.style.includes(\"right\")) {\n            align = \"right\";\n          }\n        }\n        if (align) {\n          return { align };\n        }\n      }\n      return {};\n    }\n    default:\n      return {};\n  }\n}\nfunction handleToken(token, nodes, file, inlineParent) {\n  if (token.type === \"frontmatter\") {\n    nodes[0].attributes.frontmatter = token.content;\n    return;\n  }\n  if (token.hidden || token.type === \"text\" && token.content === \"\")\n    return;\n  const errors = token.errors || [];\n  const parent = nodes[nodes.length - 1];\n  const { tag, attributes, error: error2 } = token.meta || {};\n  if (token.type === \"annotation\") {\n    if (inlineParent)\n      return annotate(inlineParent, attributes);\n    return parent.errors.push({\n      id: \"no-inline-annotations\",\n      level: \"error\",\n      message: `Can't apply inline annotations to '${parent.type}'`\n    });\n  }\n  let typeName = token.type.replace(/_(open|close)$/, \"\");\n  if (mappings[typeName])\n    typeName = mappings[typeName];\n  if (typeName === \"error\") {\n    const { message, location } = error2;\n    errors.push({ id: \"parse-error\", level: \"critical\", message, location });\n  }\n  if (token.nesting < 0) {\n    if (parent.type === typeName) {\n      if (parent.lines && token.map)\n        parent.lines.push(...token.map);\n      return nodes.pop();\n    }\n    errors.push({\n      id: \"missing-opening\",\n      level: \"critical\",\n      message: `Node '${typeName}' is missing opening`\n    });\n  }\n  const attrs = handleAttrs(token, typeName);\n  const node2 = new Node(typeName, attrs, void 0, tag || void 0);\n  const { position = {} } = token;\n  node2.errors = errors;\n  node2.lines = token.map || parent.lines || [];\n  node2.location = {\n    file,\n    start: {\n      line: node2.lines[0],\n      character: position.start\n    },\n    end: {\n      line: node2.lines[1],\n      character: position.end\n    }\n  };\n  if (inlineParent)\n    node2.inline = true;\n  if (attributes && [\"tag\", \"fence\", \"image\"].includes(typeName))\n    annotate(node2, attributes);\n  parent.push(node2);\n  if (token.nesting > 0)\n    nodes.push(node2);\n  if (!Array.isArray(token.children))\n    return;\n  inlineParent = parent;\n  nodes.push(node2);\n  const isLeafNode = typeName === \"image\";\n  if (!isLeafNode) {\n    for (const child of token.children)\n      handleToken(child, nodes, file, inlineParent);\n  }\n  nodes.pop();\n}\nfunction parser(tokens, file) {\n  const doc = new Node(\"document\");\n  const nodes = [doc];\n  for (const token of tokens)\n    handleToken(token, nodes, file);\n  if (nodes.length > 1)\n    for (const node2 of nodes.slice(1))\n      node2.errors.push({\n        id: \"missing-closing\",\n        level: \"critical\",\n        message: `Node '${node2.tag || node2.type}' is missing closing`\n      });\n  for (const transform3 of transforms_default)\n    transform3(doc);\n  return doc;\n}\n\n// src/schema.ts\nvar schema_exports = {};\n__export(schema_exports, {\n  blockquote: () => blockquote,\n  code: () => code,\n  document: () => document,\n  em: () => em,\n  error: () => error,\n  fence: () => fence,\n  hardbreak: () => hardbreak,\n  heading: () => heading,\n  hr: () => hr,\n  image: () => image,\n  inline: () => inline,\n  item: () => item,\n  link: () => link,\n  list: () => list,\n  node: () => node,\n  paragraph: () => paragraph,\n  s: () => s,\n  softbreak: () => softbreak,\n  strong: () => strong,\n  table: () => table,\n  tbody: () => tbody,\n  td: () => td,\n  text: () => text,\n  th: () => th,\n  thead: () => thead,\n  tr: () => tr\n});\nvar document = {\n  render: \"article\",\n  children: [\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ],\n  attributes: {\n    frontmatter: { render: false }\n  }\n};\nvar heading = {\n  children: [\"inline\"],\n  attributes: {\n    level: { type: Number, render: false, required: true }\n  },\n  transform(node2, config) {\n    return new Tag(`h${node2.attributes[\"level\"]}`, node2.transformAttributes(config), node2.transformChildren(config));\n  }\n};\nvar paragraph = {\n  render: \"p\",\n  children: [\"inline\"]\n};\nvar image = {\n  render: \"img\",\n  attributes: {\n    src: { type: String, required: true },\n    alt: { type: String },\n    title: { type: String }\n  }\n};\nvar fence = {\n  render: \"pre\",\n  attributes: {\n    content: { type: String, render: false, required: true },\n    language: { type: String, render: \"data-language\" },\n    process: { type: Boolean, render: false, default: true }\n  },\n  transform(node2, config) {\n    const attributes = node2.transformAttributes(config);\n    const children = node2.children.length ? node2.transformChildren(config) : [node2.attributes.content];\n    return new Tag(\"pre\", attributes, children);\n  }\n};\nvar blockquote = {\n  render: \"blockquote\",\n  children: [\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ]\n};\nvar item = {\n  render: \"li\",\n  children: [\n    \"inline\",\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ]\n};\nvar list = {\n  children: [\"item\"],\n  attributes: {\n    ordered: { type: Boolean, render: false, required: true }\n  },\n  transform(node2, config) {\n    return new Tag(node2.attributes.ordered ? \"ol\" : \"ul\", node2.transformAttributes(config), node2.transformChildren(config));\n  }\n};\nvar hr = {\n  render: \"hr\"\n};\nvar table = {\n  render: \"table\"\n};\nvar td = {\n  render: \"td\",\n  children: [\n    \"inline\",\n    \"heading\",\n    \"paragraph\",\n    \"image\",\n    \"table\",\n    \"tag\",\n    \"fence\",\n    \"blockquote\",\n    \"list\",\n    \"hr\"\n  ],\n  attributes: {\n    colspan: { type: Number },\n    rowspan: { type: Number },\n    align: { type: String }\n  }\n};\nvar th = {\n  render: \"th\",\n  attributes: {\n    width: { type: Number },\n    align: { type: String }\n  }\n};\nvar tr = {\n  render: \"tr\",\n  children: [\"th\", \"td\"]\n};\nvar tbody = {\n  render: \"tbody\",\n  children: [\"tr\", \"tag\"]\n};\nvar thead = {\n  render: \"thead\",\n  children: [\"tr\"]\n};\nvar strong = {\n  render: \"strong\",\n  children: [\"em\", \"s\", \"link\", \"code\", \"text\", \"tag\"]\n};\nvar em = {\n  render: \"em\",\n  children: [\"strong\", \"s\", \"link\", \"code\", \"text\", \"tag\"]\n};\nvar s = {\n  render: \"s\",\n  children: [\"strong\", \"em\", \"link\", \"code\", \"text\", \"tag\"]\n};\nvar inline = {\n  children: [\n    \"strong\",\n    \"em\",\n    \"s\",\n    \"code\",\n    \"text\",\n    \"tag\",\n    \"link\",\n    \"image\",\n    \"hardbreak\",\n    \"softbreak\"\n  ]\n};\nvar link = {\n  render: \"a\",\n  children: [\"strong\", \"em\", \"s\", \"code\", \"text\", \"tag\"],\n  attributes: {\n    href: { type: String, required: true },\n    title: { type: String }\n  }\n};\nvar code = {\n  render: \"code\",\n  attributes: {\n    content: { type: String, render: false, required: true }\n  },\n  transform(node2, config) {\n    const attributes = node2.transformAttributes(config);\n    return new Tag(\"code\", attributes, [node2.attributes.content]);\n  }\n};\nvar text = {\n  attributes: {\n    content: { type: String, required: true }\n  },\n  transform(node2) {\n    return node2.attributes.content;\n  }\n};\nvar hardbreak = {\n  render: \"br\"\n};\nvar softbreak = {\n  transform() {\n    return \" \";\n  }\n};\nvar error = {};\nvar node = {};\n\n// src/renderers/html.ts\nvar import_markdown_it = __toModule(require_markdown_it());\nvar { escapeHtml } = (0, import_markdown_it.default)().utils;\nvar voidElements = new Set([\n  \"area\",\n  \"base\",\n  \"br\",\n  \"col\",\n  \"embed\",\n  \"hr\",\n  \"img\",\n  \"input\",\n  \"link\",\n  \"meta\",\n  \"param\",\n  \"source\",\n  \"track\",\n  \"wbr\"\n]);\nfunction render(node2) {\n  if (typeof node2 === \"string\")\n    return escapeHtml(node2);\n  if (Array.isArray(node2))\n    return node2.map(render).join(\"\");\n  if (node2 === null || typeof node2 !== \"object\")\n    return \"\";\n  const { name, attributes, children = [] } = node2;\n  if (!name)\n    return render(children);\n  let output = `<${name}`;\n  for (const [k, v] of Object.entries(attributes ?? {}))\n    output += ` ${k}=\"${escapeHtml(String(v))}\"`;\n  output += \">\";\n  if (voidElements.has(name))\n    return output;\n  if (children.length)\n    output += render(children);\n  output += `</${name}>`;\n  return output;\n}\n\n// src/renderers/react/shared.ts\nfunction tagName(name, components) {\n  return typeof name !== \"string\" ? \"Fragment\" : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];\n}\n\n// src/renderers/react/react.ts\nfunction dynamic(node2, React, { components = {} } = {}) {\n  function deepRender2(value) {\n    if (value == null || typeof value !== \"object\")\n      return value;\n    if (Array.isArray(value))\n      return value.map((item2) => deepRender2(item2));\n    if (value.$$mdtype === \"Tag\")\n      return render3(value);\n    if (typeof value !== \"object\")\n      return value;\n    const output = {};\n    for (const [k, v] of Object.entries(value))\n      output[k] = deepRender2(v);\n    return output;\n  }\n  function render3(node3) {\n    if (Array.isArray(node3))\n      return React.createElement(React.Fragment, null, ...node3.map(render3));\n    if (node3 === null || typeof node3 !== \"object\")\n      return node3;\n    const {\n      name,\n      attributes: { class: className, ...attrs } = {},\n      children = []\n    } = node3;\n    if (className)\n      attrs.className = className;\n    return React.createElement(tagName(name, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));\n  }\n  return render3(node2);\n}\n\n// src/renderers/react/static.ts\nfunction renderArray(children) {\n  return children.map(render2).join(\", \");\n}\nfunction deepRender(value) {\n  if (value == null || typeof value !== \"object\")\n    return JSON.stringify(value);\n  if (Array.isArray(value))\n    return `[${value.map((item2) => deepRender(item2)).join(\", \")}]`;\n  if (value.$$mdtype === \"Tag\")\n    return render2(value);\n  if (typeof value !== \"object\")\n    return JSON.stringify(value);\n  const object = Object.entries(value).map(([k, v]) => [JSON.stringify(k), deepRender(v)].join(\": \")).join(\", \");\n  return `{${object}}`;\n}\nfunction render2(node2) {\n  if (Array.isArray(node2))\n    return `React.createElement(React.Fragment, null, ${renderArray(node2)})`;\n  if (node2 === null || typeof node2 !== \"object\")\n    return JSON.stringify(node2);\n  const {\n    name,\n    attributes: { class: className, ...attrs } = {},\n    children = []\n  } = node2;\n  if (className)\n    attrs.className = className;\n  return `React.createElement(\n    tagName(${JSON.stringify(name)}, components),\n    ${Object.keys(attrs).length == 0 ? \"null\" : deepRender(attrs)},\n    ${renderArray(children)})`;\n}\nfunction reactStatic(node2) {\n  return `\n  (({components = {}} = {}) => {\n    ${tagName}\n    return ${render2(node2)};\n  })\n`;\n}\n\n// src/renderers/index.ts\nvar renderers_default = { html: render, react: dynamic, reactStatic };\n\n// src/tags/partial.ts\nvar PartialFile = class {\n  validate(file, config) {\n    const { partials = {} } = config;\n    const partial2 = partials[file];\n    if (!partial2)\n      return [\n        {\n          id: \"attribute-value-invalid\",\n          level: \"error\",\n          message: `Partial \\`${file}\\` not found. The 'file' attribute must be set in \\`config.partials\\``\n        }\n      ];\n    return [];\n  }\n};\nvar partial = {\n  selfClosing: true,\n  attributes: {\n    file: { type: PartialFile, render: false, required: true },\n    variables: { type: Object, render: false }\n  },\n  transform(node2, config) {\n    const { partials = {} } = config;\n    const { file, variables } = node2.attributes;\n    const partial2 = partials[file];\n    if (!partial2)\n      return null;\n    const scopedConfig = {\n      ...config,\n      variables: {\n        ...config.variables,\n        ...variables,\n        [\"$$partial:filename\"]: file\n      }\n    };\n    const transformChildren = (part) => part.resolve(scopedConfig).transformChildren(scopedConfig);\n    return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);\n  }\n};\n\n// src/tags/table.ts\nvar table2 = {\n  children: [\"table\"]\n};\n\n// src/tags/index.ts\nvar tags_default = {\n  if: tagIf,\n  else: tagElse,\n  partial,\n  table: table2\n};\n\n// src/tokenizer/index.ts\nvar import_lib = __toModule(require_lib());\n\n// src/tokenizer/plugins/annotations.ts\nvar import_tag4 = __toModule(require_tag());\nfunction createToken(state, content, contentStart) {\n  try {\n    const { type, meta, nesting = 0 } = (0, import_tag4.parse)(content, { Variable, Function: Function2 });\n    const token = state.push(type, \"\", nesting);\n    token.info = content;\n    token.meta = meta;\n    if (!state.delimiters) {\n      state.delimiters = [];\n    }\n    return token;\n  } catch (error2) {\n    if (!(error2 instanceof import_tag4.SyntaxError))\n      throw error2;\n    const {\n      message,\n      location: { start, end }\n    } = error2;\n    const location = contentStart ? {\n      start: { offset: start.offset + contentStart },\n      end: { offset: end.offset + contentStart }\n    } : null;\n    const token = state.push(\"error\", \"\", 0);\n    token.meta = { error: { message, location } };\n    return token;\n  }\n}\nfunction block(state, startLine, endLine, silent) {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const finish = state.eMarks[startLine];\n  if (!state.src.startsWith(OPEN, start))\n    return false;\n  const tagEnd = findTagEnd(state.src, start);\n  const lastPossible = state.src.slice(0, finish).trim().length;\n  if (!tagEnd || tagEnd < lastPossible - CLOSE.length)\n    return false;\n  const contentStart = start + OPEN.length;\n  const content = state.src.slice(contentStart, tagEnd).trim();\n  const lines = content.split(\"\\n\").length;\n  if (content[0] === \"$\")\n    return false;\n  if (silent)\n    return true;\n  const token = createToken(state, content, contentStart);\n  token.map = [startLine, startLine + lines];\n  state.line += lines;\n  return true;\n}\nfunction inline2(state, silent) {\n  if (!state.src.startsWith(OPEN, state.pos))\n    return false;\n  const tagEnd = findTagEnd(state.src, state.pos);\n  if (!tagEnd)\n    return false;\n  const content = state.src.slice(state.pos + OPEN.length, tagEnd);\n  if (!silent)\n    createToken(state, content.trim());\n  state.pos = tagEnd + CLOSE.length;\n  return true;\n}\nfunction core(state) {\n  let token;\n  for (token of state.tokens) {\n    if (token.type !== \"fence\")\n      continue;\n    if (token.info.includes(OPEN)) {\n      const start = token.info.indexOf(OPEN);\n      const end = findTagEnd(token.info, start);\n      const content = token.info.slice(start + OPEN.length, end);\n      try {\n        const { meta } = (0, import_tag4.parse)(content.trim(), { Variable, Function: Function2 });\n        token.meta = meta;\n      } catch (error2) {\n        if (!(error2 instanceof import_tag4.SyntaxError))\n          throw error2;\n        if (!token.errors)\n          token.errors = [];\n        token.errors.push({\n          id: \"fence-tag-error\",\n          level: \"error\",\n          message: `Syntax error in fence tag: ${error2.message}`\n        });\n      }\n    }\n    if (token?.meta?.attributes?.find((attr) => attr.name === \"process\" && !attr.value))\n      continue;\n    token.children = parseTags(token.content, token.map[0]);\n  }\n}\nfunction plugin(md) {\n  md.block.ruler.before(\"paragraph\", \"annotations\", block, {\n    alt: [\"paragraph\", \"blockquote\"]\n  });\n  md.inline.ruler.push(\"containers\", inline2);\n  md.core.ruler.push(\"annotations\", core);\n}\n\n// src/tokenizer/plugins/frontmatter.ts\nvar fence2 = \"---\";\nfunction getLine(state, n) {\n  return state.src.slice(state.bMarks[n], state.eMarks[n]).trim();\n}\nfunction findClose(state, endLine) {\n  for (let line = 1; line < endLine; line++)\n    if (getLine(state, line) === fence2)\n      return line;\n}\nfunction block2(state, startLine, endLine, silent) {\n  if (startLine != 0 || getLine(state, 0) != fence2)\n    return false;\n  const close = findClose(state, endLine);\n  if (!close)\n    return false;\n  if (silent)\n    return true;\n  const token = state.push(\"frontmatter\", \"\", 0);\n  token.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();\n  token.map = [0, close];\n  token.hidden = true;\n  state.line = close + 1;\n  return true;\n}\nfunction plugin2(md) {\n  md.block.ruler.before(\"hr\", \"frontmatter\", block2);\n}\n\n// src/tokenizer/index.ts\nvar Tokenizer = class {\n  constructor(config = {}) {\n    this.parser = new import_lib.default(config);\n    this.parser.use(plugin, \"annotations\", {});\n    this.parser.use(plugin2, \"frontmatter\", {});\n    this.parser.disable([\n      \"lheading\",\n      \"code\"\n    ]);\n  }\n  tokenize(content) {\n    return this.parser.parse(content.toString(), {});\n  }\n};\n\n// src/validator.ts\nvar TypeMappings = {\n  String,\n  Number,\n  Array,\n  Object,\n  Boolean\n};\nfunction validateType(type, value, config) {\n  if (!type)\n    return true;\n  if (ast_default.isFunction(value) && config.validation?.validateFunctions) {\n    const schema = config.functions?.[value.name];\n    return !schema?.returns ? true : Array.isArray(schema.returns) ? schema.returns.find((t) => t === type) !== void 0 : schema.returns === type;\n  }\n  if (ast_default.isAst(value))\n    return true;\n  if (Array.isArray(type))\n    return type.some((t) => validateType(t, value, config));\n  if (typeof type === \"string\")\n    type = TypeMappings[type];\n  if (typeof type === \"function\") {\n    const instance = new type();\n    if (instance.validate) {\n      return instance.validate(value, config);\n    }\n  }\n  return value != null && value.constructor === type;\n}\nfunction typeToString(type) {\n  if (typeof type === \"string\")\n    return type;\n  if (Array.isArray(type))\n    return type.map(typeToString).join(\" | \");\n  return type.name;\n}\nfunction validateFunction(fn, config) {\n  const schema = config.functions?.[fn.name];\n  const errors = [];\n  if (!schema)\n    return [\n      {\n        id: \"function-undefined\",\n        level: \"critical\",\n        message: `Undefined function: '${fn.name}'`\n      }\n    ];\n  if (schema.validate)\n    errors.push(...schema.validate(fn, config));\n  if (schema.parameters) {\n    for (const [key, value] of Object.entries(fn.parameters)) {\n      const param = schema.parameters?.[key];\n      if (!param) {\n        errors.push({\n          id: \"parameter-undefined\",\n          level: \"error\",\n          message: `Invalid parameter: '${key}'`\n        });\n        continue;\n      }\n      if (ast_default.isAst(value) && !ast_default.isFunction(value))\n        continue;\n      if (param.type) {\n        const valid = validateType(param.type, value, config);\n        if (valid === false) {\n          errors.push({\n            id: \"parameter-type-invalid\",\n            level: \"error\",\n            message: `Parameter '${key}' of '${fn.name}' must be type of '${typeToString(param.type)}'`\n          });\n        } else if (Array.isArray(valid)) {\n          errors.push(...valid);\n        }\n      }\n    }\n  }\n  for (const [key, { required }] of Object.entries(schema.parameters ?? {}))\n    if (required && fn.parameters[key] === void 0)\n      errors.push({\n        id: \"parameter-missing-required\",\n        level: \"error\",\n        message: `Missing required parameter: '${key}'`\n      });\n  return errors;\n}\nfunction validate(node2, config) {\n  const schema = node2.findSchema(config);\n  const errors = [...node2.errors || []];\n  if (!schema) {\n    errors.push({\n      id: node2.tag ? \"tag-undefined\" : \"node-undefined\",\n      level: \"critical\",\n      message: node2.tag ? `Undefined tag: '${node2.tag}'` : `Undefined node: '${node2.type}'`\n    });\n    return errors;\n  }\n  if (schema.selfClosing && node2.children.length > 0)\n    errors.push({\n      id: \"tag-selfclosing-has-children\",\n      level: \"critical\",\n      message: `'${node2.tag}' tag should be self-closing`\n    });\n  const attributes = {\n    ...globalAttributes,\n    ...schema.attributes\n  };\n  if (schema.validate)\n    errors.push(...schema.validate(node2, config));\n  for (let [key, value] of Object.entries(node2.attributes)) {\n    const attrib = attributes[key];\n    if (!attrib) {\n      errors.push({\n        id: \"attribute-undefined\",\n        level: \"error\",\n        message: `Invalid attribute: '${key}'`\n      });\n      continue;\n    }\n    let { type, matches, errorLevel } = attrib;\n    if (ast_default.isAst(value)) {\n      if (ast_default.isFunction(value) && config.validation?.validateFunctions)\n        errors.push(...validateFunction(value, config));\n      else if (ast_default.isVariable(value) && config.variables) {\n        let missing = false;\n        let variables = config.variables;\n        for (const key2 of value.path) {\n          if (!Object.prototype.hasOwnProperty.call(variables, key2)) {\n            missing = true;\n            break;\n          }\n          variables = variables[key2];\n        }\n        if (missing) {\n          errors.push({\n            id: \"variable-undefined\",\n            level: \"error\",\n            message: `Undefined variable: '${value.path.join(\".\")}'`\n          });\n        }\n      } else\n        continue;\n    }\n    value = value;\n    if (key === \"id\" && value.match(/^[0-9]/))\n      errors.push({\n        id: \"attribute-value-invalid\",\n        level: \"error\",\n        message: \"The id attribute must not start with a number\"\n      });\n    if (type) {\n      const valid = validateType(type, value, config);\n      if (valid === false) {\n        errors.push({\n          id: \"attribute-type-invalid\",\n          level: errorLevel || \"error\",\n          message: `Attribute '${key}' must be type of '${typeToString(type)}'`\n        });\n      }\n      if (Array.isArray(valid)) {\n        errors.push(...valid);\n      }\n    }\n    if (typeof matches === \"function\")\n      matches = matches(config);\n    if (Array.isArray(matches) && !matches.includes(value))\n      errors.push({\n        id: \"attribute-value-invalid\",\n        level: errorLevel || \"error\",\n        message: `Attribute '${key}' must match one of ${JSON.stringify(matches)}. Got '${value}' instead.`\n      });\n    if (matches instanceof RegExp && !matches.test(value))\n      errors.push({\n        id: \"attribute-value-invalid\",\n        level: errorLevel || \"error\",\n        message: `Attribute '${key}' must match ${matches}. Got '${value}' instead.`\n      });\n  }\n  for (const [key, { required }] of Object.entries(attributes))\n    if (required && node2.attributes[key] === void 0)\n      errors.push({\n        id: \"attribute-missing-required\",\n        level: \"error\",\n        message: `Missing required attribute: '${key}'`\n      });\n  for (const { type } of node2.children) {\n    if (schema.children && type !== \"error\" && !schema.children.includes(type))\n      errors.push({\n        id: \"child-invalid\",\n        level: \"warning\",\n        message: `Can't nest '${type}' in '${node2.tag || node2.type}'`\n      });\n  }\n  return errors;\n}\n\n// index.ts\nvar tokenizer = new Tokenizer();\nfunction mergeConfig(config = {}) {\n  return {\n    ...config,\n    tags: {\n      ...tags_default,\n      ...config.tags\n    },\n    nodes: {\n      ...schema_exports,\n      ...config.nodes\n    },\n    functions: {\n      ...functions_default,\n      ...config.functions\n    }\n  };\n}\nfunction parse3(content, file) {\n  if (typeof content === \"string\")\n    content = tokenizer.tokenize(content);\n  return parser(content, file);\n}\nfunction resolve2(content, config) {\n  if (Array.isArray(content))\n    return content.flatMap((child) => child.resolve(config));\n  return content.resolve(config);\n}\nfunction transform2(nodes, options) {\n  const config = mergeConfig(options);\n  const content = resolve2(nodes, config);\n  if (Array.isArray(content))\n    return content.flatMap((child) => child.transform(config));\n  return content.transform(config);\n}\nfunction validate2(content, options) {\n  const config = mergeConfig(options);\n  const output = [];\n  for (const node2 of [content, ...content.walk()]) {\n    const { type, lines, location } = node2;\n    const errors = validate(node2, config);\n    for (const error2 of errors)\n      output.push({ type, lines, location, error: error2 });\n  }\n  return output;\n}\nfunction createElement(name, attributes = {}, ...children) {\n  return { name, attributes, children };\n}\nvar Markdoc = class {\n  constructor(config) {\n    this.parse = parse3;\n    this.resolve = (content) => resolve2(content, this.config);\n    this.transform = (content) => transform2(content, this.config);\n    this.validate = (content) => validate2(content, this.config);\n    this.config = config;\n  }\n};\nMarkdoc.nodes = schema_exports;\nMarkdoc.tags = tags_default;\nMarkdoc.functions = functions_default;\nMarkdoc.globalAttributes = globalAttributes;\nMarkdoc.renderers = renderers_default;\nMarkdoc.transforms = transforms_default;\nMarkdoc.Ast = ast_default;\nMarkdoc.Tag = Tag;\nMarkdoc.Tokenizer = Tokenizer;\nMarkdoc.parseTags = parseTags;\nMarkdoc.transformer = transformer_default;\nMarkdoc.validator = validate;\nMarkdoc.parse = parse3;\nMarkdoc.transform = transform2;\nMarkdoc.validate = validate2;\nMarkdoc.createElement = createElement;\nMarkdoc.truthy = truthy;\nMarkdoc.__EXPERIMENTAL__format = format;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXJrZG9jL21hcmtkb2MvZGlzdC9pbmRleC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdHQUFnRztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxvRUFBb0UsOENBQThDLElBQUksaUNBQWlDO0FBQ3hQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjLEVBQUU7QUFDakUsc0NBQXNDLEtBQUssRUFBRTtBQUM3QztBQUNBLGtEQUFrRCxJQUFJLE9BQU8sSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFnRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWdEO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxFQUFFO0FBQ3JDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDMUksaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxPQUFPLElBQUksR0FBRztBQUN6RCxxQ0FBcUMsS0FBSyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEU7QUFDQSx5Q0FBeUMsRUFBRSxjQUFjLEVBQUUsa0NBQWtDLElBQUk7QUFDakc7QUFDQSx1RkFBdUYsVUFBVSxxRkFBcUYsMkJBQTJCLFFBQVEsNEhBQTRILEdBQUcsOElBQThJO0FBQ3RlLGdDQUFnQyw2QkFBNkI7QUFDN0QsbUNBQW1DLEtBQUs7QUFDeEMsOEVBQThFLEtBQUs7QUFDbkYsK0lBQStJLEtBQUs7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZLElBQUk7QUFDNUIsNEZBQTRGO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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cUNBQXFDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQG1hcmtkb2MvbWFya2RvYy9kaXN0L2luZGV4Lm1qcz84ZDMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbT2JqZWN0LmtleXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZSAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZSkpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlID8geyBnZXQ6ICgpID0+IG1vZHVsZS5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUpO1xufTtcblxuLy8gc3JjL2dyYW1tYXIvdGFnLmpzXG52YXIgcmVxdWlyZV90YWcgPSBfX2NvbW1vbkpTKHtcbiAgXCJzcmMvZ3JhbW1hci90YWcuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICAgICAgZnVuY3Rpb24gQygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgQy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IEMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgcGVnJFN5bnRheEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGVnJHN1YmNsYXNzKHBlZyRTeW50YXhFcnJvciwgRXJyb3IpO1xuICAgIHBlZyRTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gICAgICB2YXIgREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TID0ge1xuICAgICAgICBsaXRlcmFsOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHJldHVybiAnXCInICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArICdcIic7XG4gICAgICAgIH0sXG4gICAgICAgIGNsYXNzOiBmdW5jdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGFydCkgPyBjbGFzc0VzY2FwZShwYXJ0WzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUocGFydFsxXSkgOiBjbGFzc0VzY2FwZShwYXJ0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzICsgXCJdXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGFueTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICB9LFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICB9LFxuICAgICAgICBvdGhlcjogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgIG5vdDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCJub3QgXCIgKyBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uLmV4cGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGhleChjaCkge1xuICAgICAgICByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUoczIpIHtcbiAgICAgICAgcmV0dXJuIHMyLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgIHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTtcbiAgICAgICAgfSkucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xhc3NFc2NhcGUoczIpIHtcbiAgICAgICAgcmV0dXJuIHMyLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXF0vZywgXCJcXFxcXVwiKS5yZXBsYWNlKC9cXF4vZywgXCJcXFxcXlwiKS5yZXBsYWNlKC8tL2csIFwiXFxcXC1cIikucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgIHJldHVybiBcIlxcXFx4MFwiICsgaGV4KGNoKTtcbiAgICAgICAgfSkucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4N0YtXFx4OUZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RhdGlvbikge1xuICAgICAgICByZXR1cm4gREVTQ1JJQkVfRVhQRUNUQVRJT05fRk5TW2V4cGVjdGF0aW9uLnR5cGVdKGV4cGVjdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQyKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbnMgPSBleHBlY3RlZDIubWFwKGRlc2NyaWJlRXhwZWN0YXRpb24pO1xuICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbnNbaSAtIDFdICE9PSBkZXNjcmlwdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb25zW2pdID0gZGVzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc2NyaXB0aW9ucy5sZW5ndGggPSBqO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXSArIFwiIG9yIFwiICsgZGVzY3JpcHRpb25zWzFdO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIikgKyBcIiwgb3IgXCIgKyBkZXNjcmlwdGlvbnNbZGVzY3JpcHRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZXNjcmliZUZvdW5kKGZvdW5kMikge1xuICAgICAgICByZXR1cm4gZm91bmQyID8gJ1wiJyArIGxpdGVyYWxFc2NhcGUoZm91bmQyKSArICdcIicgOiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkKSArIFwiIGJ1dCBcIiArIGRlc2NyaWJlRm91bmQoZm91bmQpICsgXCIgZm91bmQuXCI7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICB2YXIgcGVnJEZBSUxFRCA9IHt9O1xuICAgICAgdmFyIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IFRvcDogcGVnJHBhcnNlVG9wIH07XG4gICAgICB2YXIgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHBhcnNlVG9wO1xuICAgICAgdmFyIHBlZyRjMCA9IFwiL1wiO1xuICAgICAgdmFyIHBlZyRjMSA9IFwiLlwiO1xuICAgICAgdmFyIHBlZyRjMiA9IFwiI1wiO1xuICAgICAgdmFyIHBlZyRjMyA9IFwiPVwiO1xuICAgICAgdmFyIHBlZyRjNCA9IFwiKFwiO1xuICAgICAgdmFyIHBlZyRjNSA9IFwiKVwiO1xuICAgICAgdmFyIHBlZyRjNiA9IFwiLFwiO1xuICAgICAgdmFyIHBlZyRjNyA9IFwiW1wiO1xuICAgICAgdmFyIHBlZyRjOCA9IFwiXVwiO1xuICAgICAgdmFyIHBlZyRjOSA9IFwibnVsbFwiO1xuICAgICAgdmFyIHBlZyRjMTAgPSBcInRydWVcIjtcbiAgICAgIHZhciBwZWckYzExID0gXCJmYWxzZVwiO1xuICAgICAgdmFyIHBlZyRjMTIgPSBcIntcIjtcbiAgICAgIHZhciBwZWckYzEzID0gXCJ9XCI7XG4gICAgICB2YXIgcGVnJGMxNCA9IFwiOlwiO1xuICAgICAgdmFyIHBlZyRjMTUgPSBcIi1cIjtcbiAgICAgIHZhciBwZWckYzE2ID0gJ1wiJztcbiAgICAgIHZhciBwZWckYzE3ID0gXCJcXFxcXCI7XG4gICAgICB2YXIgcGVnJHIwID0gL15bJEBdLztcbiAgICAgIHZhciBwZWckcjEgPSAvXlswLTldLztcbiAgICAgIHZhciBwZWckcjIgPSAvXlteXFwwLVxceDFGXCJcXFxcXS87XG4gICAgICB2YXIgcGVnJHIzID0gL15bYS16QS1aMC05X1xcLV0vO1xuICAgICAgdmFyIHBlZyRyNCA9IC9eWyBcXG5cXHRdLztcbiAgICAgIHZhciBwZWckZTAgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiL1wiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGUxID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ0YWcgbmFtZVwiKTtcbiAgICAgIHZhciBwZWckZTIgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImNsYXNzXCIpO1xuICAgICAgdmFyIHBlZyRlMyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiaWRcIik7XG4gICAgICB2YXIgcGVnJGU0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj1cIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIoXCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTYgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiKVwiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGU3ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIixcIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlOCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwidmFyaWFibGVcIik7XG4gICAgICB2YXIgcGVnJGU5ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJudWxsXCIpO1xuICAgICAgdmFyIHBlZyRlMTAgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImJvb2xlYW5cIik7XG4gICAgICB2YXIgcGVnJGUxMSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTEyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl1cIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlMTMgPSBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwie1wiLCBmYWxzZSk7XG4gICAgICB2YXIgcGVnJGUxNCA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKTtcbiAgICAgIHZhciBwZWckZTE1ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjpcIiwgZmFsc2UpO1xuICAgICAgdmFyIHBlZyRlMTYgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcIm51bWJlclwiKTtcbiAgICAgIHZhciBwZWckZTE3ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJzdHJpbmdcIik7XG4gICAgICB2YXIgcGVnJGUxOCA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIHZhciBwZWckZTE5ID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ3aGl0ZXNwYWNlXCIpO1xuICAgICAgdmFyIHBlZyRmMCA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidmFyaWFibGVcIiwgbWV0YTogeyB2YXJpYWJsZSB9IH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhbm5vdGF0aW9uXCIsIG1ldGE6IHsgYXR0cmlidXRlcyB9IH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMiA9IGZ1bmN0aW9uKHRhZywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjMgPSBmdW5jdGlvbih0YWcsIHByaW1hcnksIGF0dHJpYnV0ZXMsIGNsb3NlKSB7XG4gICAgICAgIGlmIChwcmltYXJ5KSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgW107XG4gICAgICAgICAgYXR0cmlidXRlcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXR0cmlidXRlXCIsXG4gICAgICAgICAgICBuYW1lOiBcInByaW1hcnlcIixcbiAgICAgICAgICAgIHZhbHVlOiBwcmltYXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R5cGUsIG5lc3RpbmddID0gY2xvc2UgPyBbXCJ0YWdcIiwgMF0gOiBbXCJ0YWdfb3BlblwiLCAxXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZSwgbmVzdGluZywgbWV0YTogeyB0YWcsIGF0dHJpYnV0ZXMgfSB9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjQgPSBmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YWdfY2xvc2VcIiwgbmVzdGluZzogLTEsIG1ldGE6IHsgdGFnIH0gfTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY1ID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgICAgICByZXR1cm4gIWhlYWQgPyBbXSA6IFtoZWFkLCAuLi50YWlsXTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY2ID0gZnVuY3Rpb24oaXRlbTIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0yO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjcgPSBmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY4ID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGY5ID0gZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTAgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiY2xhc3NcIiwgbmFtZSwgdmFsdWU6IHRydWUgfTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYxMSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYXR0cmlidXRlXCIsIG5hbWU6IFwiaWRcIiwgdmFsdWUgfTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYxMiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiYXR0cmlidXRlXCIsIG5hbWUsIHZhbHVlIH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTMgPSBmdW5jdGlvbihuYW1lLCBoZWFkLCB0YWlsKSB7XG4gICAgICAgIHJldHVybiBoZWFkID8gW2hlYWQsIC4uLnRhaWxdIDogW107XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTQgPSBmdW5jdGlvbihuYW1lLCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgW2luZGV4LCB7IG5hbWU6IG5hbWUyLCB2YWx1ZSB9XSBvZiBwYXJhbXMuZW50cmllcygpKVxuICAgICAgICAgIHBhcmFtZXRlcnNbbmFtZTIgfHwgaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24zKG5hbWUsIHBhcmFtZXRlcnMpO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjE1ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYxNiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMTggPSBmdW5jdGlvbihwcmVmaXgsIGhlYWQsIHRhaWwpIHtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJAXCIpXG4gICAgICAgICAgcmV0dXJuIFtoZWFkLCAuLi50YWlsXTtcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZTIoW2hlYWQsIC4uLnRhaWxdKTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYxOSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYyMCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYyMSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjIgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgICAgIHJldHVybiBbaGVhZCwgLi4udGFpbF07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjQgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGhlYWQsIC4uLnRhaWwpO1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjI1ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IHt9O1xuICAgICAgfTtcbiAgICAgIHZhciBwZWckZjI2ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2V5ID09PSBcIiQkbWR0eXBlXCIgPyB7fSA6IHsgW2tleV06IHZhbHVlIH07XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGV4dDIoKSk7XG4gICAgICB9O1xuICAgICAgdmFyIHBlZyRmMjggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuam9pbihcIlwiKTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGYyOSA9IGZ1bmN0aW9uKHNlcXVlbmNlKSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICAgIH07XG4gICAgICB2YXIgcGVnJGN1cnJQb3MgPSAwO1xuICAgICAgdmFyIHBlZyRzYXZlZFBvcyA9IDA7XG4gICAgICB2YXIgcGVnJHBvc0RldGFpbHNDYWNoZSA9IFt7IGxpbmU6IDEsIGNvbHVtbjogMSB9XTtcbiAgICAgIHZhciBwZWckZXhwZWN0ZWQgPSBbXTtcbiAgICAgIHZhciBwZWckc2lsZW50RmFpbHMgPSAwO1xuICAgICAgdmFyIHBlZyRyZXN1bHQ7XG4gICAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcImAgKyBvcHRpb25zLnN0YXJ0UnVsZSArICdcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRleHQyKCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gcGVnJHNhdmVkUG9zO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBbcGVnJHNhdmVkUG9zLCBwZWckY3VyclBvc107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbiwgbG9jYXRpb24yKSB7XG4gICAgICAgIGxvY2F0aW9uMiA9IGxvY2F0aW9uMiAhPT0gdm9pZCAwID8gbG9jYXRpb24yIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFtwZWckb3RoZXJFeHBlY3RhdGlvbihkZXNjcmlwdGlvbildLCBpbnB1dC5zdWJzdHJpbmcocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyksIGxvY2F0aW9uMik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlcnJvcjIobWVzc2FnZSwgbG9jYXRpb24yKSB7XG4gICAgICAgIGxvY2F0aW9uMiA9IGxvY2F0aW9uMiAhPT0gdm9pZCAwID8gbG9jYXRpb24yIDogcGVnJGNvbXB1dGVMb2NhdGlvbihwZWckc2F2ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgdGhyb3cgcGVnJGJ1aWxkU2ltcGxlRXJyb3IobWVzc2FnZSwgbG9jYXRpb24yKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dDMsIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQzLCBpZ25vcmVDYXNlIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckY2xhc3NFeHBlY3RhdGlvbihwYXJ0cywgaW52ZXJ0ZWQsIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImNsYXNzXCIsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgaW52ZXJ0ZWQsXG4gICAgICAgICAgaWdub3JlQ2FzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGFueUV4cGVjdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImFueVwiIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb24gfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICAgICAgdmFyIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3Bvc107XG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAoZGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgICAgIHdoaWxlICghcGVnJHBvc0RldGFpbHNDYWNoZVtwXSkge1xuICAgICAgICAgICAgcC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXRhaWxzID0gcGVnJHBvc0RldGFpbHNDYWNoZVtwXTtcbiAgICAgICAgICBkZXRhaWxzID0ge1xuICAgICAgICAgICAgbGluZTogZGV0YWlscy5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBkZXRhaWxzLmNvbHVtblxuICAgICAgICAgIH07XG4gICAgICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHApID09PSAxMCkge1xuICAgICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHArKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHBlZyRWQUxJREZJTEVOQU1FID0gdHlwZW9mIG9wdGlvbnMuZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5maWxlbmFtZS5sZW5ndGggPiAwO1xuICAgICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVMb2NhdGlvbihzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBsb2MgPSB7fTtcbiAgICAgICAgaWYgKHBlZyRWQUxJREZJTEVOQU1FKVxuICAgICAgICAgIGxvYy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xuICAgICAgICBsb2Muc3RhcnQgPSB7XG4gICAgICAgICAgb2Zmc2V0OiBzdGFydFBvcyxcbiAgICAgICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgICAgICBjb2x1bW46IHN0YXJ0UG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBvZmZzZXQ6IGVuZFBvcyxcbiAgICAgICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBlbmRQb3NEZXRhaWxzLmNvbHVtblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbG9jO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGJlZ2luKCkge1xuICAgICAgICBwZWckZXhwZWN0ZWQucHVzaCh7IHBvczogcGVnJGN1cnJQb3MsIHZhcmlhbnRzOiBbXSB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRleHBlY3QoZXhwZWN0ZWQyKSB7XG4gICAgICAgIHZhciB0b3AgPSBwZWckZXhwZWN0ZWRbcGVnJGV4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAocGVnJGN1cnJQb3MgPCB0b3AucG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZWckY3VyclBvcyA+IHRvcC5wb3MpIHtcbiAgICAgICAgICB0b3AucG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgdG9wLnZhcmlhbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdG9wLnZhcmlhbnRzLnB1c2goZXhwZWN0ZWQyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRlbmQoaW52ZXJ0KSB7XG4gICAgICAgIHZhciBleHBlY3RlZDIgPSBwZWckZXhwZWN0ZWQucG9wKCk7XG4gICAgICAgIHZhciB0b3AgPSBwZWckZXhwZWN0ZWRbcGVnJGV4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgdmFyaWFudHMgPSBleHBlY3RlZDIudmFyaWFudHM7XG4gICAgICAgIGlmICh0b3AucG9zICE9PSBleHBlY3RlZDIucG9zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICB2YXJpYW50cyA9IHZhcmlhbnRzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50eXBlID09PSBcIm5vdFwiID8gZS5leHBlY3RlZCA6IHsgdHlwZTogXCJub3RcIiwgZXhwZWN0ZWQ6IGUgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0b3AudmFyaWFudHMsIHZhcmlhbnRzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMikge1xuICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihtZXNzYWdlLCBudWxsLCBudWxsLCBsb2NhdGlvbjIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMikge1xuICAgICAgICByZXR1cm4gbmV3IHBlZyRTeW50YXhFcnJvcihwZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMiksIGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckYnVpbGRFcnJvcigpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkMiA9IHBlZyRleHBlY3RlZFswXTtcbiAgICAgICAgdmFyIGZhaWxQb3MgPSBleHBlY3RlZDIucG9zO1xuICAgICAgICByZXR1cm4gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMi52YXJpYW50cywgZmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChmYWlsUG9zKSA6IG51bGwsIGZhaWxQb3MgPCBpbnB1dC5sZW5ndGggPyBwZWckY29tcHV0ZUxvY2F0aW9uKGZhaWxQb3MsIGZhaWxQb3MgKyAxKSA6IHBlZyRjb21wdXRlTG9jYXRpb24oZmFpbFBvcywgZmFpbFBvcykpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVG9wKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRwYXJzZVRvcExldmVsVmFsdWUoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVRhZ09wZW4oKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVRhZ0Nsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRvcExldmVsVmFsdWUoKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZVZhcmlhYmxlKCk7XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRmMChzMSk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMShzMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnT3BlbigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdOYW1lKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckZjIoczEsIHM0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVGFnQXR0cmlidXRlcygpO1xuICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNSA9IFtdO1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMCk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgICAgczYgPSBwZWckYzA7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMyhzMSwgczMsIHM0LCBzNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQ2xvc2UoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMCk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZVRhZ05hbWUoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjQoczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VUYWdOYW1lKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxKTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQXR0cmlidXRlcygpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzSXRlbSgpO1xuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlVGFnQXR0cmlidXRlc1RhaWwoKTtcbiAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VUYWdBdHRyaWJ1dGVzVGFpbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmNShzMSwgczIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZXNUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZXNJdGVtKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGY2KHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnQXR0cmlidXRlc0l0ZW0oKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZVRhZ1Nob3J0Y3V0SWQoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckZjcoczEpO1xuICAgICAgICB9XG4gICAgICAgIHMwID0gczE7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VUYWdTaG9ydGN1dENsYXNzKCk7XG4gICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGY4KHMxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZSgpO1xuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRmOShzMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VUYWdTaG9ydGN1dENsYXNzKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTIpO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgICAgIHMxID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMTAoczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVGFnU2hvcnRjdXRJZCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczI7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUzKTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzUpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjExKHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVRhZ0F0dHJpYnV0ZSgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGMzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckZjEyKHMxLCBzMyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZUZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTUpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGM0O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VGdW5jdGlvblBhcmFtZXRlcigpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM2ID0gW107XG4gICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUZ1bmN0aW9uUGFyYW1ldGVyVGFpbCgpO1xuICAgICAgICAgICAgd2hpbGUgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2LnB1c2goczcpO1xuICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZUZ1bmN0aW9uUGFyYW1ldGVyVGFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczQ7XG4gICAgICAgICAgICBzNCA9IHBlZyRmMTMoczEsIHM1LCBzNik7XG4gICAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU2KTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzU7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGYxNChzMSwgczQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VGdW5jdGlvblBhcmFtZXRlcigpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckY3VyclBvcztcbiAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMxO1xuICAgICAgICAgICAgczEgPSBwZWckZjE1KHMyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHMyID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckZjE2KHMxLCBzMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlRnVuY3Rpb25QYXJhbWV0ZXJUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTcpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlRnVuY3Rpb25QYXJhbWV0ZXIoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjE3KHM0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVHJhaWxpbmdDb21tYSgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczI7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IFtdO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNyk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjNjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhcmlhYmxlKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlOCk7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IFtdO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VWYXJpYWJsZVRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VWYXJpYWJsZVRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckZjE4KHMxLCBzMiwgczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFyaWFibGVUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICAgICAgczEgPSBwZWckYzE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYxNShzMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICAgICAgczEgPSBwZWckYzc7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VWYWx1ZU51bWJlcigpO1xuICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgczMgPSBwZWckYzg7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckZjE3KHMyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZSgpIHtcbiAgICAgICAgdmFyIHMwO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZU51bGwoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZUJvb2xlYW4oKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZVZhbHVlTnVtYmVyKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFsdWVBcnJheSgpO1xuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZUhhc2goKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlVmFyaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZU51bGwoKSB7XG4gICAgICAgIHZhciBzMCwgczE7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU5KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDQpID09PSBwZWckYzkpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjOTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRmMTkoKTtcbiAgICAgICAgfVxuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWVCb29sZWFuKCkge1xuICAgICAgICB2YXIgczAsIHMxO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTApO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNCkgPT09IHBlZyRjMTApIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMTA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckZjIwKCk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMxMSkge1xuICAgICAgICAgICAgczEgPSBwZWckYzExO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckZjIxKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlQXJyYXkoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTExKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgICAgIHMxID0gcGVnJGM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlQXJyYXlUYWlsKCk7XG4gICAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUucHVzaChzNik7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlVmFsdWVBcnJheVRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlVHJhaWxpbmdDb21tYSgpO1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRmMjIoczQsIHM1KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gW107XG4gICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxMik7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgczUgPSBwZWckYzg7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMjMoczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZUFycmF5VGFpbCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgfVxuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU3KTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZVZhbHVlKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYxNyhzNCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlSGFzaCgpIHtcbiAgICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTMpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICAgIHMxID0gcGVnJGMxMjtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IFtdO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZVZhbHVlSGFzaEl0ZW0oKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVZhbHVlSGFzaFRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNS5wdXNoKHM2KTtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VWYWx1ZUhhc2hUYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzNiA9IHBlZyRwYXJzZVRyYWlsaW5nQ29tbWEoKTtcbiAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckZjI0KHM0LCBzNSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzNCA9IFtdO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHdoaWxlIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQucHVzaChzNSk7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTQpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTI1KSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRjMTM7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMjUoczMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZUhhc2hUYWlsKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBbXTtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTcpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWVIYXNoSXRlbSgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmNihzNCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlSGFzaEl0ZW0oKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2VWYWx1ZVN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE1KTtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjMTQ7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckZjI2KHMxLCBzNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBlZyRwYXJzZVZhbHVlTnVtYmVyKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUxNik7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgczEgPSBwZWckYzE1O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJGMxO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRmMjcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlVmFsdWVTdHJpbmcoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE3KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMTY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBbXTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZVZhbHVlU3RyaW5nQ2hhcnMoKTtcbiAgICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VWYWx1ZVN0cmluZ0NoYXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMxNjtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGYyOChzMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZVN0cmluZ0NoYXJzKCkge1xuICAgICAgICB2YXIgczA7XG4gICAgICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGVnJHIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VWYWx1ZVN0cmluZ0VzY2FwZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VWYWx1ZVN0cmluZ0VzY2FwZXMoKSB7XG4gICAgICAgIHZhciBzMCwgczEsIHMyO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICAgIHMxID0gcGVnJGMxNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRjMTY7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRjMTc7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRmMjkoczIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwZWckcGFyc2VJZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgczAsIHMxLCBzMjtcbiAgICAgICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTE4KTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gW107XG4gICAgICAgIGlmIChwZWckcjMudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgICAgaWYgKHBlZyRyMy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gaW5wdXQuc3Vic3RyaW5nKHMwLCBwZWckY3VyclBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfVxuICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgcmV0dXJuIHMwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGVnJHBhcnNlXygpIHtcbiAgICAgICAgdmFyIHMwO1xuICAgICAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMTkpO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgaWYgKHBlZyRyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICByZXR1cm4gczA7XG4gICAgICB9XG4gICAgICBjb25zdCB7IFZhcmlhYmxlOiBWYXJpYWJsZTIsIEZ1bmN0aW9uOiBGdW5jdGlvbjMgfSA9IG9wdGlvbnM7XG4gICAgICBwZWckYmVnaW4oKTtcbiAgICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcbiAgICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgIHBlZyRleHBlY3QocGVnJGVuZEV4cGVjdGF0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHBlZyRidWlsZEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgU3ludGF4RXJyb3I6IHBlZyRTeW50YXhFcnJvcixcbiAgICAgIHBhcnNlOiBwZWckcGFyc2VcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL2VudGl0aWVzLmpzb25cbnZhciByZXF1aXJlX2VudGl0aWVzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9tYXBzL2VudGl0aWVzLmpzb25cIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsgQWFjdXRlOiBcIlxceEMxXCIsIGFhY3V0ZTogXCJcXHhFMVwiLCBBYnJldmU6IFwiXFx1MDEwMlwiLCBhYnJldmU6IFwiXFx1MDEwM1wiLCBhYzogXCJcXHUyMjNFXCIsIGFjZDogXCJcXHUyMjNGXCIsIGFjRTogXCJcXHUyMjNFXFx1MDMzM1wiLCBBY2lyYzogXCJcXHhDMlwiLCBhY2lyYzogXCJcXHhFMlwiLCBhY3V0ZTogXCJcXHhCNFwiLCBBY3k6IFwiXFx1MDQxMFwiLCBhY3k6IFwiXFx1MDQzMFwiLCBBRWxpZzogXCJcXHhDNlwiLCBhZWxpZzogXCJcXHhFNlwiLCBhZjogXCJcXHUyMDYxXCIsIEFmcjogXCJcXHV7MUQ1MDR9XCIsIGFmcjogXCJcXHV7MUQ1MUV9XCIsIEFncmF2ZTogXCJcXHhDMFwiLCBhZ3JhdmU6IFwiXFx4RTBcIiwgYWxlZnN5bTogXCJcXHUyMTM1XCIsIGFsZXBoOiBcIlxcdTIxMzVcIiwgQWxwaGE6IFwiXFx1MDM5MVwiLCBhbHBoYTogXCJcXHUwM0IxXCIsIEFtYWNyOiBcIlxcdTAxMDBcIiwgYW1hY3I6IFwiXFx1MDEwMVwiLCBhbWFsZzogXCJcXHUyQTNGXCIsIGFtcDogXCImXCIsIEFNUDogXCImXCIsIGFuZGFuZDogXCJcXHUyQTU1XCIsIEFuZDogXCJcXHUyQTUzXCIsIGFuZDogXCJcXHUyMjI3XCIsIGFuZGQ6IFwiXFx1MkE1Q1wiLCBhbmRzbG9wZTogXCJcXHUyQTU4XCIsIGFuZHY6IFwiXFx1MkE1QVwiLCBhbmc6IFwiXFx1MjIyMFwiLCBhbmdlOiBcIlxcdTI5QTRcIiwgYW5nbGU6IFwiXFx1MjIyMFwiLCBhbmdtc2RhYTogXCJcXHUyOUE4XCIsIGFuZ21zZGFiOiBcIlxcdTI5QTlcIiwgYW5nbXNkYWM6IFwiXFx1MjlBQVwiLCBhbmdtc2RhZDogXCJcXHUyOUFCXCIsIGFuZ21zZGFlOiBcIlxcdTI5QUNcIiwgYW5nbXNkYWY6IFwiXFx1MjlBRFwiLCBhbmdtc2RhZzogXCJcXHUyOUFFXCIsIGFuZ21zZGFoOiBcIlxcdTI5QUZcIiwgYW5nbXNkOiBcIlxcdTIyMjFcIiwgYW5ncnQ6IFwiXFx1MjIxRlwiLCBhbmdydHZiOiBcIlxcdTIyQkVcIiwgYW5ncnR2YmQ6IFwiXFx1Mjk5RFwiLCBhbmdzcGg6IFwiXFx1MjIyMlwiLCBhbmdzdDogXCJcXHhDNVwiLCBhbmd6YXJyOiBcIlxcdTIzN0NcIiwgQW9nb246IFwiXFx1MDEwNFwiLCBhb2dvbjogXCJcXHUwMTA1XCIsIEFvcGY6IFwiXFx1ezFENTM4fVwiLCBhb3BmOiBcIlxcdXsxRDU1Mn1cIiwgYXBhY2lyOiBcIlxcdTJBNkZcIiwgYXA6IFwiXFx1MjI0OFwiLCBhcEU6IFwiXFx1MkE3MFwiLCBhcGU6IFwiXFx1MjI0QVwiLCBhcGlkOiBcIlxcdTIyNEJcIiwgYXBvczogXCInXCIsIEFwcGx5RnVuY3Rpb246IFwiXFx1MjA2MVwiLCBhcHByb3g6IFwiXFx1MjI0OFwiLCBhcHByb3hlcTogXCJcXHUyMjRBXCIsIEFyaW5nOiBcIlxceEM1XCIsIGFyaW5nOiBcIlxceEU1XCIsIEFzY3I6IFwiXFx1ezFENDlDfVwiLCBhc2NyOiBcIlxcdXsxRDRCNn1cIiwgQXNzaWduOiBcIlxcdTIyNTRcIiwgYXN0OiBcIipcIiwgYXN5bXA6IFwiXFx1MjI0OFwiLCBhc3ltcGVxOiBcIlxcdTIyNERcIiwgQXRpbGRlOiBcIlxceEMzXCIsIGF0aWxkZTogXCJcXHhFM1wiLCBBdW1sOiBcIlxceEM0XCIsIGF1bWw6IFwiXFx4RTRcIiwgYXdjb25pbnQ6IFwiXFx1MjIzM1wiLCBhd2ludDogXCJcXHUyQTExXCIsIGJhY2tjb25nOiBcIlxcdTIyNENcIiwgYmFja2Vwc2lsb246IFwiXFx1MDNGNlwiLCBiYWNrcHJpbWU6IFwiXFx1MjAzNVwiLCBiYWNrc2ltOiBcIlxcdTIyM0RcIiwgYmFja3NpbWVxOiBcIlxcdTIyQ0RcIiwgQmFja3NsYXNoOiBcIlxcdTIyMTZcIiwgQmFydjogXCJcXHUyQUU3XCIsIGJhcnZlZTogXCJcXHUyMkJEXCIsIGJhcndlZDogXCJcXHUyMzA1XCIsIEJhcndlZDogXCJcXHUyMzA2XCIsIGJhcndlZGdlOiBcIlxcdTIzMDVcIiwgYmJyazogXCJcXHUyM0I1XCIsIGJicmt0YnJrOiBcIlxcdTIzQjZcIiwgYmNvbmc6IFwiXFx1MjI0Q1wiLCBCY3k6IFwiXFx1MDQxMVwiLCBiY3k6IFwiXFx1MDQzMVwiLCBiZHF1bzogXCJcXHUyMDFFXCIsIGJlY2F1czogXCJcXHUyMjM1XCIsIGJlY2F1c2U6IFwiXFx1MjIzNVwiLCBCZWNhdXNlOiBcIlxcdTIyMzVcIiwgYmVtcHR5djogXCJcXHUyOUIwXCIsIGJlcHNpOiBcIlxcdTAzRjZcIiwgYmVybm91OiBcIlxcdTIxMkNcIiwgQmVybm91bGxpczogXCJcXHUyMTJDXCIsIEJldGE6IFwiXFx1MDM5MlwiLCBiZXRhOiBcIlxcdTAzQjJcIiwgYmV0aDogXCJcXHUyMTM2XCIsIGJldHdlZW46IFwiXFx1MjI2Q1wiLCBCZnI6IFwiXFx1ezFENTA1fVwiLCBiZnI6IFwiXFx1ezFENTFGfVwiLCBiaWdjYXA6IFwiXFx1MjJDMlwiLCBiaWdjaXJjOiBcIlxcdTI1RUZcIiwgYmlnY3VwOiBcIlxcdTIyQzNcIiwgYmlnb2RvdDogXCJcXHUyQTAwXCIsIGJpZ29wbHVzOiBcIlxcdTJBMDFcIiwgYmlnb3RpbWVzOiBcIlxcdTJBMDJcIiwgYmlnc3FjdXA6IFwiXFx1MkEwNlwiLCBiaWdzdGFyOiBcIlxcdTI2MDVcIiwgYmlndHJpYW5nbGVkb3duOiBcIlxcdTI1QkRcIiwgYmlndHJpYW5nbGV1cDogXCJcXHUyNUIzXCIsIGJpZ3VwbHVzOiBcIlxcdTJBMDRcIiwgYmlndmVlOiBcIlxcdTIyQzFcIiwgYmlnd2VkZ2U6IFwiXFx1MjJDMFwiLCBia2Fyb3c6IFwiXFx1MjkwRFwiLCBibGFja2xvemVuZ2U6IFwiXFx1MjlFQlwiLCBibGFja3NxdWFyZTogXCJcXHUyNUFBXCIsIGJsYWNrdHJpYW5nbGU6IFwiXFx1MjVCNFwiLCBibGFja3RyaWFuZ2xlZG93bjogXCJcXHUyNUJFXCIsIGJsYWNrdHJpYW5nbGVsZWZ0OiBcIlxcdTI1QzJcIiwgYmxhY2t0cmlhbmdsZXJpZ2h0OiBcIlxcdTI1QjhcIiwgYmxhbms6IFwiXFx1MjQyM1wiLCBibGsxMjogXCJcXHUyNTkyXCIsIGJsazE0OiBcIlxcdTI1OTFcIiwgYmxrMzQ6IFwiXFx1MjU5M1wiLCBibG9jazogXCJcXHUyNTg4XCIsIGJuZTogXCI9XFx1MjBFNVwiLCBibmVxdWl2OiBcIlxcdTIyNjFcXHUyMEU1XCIsIGJOb3Q6IFwiXFx1MkFFRFwiLCBibm90OiBcIlxcdTIzMTBcIiwgQm9wZjogXCJcXHV7MUQ1Mzl9XCIsIGJvcGY6IFwiXFx1ezFENTUzfVwiLCBib3Q6IFwiXFx1MjJBNVwiLCBib3R0b206IFwiXFx1MjJBNVwiLCBib3d0aWU6IFwiXFx1MjJDOFwiLCBib3hib3g6IFwiXFx1MjlDOVwiLCBib3hkbDogXCJcXHUyNTEwXCIsIGJveGRMOiBcIlxcdTI1NTVcIiwgYm94RGw6IFwiXFx1MjU1NlwiLCBib3hETDogXCJcXHUyNTU3XCIsIGJveGRyOiBcIlxcdTI1MENcIiwgYm94ZFI6IFwiXFx1MjU1MlwiLCBib3hEcjogXCJcXHUyNTUzXCIsIGJveERSOiBcIlxcdTI1NTRcIiwgYm94aDogXCJcXHUyNTAwXCIsIGJveEg6IFwiXFx1MjU1MFwiLCBib3hoZDogXCJcXHUyNTJDXCIsIGJveEhkOiBcIlxcdTI1NjRcIiwgYm94aEQ6IFwiXFx1MjU2NVwiLCBib3hIRDogXCJcXHUyNTY2XCIsIGJveGh1OiBcIlxcdTI1MzRcIiwgYm94SHU6IFwiXFx1MjU2N1wiLCBib3hoVTogXCJcXHUyNTY4XCIsIGJveEhVOiBcIlxcdTI1NjlcIiwgYm94bWludXM6IFwiXFx1MjI5RlwiLCBib3hwbHVzOiBcIlxcdTIyOUVcIiwgYm94dGltZXM6IFwiXFx1MjJBMFwiLCBib3h1bDogXCJcXHUyNTE4XCIsIGJveHVMOiBcIlxcdTI1NUJcIiwgYm94VWw6IFwiXFx1MjU1Q1wiLCBib3hVTDogXCJcXHUyNTVEXCIsIGJveHVyOiBcIlxcdTI1MTRcIiwgYm94dVI6IFwiXFx1MjU1OFwiLCBib3hVcjogXCJcXHUyNTU5XCIsIGJveFVSOiBcIlxcdTI1NUFcIiwgYm94djogXCJcXHUyNTAyXCIsIGJveFY6IFwiXFx1MjU1MVwiLCBib3h2aDogXCJcXHUyNTNDXCIsIGJveHZIOiBcIlxcdTI1NkFcIiwgYm94Vmg6IFwiXFx1MjU2QlwiLCBib3hWSDogXCJcXHUyNTZDXCIsIGJveHZsOiBcIlxcdTI1MjRcIiwgYm94dkw6IFwiXFx1MjU2MVwiLCBib3hWbDogXCJcXHUyNTYyXCIsIGJveFZMOiBcIlxcdTI1NjNcIiwgYm94dnI6IFwiXFx1MjUxQ1wiLCBib3h2UjogXCJcXHUyNTVFXCIsIGJveFZyOiBcIlxcdTI1NUZcIiwgYm94VlI6IFwiXFx1MjU2MFwiLCBicHJpbWU6IFwiXFx1MjAzNVwiLCBicmV2ZTogXCJcXHUwMkQ4XCIsIEJyZXZlOiBcIlxcdTAyRDhcIiwgYnJ2YmFyOiBcIlxceEE2XCIsIGJzY3I6IFwiXFx1ezFENEI3fVwiLCBCc2NyOiBcIlxcdTIxMkNcIiwgYnNlbWk6IFwiXFx1MjA0RlwiLCBic2ltOiBcIlxcdTIyM0RcIiwgYnNpbWU6IFwiXFx1MjJDRFwiLCBic29sYjogXCJcXHUyOUM1XCIsIGJzb2w6IFwiXFxcXFwiLCBic29saHN1YjogXCJcXHUyN0M4XCIsIGJ1bGw6IFwiXFx1MjAyMlwiLCBidWxsZXQ6IFwiXFx1MjAyMlwiLCBidW1wOiBcIlxcdTIyNEVcIiwgYnVtcEU6IFwiXFx1MkFBRVwiLCBidW1wZTogXCJcXHUyMjRGXCIsIEJ1bXBlcTogXCJcXHUyMjRFXCIsIGJ1bXBlcTogXCJcXHUyMjRGXCIsIENhY3V0ZTogXCJcXHUwMTA2XCIsIGNhY3V0ZTogXCJcXHUwMTA3XCIsIGNhcGFuZDogXCJcXHUyQTQ0XCIsIGNhcGJyY3VwOiBcIlxcdTJBNDlcIiwgY2FwY2FwOiBcIlxcdTJBNEJcIiwgY2FwOiBcIlxcdTIyMjlcIiwgQ2FwOiBcIlxcdTIyRDJcIiwgY2FwY3VwOiBcIlxcdTJBNDdcIiwgY2FwZG90OiBcIlxcdTJBNDBcIiwgQ2FwaXRhbERpZmZlcmVudGlhbEQ6IFwiXFx1MjE0NVwiLCBjYXBzOiBcIlxcdTIyMjlcXHVGRTAwXCIsIGNhcmV0OiBcIlxcdTIwNDFcIiwgY2Fyb246IFwiXFx1MDJDN1wiLCBDYXlsZXlzOiBcIlxcdTIxMkRcIiwgY2NhcHM6IFwiXFx1MkE0RFwiLCBDY2Fyb246IFwiXFx1MDEwQ1wiLCBjY2Fyb246IFwiXFx1MDEwRFwiLCBDY2VkaWw6IFwiXFx4QzdcIiwgY2NlZGlsOiBcIlxceEU3XCIsIENjaXJjOiBcIlxcdTAxMDhcIiwgY2NpcmM6IFwiXFx1MDEwOVwiLCBDY29uaW50OiBcIlxcdTIyMzBcIiwgY2N1cHM6IFwiXFx1MkE0Q1wiLCBjY3Vwc3NtOiBcIlxcdTJBNTBcIiwgQ2RvdDogXCJcXHUwMTBBXCIsIGNkb3Q6IFwiXFx1MDEwQlwiLCBjZWRpbDogXCJcXHhCOFwiLCBDZWRpbGxhOiBcIlxceEI4XCIsIGNlbXB0eXY6IFwiXFx1MjlCMlwiLCBjZW50OiBcIlxceEEyXCIsIGNlbnRlcmRvdDogXCJcXHhCN1wiLCBDZW50ZXJEb3Q6IFwiXFx4QjdcIiwgY2ZyOiBcIlxcdXsxRDUyMH1cIiwgQ2ZyOiBcIlxcdTIxMkRcIiwgQ0hjeTogXCJcXHUwNDI3XCIsIGNoY3k6IFwiXFx1MDQ0N1wiLCBjaGVjazogXCJcXHUyNzEzXCIsIGNoZWNrbWFyazogXCJcXHUyNzEzXCIsIENoaTogXCJcXHUwM0E3XCIsIGNoaTogXCJcXHUwM0M3XCIsIGNpcmM6IFwiXFx1MDJDNlwiLCBjaXJjZXE6IFwiXFx1MjI1N1wiLCBjaXJjbGVhcnJvd2xlZnQ6IFwiXFx1MjFCQVwiLCBjaXJjbGVhcnJvd3JpZ2h0OiBcIlxcdTIxQkJcIiwgY2lyY2xlZGFzdDogXCJcXHUyMjlCXCIsIGNpcmNsZWRjaXJjOiBcIlxcdTIyOUFcIiwgY2lyY2xlZGRhc2g6IFwiXFx1MjI5RFwiLCBDaXJjbGVEb3Q6IFwiXFx1MjI5OVwiLCBjaXJjbGVkUjogXCJcXHhBRVwiLCBjaXJjbGVkUzogXCJcXHUyNEM4XCIsIENpcmNsZU1pbnVzOiBcIlxcdTIyOTZcIiwgQ2lyY2xlUGx1czogXCJcXHUyMjk1XCIsIENpcmNsZVRpbWVzOiBcIlxcdTIyOTdcIiwgY2lyOiBcIlxcdTI1Q0JcIiwgY2lyRTogXCJcXHUyOUMzXCIsIGNpcmU6IFwiXFx1MjI1N1wiLCBjaXJmbmludDogXCJcXHUyQTEwXCIsIGNpcm1pZDogXCJcXHUyQUVGXCIsIGNpcnNjaXI6IFwiXFx1MjlDMlwiLCBDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IFwiXFx1MjIzMlwiLCBDbG9zZUN1cmx5RG91YmxlUXVvdGU6IFwiXFx1MjAxRFwiLCBDbG9zZUN1cmx5UXVvdGU6IFwiXFx1MjAxOVwiLCBjbHViczogXCJcXHUyNjYzXCIsIGNsdWJzdWl0OiBcIlxcdTI2NjNcIiwgY29sb246IFwiOlwiLCBDb2xvbjogXCJcXHUyMjM3XCIsIENvbG9uZTogXCJcXHUyQTc0XCIsIGNvbG9uZTogXCJcXHUyMjU0XCIsIGNvbG9uZXE6IFwiXFx1MjI1NFwiLCBjb21tYTogXCIsXCIsIGNvbW1hdDogXCJAXCIsIGNvbXA6IFwiXFx1MjIwMVwiLCBjb21wZm46IFwiXFx1MjIxOFwiLCBjb21wbGVtZW50OiBcIlxcdTIyMDFcIiwgY29tcGxleGVzOiBcIlxcdTIxMDJcIiwgY29uZzogXCJcXHUyMjQ1XCIsIGNvbmdkb3Q6IFwiXFx1MkE2RFwiLCBDb25ncnVlbnQ6IFwiXFx1MjI2MVwiLCBjb25pbnQ6IFwiXFx1MjIyRVwiLCBDb25pbnQ6IFwiXFx1MjIyRlwiLCBDb250b3VySW50ZWdyYWw6IFwiXFx1MjIyRVwiLCBjb3BmOiBcIlxcdXsxRDU1NH1cIiwgQ29wZjogXCJcXHUyMTAyXCIsIGNvcHJvZDogXCJcXHUyMjEwXCIsIENvcHJvZHVjdDogXCJcXHUyMjEwXCIsIGNvcHk6IFwiXFx4QTlcIiwgQ09QWTogXCJcXHhBOVwiLCBjb3B5c3I6IFwiXFx1MjExN1wiLCBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiBcIlxcdTIyMzNcIiwgY3JhcnI6IFwiXFx1MjFCNVwiLCBjcm9zczogXCJcXHUyNzE3XCIsIENyb3NzOiBcIlxcdTJBMkZcIiwgQ3NjcjogXCJcXHV7MUQ0OUV9XCIsIGNzY3I6IFwiXFx1ezFENEI4fVwiLCBjc3ViOiBcIlxcdTJBQ0ZcIiwgY3N1YmU6IFwiXFx1MkFEMVwiLCBjc3VwOiBcIlxcdTJBRDBcIiwgY3N1cGU6IFwiXFx1MkFEMlwiLCBjdGRvdDogXCJcXHUyMkVGXCIsIGN1ZGFycmw6IFwiXFx1MjkzOFwiLCBjdWRhcnJyOiBcIlxcdTI5MzVcIiwgY3VlcHI6IFwiXFx1MjJERVwiLCBjdWVzYzogXCJcXHUyMkRGXCIsIGN1bGFycjogXCJcXHUyMUI2XCIsIGN1bGFycnA6IFwiXFx1MjkzRFwiLCBjdXBicmNhcDogXCJcXHUyQTQ4XCIsIGN1cGNhcDogXCJcXHUyQTQ2XCIsIEN1cENhcDogXCJcXHUyMjREXCIsIGN1cDogXCJcXHUyMjJBXCIsIEN1cDogXCJcXHUyMkQzXCIsIGN1cGN1cDogXCJcXHUyQTRBXCIsIGN1cGRvdDogXCJcXHUyMjhEXCIsIGN1cG9yOiBcIlxcdTJBNDVcIiwgY3VwczogXCJcXHUyMjJBXFx1RkUwMFwiLCBjdXJhcnI6IFwiXFx1MjFCN1wiLCBjdXJhcnJtOiBcIlxcdTI5M0NcIiwgY3VybHllcXByZWM6IFwiXFx1MjJERVwiLCBjdXJseWVxc3VjYzogXCJcXHUyMkRGXCIsIGN1cmx5dmVlOiBcIlxcdTIyQ0VcIiwgY3VybHl3ZWRnZTogXCJcXHUyMkNGXCIsIGN1cnJlbjogXCJcXHhBNFwiLCBjdXJ2ZWFycm93bGVmdDogXCJcXHUyMUI2XCIsIGN1cnZlYXJyb3dyaWdodDogXCJcXHUyMUI3XCIsIGN1dmVlOiBcIlxcdTIyQ0VcIiwgY3V3ZWQ6IFwiXFx1MjJDRlwiLCBjd2NvbmludDogXCJcXHUyMjMyXCIsIGN3aW50OiBcIlxcdTIyMzFcIiwgY3lsY3R5OiBcIlxcdTIzMkRcIiwgZGFnZ2VyOiBcIlxcdTIwMjBcIiwgRGFnZ2VyOiBcIlxcdTIwMjFcIiwgZGFsZXRoOiBcIlxcdTIxMzhcIiwgZGFycjogXCJcXHUyMTkzXCIsIERhcnI6IFwiXFx1MjFBMVwiLCBkQXJyOiBcIlxcdTIxRDNcIiwgZGFzaDogXCJcXHUyMDEwXCIsIERhc2h2OiBcIlxcdTJBRTRcIiwgZGFzaHY6IFwiXFx1MjJBM1wiLCBkYmthcm93OiBcIlxcdTI5MEZcIiwgZGJsYWM6IFwiXFx1MDJERFwiLCBEY2Fyb246IFwiXFx1MDEwRVwiLCBkY2Fyb246IFwiXFx1MDEwRlwiLCBEY3k6IFwiXFx1MDQxNFwiLCBkY3k6IFwiXFx1MDQzNFwiLCBkZGFnZ2VyOiBcIlxcdTIwMjFcIiwgZGRhcnI6IFwiXFx1MjFDQVwiLCBERDogXCJcXHUyMTQ1XCIsIGRkOiBcIlxcdTIxNDZcIiwgRERvdHJhaGQ6IFwiXFx1MjkxMVwiLCBkZG90c2VxOiBcIlxcdTJBNzdcIiwgZGVnOiBcIlxceEIwXCIsIERlbDogXCJcXHUyMjA3XCIsIERlbHRhOiBcIlxcdTAzOTRcIiwgZGVsdGE6IFwiXFx1MDNCNFwiLCBkZW1wdHl2OiBcIlxcdTI5QjFcIiwgZGZpc2h0OiBcIlxcdTI5N0ZcIiwgRGZyOiBcIlxcdXsxRDUwN31cIiwgZGZyOiBcIlxcdXsxRDUyMX1cIiwgZEhhcjogXCJcXHUyOTY1XCIsIGRoYXJsOiBcIlxcdTIxQzNcIiwgZGhhcnI6IFwiXFx1MjFDMlwiLCBEaWFjcml0aWNhbEFjdXRlOiBcIlxceEI0XCIsIERpYWNyaXRpY2FsRG90OiBcIlxcdTAyRDlcIiwgRGlhY3JpdGljYWxEb3VibGVBY3V0ZTogXCJcXHUwMkREXCIsIERpYWNyaXRpY2FsR3JhdmU6IFwiYFwiLCBEaWFjcml0aWNhbFRpbGRlOiBcIlxcdTAyRENcIiwgZGlhbTogXCJcXHUyMkM0XCIsIGRpYW1vbmQ6IFwiXFx1MjJDNFwiLCBEaWFtb25kOiBcIlxcdTIyQzRcIiwgZGlhbW9uZHN1aXQ6IFwiXFx1MjY2NlwiLCBkaWFtczogXCJcXHUyNjY2XCIsIGRpZTogXCJcXHhBOFwiLCBEaWZmZXJlbnRpYWxEOiBcIlxcdTIxNDZcIiwgZGlnYW1tYTogXCJcXHUwM0REXCIsIGRpc2luOiBcIlxcdTIyRjJcIiwgZGl2OiBcIlxceEY3XCIsIGRpdmlkZTogXCJcXHhGN1wiLCBkaXZpZGVvbnRpbWVzOiBcIlxcdTIyQzdcIiwgZGl2b254OiBcIlxcdTIyQzdcIiwgREpjeTogXCJcXHUwNDAyXCIsIGRqY3k6IFwiXFx1MDQ1MlwiLCBkbGNvcm46IFwiXFx1MjMxRVwiLCBkbGNyb3A6IFwiXFx1MjMwRFwiLCBkb2xsYXI6IFwiJFwiLCBEb3BmOiBcIlxcdXsxRDUzQn1cIiwgZG9wZjogXCJcXHV7MUQ1NTV9XCIsIERvdDogXCJcXHhBOFwiLCBkb3Q6IFwiXFx1MDJEOVwiLCBEb3REb3Q6IFwiXFx1MjBEQ1wiLCBkb3RlcTogXCJcXHUyMjUwXCIsIGRvdGVxZG90OiBcIlxcdTIyNTFcIiwgRG90RXF1YWw6IFwiXFx1MjI1MFwiLCBkb3RtaW51czogXCJcXHUyMjM4XCIsIGRvdHBsdXM6IFwiXFx1MjIxNFwiLCBkb3RzcXVhcmU6IFwiXFx1MjJBMVwiLCBkb3VibGViYXJ3ZWRnZTogXCJcXHUyMzA2XCIsIERvdWJsZUNvbnRvdXJJbnRlZ3JhbDogXCJcXHUyMjJGXCIsIERvdWJsZURvdDogXCJcXHhBOFwiLCBEb3VibGVEb3duQXJyb3c6IFwiXFx1MjFEM1wiLCBEb3VibGVMZWZ0QXJyb3c6IFwiXFx1MjFEMFwiLCBEb3VibGVMZWZ0UmlnaHRBcnJvdzogXCJcXHUyMUQ0XCIsIERvdWJsZUxlZnRUZWU6IFwiXFx1MkFFNFwiLCBEb3VibGVMb25nTGVmdEFycm93OiBcIlxcdTI3RjhcIiwgRG91YmxlTG9uZ0xlZnRSaWdodEFycm93OiBcIlxcdTI3RkFcIiwgRG91YmxlTG9uZ1JpZ2h0QXJyb3c6IFwiXFx1MjdGOVwiLCBEb3VibGVSaWdodEFycm93OiBcIlxcdTIxRDJcIiwgRG91YmxlUmlnaHRUZWU6IFwiXFx1MjJBOFwiLCBEb3VibGVVcEFycm93OiBcIlxcdTIxRDFcIiwgRG91YmxlVXBEb3duQXJyb3c6IFwiXFx1MjFENVwiLCBEb3VibGVWZXJ0aWNhbEJhcjogXCJcXHUyMjI1XCIsIERvd25BcnJvd0JhcjogXCJcXHUyOTEzXCIsIGRvd25hcnJvdzogXCJcXHUyMTkzXCIsIERvd25BcnJvdzogXCJcXHUyMTkzXCIsIERvd25hcnJvdzogXCJcXHUyMUQzXCIsIERvd25BcnJvd1VwQXJyb3c6IFwiXFx1MjFGNVwiLCBEb3duQnJldmU6IFwiXFx1MDMxMVwiLCBkb3duZG93bmFycm93czogXCJcXHUyMUNBXCIsIGRvd25oYXJwb29ubGVmdDogXCJcXHUyMUMzXCIsIGRvd25oYXJwb29ucmlnaHQ6IFwiXFx1MjFDMlwiLCBEb3duTGVmdFJpZ2h0VmVjdG9yOiBcIlxcdTI5NTBcIiwgRG93bkxlZnRUZWVWZWN0b3I6IFwiXFx1Mjk1RVwiLCBEb3duTGVmdFZlY3RvckJhcjogXCJcXHUyOTU2XCIsIERvd25MZWZ0VmVjdG9yOiBcIlxcdTIxQkRcIiwgRG93blJpZ2h0VGVlVmVjdG9yOiBcIlxcdTI5NUZcIiwgRG93blJpZ2h0VmVjdG9yQmFyOiBcIlxcdTI5NTdcIiwgRG93blJpZ2h0VmVjdG9yOiBcIlxcdTIxQzFcIiwgRG93blRlZUFycm93OiBcIlxcdTIxQTdcIiwgRG93blRlZTogXCJcXHUyMkE0XCIsIGRyYmthcm93OiBcIlxcdTI5MTBcIiwgZHJjb3JuOiBcIlxcdTIzMUZcIiwgZHJjcm9wOiBcIlxcdTIzMENcIiwgRHNjcjogXCJcXHV7MUQ0OUZ9XCIsIGRzY3I6IFwiXFx1ezFENEI5fVwiLCBEU2N5OiBcIlxcdTA0MDVcIiwgZHNjeTogXCJcXHUwNDU1XCIsIGRzb2w6IFwiXFx1MjlGNlwiLCBEc3Ryb2s6IFwiXFx1MDExMFwiLCBkc3Ryb2s6IFwiXFx1MDExMVwiLCBkdGRvdDogXCJcXHUyMkYxXCIsIGR0cmk6IFwiXFx1MjVCRlwiLCBkdHJpZjogXCJcXHUyNUJFXCIsIGR1YXJyOiBcIlxcdTIxRjVcIiwgZHVoYXI6IFwiXFx1Mjk2RlwiLCBkd2FuZ2xlOiBcIlxcdTI5QTZcIiwgRFpjeTogXCJcXHUwNDBGXCIsIGR6Y3k6IFwiXFx1MDQ1RlwiLCBkemlncmFycjogXCJcXHUyN0ZGXCIsIEVhY3V0ZTogXCJcXHhDOVwiLCBlYWN1dGU6IFwiXFx4RTlcIiwgZWFzdGVyOiBcIlxcdTJBNkVcIiwgRWNhcm9uOiBcIlxcdTAxMUFcIiwgZWNhcm9uOiBcIlxcdTAxMUJcIiwgRWNpcmM6IFwiXFx4Q0FcIiwgZWNpcmM6IFwiXFx4RUFcIiwgZWNpcjogXCJcXHUyMjU2XCIsIGVjb2xvbjogXCJcXHUyMjU1XCIsIEVjeTogXCJcXHUwNDJEXCIsIGVjeTogXCJcXHUwNDREXCIsIGVERG90OiBcIlxcdTJBNzdcIiwgRWRvdDogXCJcXHUwMTE2XCIsIGVkb3Q6IFwiXFx1MDExN1wiLCBlRG90OiBcIlxcdTIyNTFcIiwgZWU6IFwiXFx1MjE0N1wiLCBlZkRvdDogXCJcXHUyMjUyXCIsIEVmcjogXCJcXHV7MUQ1MDh9XCIsIGVmcjogXCJcXHV7MUQ1MjJ9XCIsIGVnOiBcIlxcdTJBOUFcIiwgRWdyYXZlOiBcIlxceEM4XCIsIGVncmF2ZTogXCJcXHhFOFwiLCBlZ3M6IFwiXFx1MkE5NlwiLCBlZ3Nkb3Q6IFwiXFx1MkE5OFwiLCBlbDogXCJcXHUyQTk5XCIsIEVsZW1lbnQ6IFwiXFx1MjIwOFwiLCBlbGludGVyczogXCJcXHUyM0U3XCIsIGVsbDogXCJcXHUyMTEzXCIsIGVsczogXCJcXHUyQTk1XCIsIGVsc2RvdDogXCJcXHUyQTk3XCIsIEVtYWNyOiBcIlxcdTAxMTJcIiwgZW1hY3I6IFwiXFx1MDExM1wiLCBlbXB0eTogXCJcXHUyMjA1XCIsIGVtcHR5c2V0OiBcIlxcdTIyMDVcIiwgRW1wdHlTbWFsbFNxdWFyZTogXCJcXHUyNUZCXCIsIGVtcHR5djogXCJcXHUyMjA1XCIsIEVtcHR5VmVyeVNtYWxsU3F1YXJlOiBcIlxcdTI1QUJcIiwgZW1zcDEzOiBcIlxcdTIwMDRcIiwgZW1zcDE0OiBcIlxcdTIwMDVcIiwgZW1zcDogXCJcXHUyMDAzXCIsIEVORzogXCJcXHUwMTRBXCIsIGVuZzogXCJcXHUwMTRCXCIsIGVuc3A6IFwiXFx1MjAwMlwiLCBFb2dvbjogXCJcXHUwMTE4XCIsIGVvZ29uOiBcIlxcdTAxMTlcIiwgRW9wZjogXCJcXHV7MUQ1M0N9XCIsIGVvcGY6IFwiXFx1ezFENTU2fVwiLCBlcGFyOiBcIlxcdTIyRDVcIiwgZXBhcnNsOiBcIlxcdTI5RTNcIiwgZXBsdXM6IFwiXFx1MkE3MVwiLCBlcHNpOiBcIlxcdTAzQjVcIiwgRXBzaWxvbjogXCJcXHUwMzk1XCIsIGVwc2lsb246IFwiXFx1MDNCNVwiLCBlcHNpdjogXCJcXHUwM0Y1XCIsIGVxY2lyYzogXCJcXHUyMjU2XCIsIGVxY29sb246IFwiXFx1MjI1NVwiLCBlcXNpbTogXCJcXHUyMjQyXCIsIGVxc2xhbnRndHI6IFwiXFx1MkE5NlwiLCBlcXNsYW50bGVzczogXCJcXHUyQTk1XCIsIEVxdWFsOiBcIlxcdTJBNzVcIiwgZXF1YWxzOiBcIj1cIiwgRXF1YWxUaWxkZTogXCJcXHUyMjQyXCIsIGVxdWVzdDogXCJcXHUyMjVGXCIsIEVxdWlsaWJyaXVtOiBcIlxcdTIxQ0NcIiwgZXF1aXY6IFwiXFx1MjI2MVwiLCBlcXVpdkREOiBcIlxcdTJBNzhcIiwgZXF2cGFyc2w6IFwiXFx1MjlFNVwiLCBlcmFycjogXCJcXHUyOTcxXCIsIGVyRG90OiBcIlxcdTIyNTNcIiwgZXNjcjogXCJcXHUyMTJGXCIsIEVzY3I6IFwiXFx1MjEzMFwiLCBlc2RvdDogXCJcXHUyMjUwXCIsIEVzaW06IFwiXFx1MkE3M1wiLCBlc2ltOiBcIlxcdTIyNDJcIiwgRXRhOiBcIlxcdTAzOTdcIiwgZXRhOiBcIlxcdTAzQjdcIiwgRVRIOiBcIlxceEQwXCIsIGV0aDogXCJcXHhGMFwiLCBFdW1sOiBcIlxceENCXCIsIGV1bWw6IFwiXFx4RUJcIiwgZXVybzogXCJcXHUyMEFDXCIsIGV4Y2w6IFwiIVwiLCBleGlzdDogXCJcXHUyMjAzXCIsIEV4aXN0czogXCJcXHUyMjAzXCIsIGV4cGVjdGF0aW9uOiBcIlxcdTIxMzBcIiwgZXhwb25lbnRpYWxlOiBcIlxcdTIxNDdcIiwgRXhwb25lbnRpYWxFOiBcIlxcdTIxNDdcIiwgZmFsbGluZ2RvdHNlcTogXCJcXHUyMjUyXCIsIEZjeTogXCJcXHUwNDI0XCIsIGZjeTogXCJcXHUwNDQ0XCIsIGZlbWFsZTogXCJcXHUyNjQwXCIsIGZmaWxpZzogXCJcXHVGQjAzXCIsIGZmbGlnOiBcIlxcdUZCMDBcIiwgZmZsbGlnOiBcIlxcdUZCMDRcIiwgRmZyOiBcIlxcdXsxRDUwOX1cIiwgZmZyOiBcIlxcdXsxRDUyM31cIiwgZmlsaWc6IFwiXFx1RkIwMVwiLCBGaWxsZWRTbWFsbFNxdWFyZTogXCJcXHUyNUZDXCIsIEZpbGxlZFZlcnlTbWFsbFNxdWFyZTogXCJcXHUyNUFBXCIsIGZqbGlnOiBcImZqXCIsIGZsYXQ6IFwiXFx1MjY2RFwiLCBmbGxpZzogXCJcXHVGQjAyXCIsIGZsdG5zOiBcIlxcdTI1QjFcIiwgZm5vZjogXCJcXHUwMTkyXCIsIEZvcGY6IFwiXFx1ezFENTNEfVwiLCBmb3BmOiBcIlxcdXsxRDU1N31cIiwgZm9yYWxsOiBcIlxcdTIyMDBcIiwgRm9yQWxsOiBcIlxcdTIyMDBcIiwgZm9yazogXCJcXHUyMkQ0XCIsIGZvcmt2OiBcIlxcdTJBRDlcIiwgRm91cmllcnRyZjogXCJcXHUyMTMxXCIsIGZwYXJ0aW50OiBcIlxcdTJBMERcIiwgZnJhYzEyOiBcIlxceEJEXCIsIGZyYWMxMzogXCJcXHUyMTUzXCIsIGZyYWMxNDogXCJcXHhCQ1wiLCBmcmFjMTU6IFwiXFx1MjE1NVwiLCBmcmFjMTY6IFwiXFx1MjE1OVwiLCBmcmFjMTg6IFwiXFx1MjE1QlwiLCBmcmFjMjM6IFwiXFx1MjE1NFwiLCBmcmFjMjU6IFwiXFx1MjE1NlwiLCBmcmFjMzQ6IFwiXFx4QkVcIiwgZnJhYzM1OiBcIlxcdTIxNTdcIiwgZnJhYzM4OiBcIlxcdTIxNUNcIiwgZnJhYzQ1OiBcIlxcdTIxNThcIiwgZnJhYzU2OiBcIlxcdTIxNUFcIiwgZnJhYzU4OiBcIlxcdTIxNURcIiwgZnJhYzc4OiBcIlxcdTIxNUVcIiwgZnJhc2w6IFwiXFx1MjA0NFwiLCBmcm93bjogXCJcXHUyMzIyXCIsIGZzY3I6IFwiXFx1ezFENEJCfVwiLCBGc2NyOiBcIlxcdTIxMzFcIiwgZ2FjdXRlOiBcIlxcdTAxRjVcIiwgR2FtbWE6IFwiXFx1MDM5M1wiLCBnYW1tYTogXCJcXHUwM0IzXCIsIEdhbW1hZDogXCJcXHUwM0RDXCIsIGdhbW1hZDogXCJcXHUwM0REXCIsIGdhcDogXCJcXHUyQTg2XCIsIEdicmV2ZTogXCJcXHUwMTFFXCIsIGdicmV2ZTogXCJcXHUwMTFGXCIsIEdjZWRpbDogXCJcXHUwMTIyXCIsIEdjaXJjOiBcIlxcdTAxMUNcIiwgZ2NpcmM6IFwiXFx1MDExRFwiLCBHY3k6IFwiXFx1MDQxM1wiLCBnY3k6IFwiXFx1MDQzM1wiLCBHZG90OiBcIlxcdTAxMjBcIiwgZ2RvdDogXCJcXHUwMTIxXCIsIGdlOiBcIlxcdTIyNjVcIiwgZ0U6IFwiXFx1MjI2N1wiLCBnRWw6IFwiXFx1MkE4Q1wiLCBnZWw6IFwiXFx1MjJEQlwiLCBnZXE6IFwiXFx1MjI2NVwiLCBnZXFxOiBcIlxcdTIyNjdcIiwgZ2Vxc2xhbnQ6IFwiXFx1MkE3RVwiLCBnZXNjYzogXCJcXHUyQUE5XCIsIGdlczogXCJcXHUyQTdFXCIsIGdlc2RvdDogXCJcXHUyQTgwXCIsIGdlc2RvdG86IFwiXFx1MkE4MlwiLCBnZXNkb3RvbDogXCJcXHUyQTg0XCIsIGdlc2w6IFwiXFx1MjJEQlxcdUZFMDBcIiwgZ2VzbGVzOiBcIlxcdTJBOTRcIiwgR2ZyOiBcIlxcdXsxRDUwQX1cIiwgZ2ZyOiBcIlxcdXsxRDUyNH1cIiwgZ2c6IFwiXFx1MjI2QlwiLCBHZzogXCJcXHUyMkQ5XCIsIGdnZzogXCJcXHUyMkQ5XCIsIGdpbWVsOiBcIlxcdTIxMzdcIiwgR0pjeTogXCJcXHUwNDAzXCIsIGdqY3k6IFwiXFx1MDQ1M1wiLCBnbGE6IFwiXFx1MkFBNVwiLCBnbDogXCJcXHUyMjc3XCIsIGdsRTogXCJcXHUyQTkyXCIsIGdsajogXCJcXHUyQUE0XCIsIGduYXA6IFwiXFx1MkE4QVwiLCBnbmFwcHJveDogXCJcXHUyQThBXCIsIGduZTogXCJcXHUyQTg4XCIsIGduRTogXCJcXHUyMjY5XCIsIGduZXE6IFwiXFx1MkE4OFwiLCBnbmVxcTogXCJcXHUyMjY5XCIsIGduc2ltOiBcIlxcdTIyRTdcIiwgR29wZjogXCJcXHV7MUQ1M0V9XCIsIGdvcGY6IFwiXFx1ezFENTU4fVwiLCBncmF2ZTogXCJgXCIsIEdyZWF0ZXJFcXVhbDogXCJcXHUyMjY1XCIsIEdyZWF0ZXJFcXVhbExlc3M6IFwiXFx1MjJEQlwiLCBHcmVhdGVyRnVsbEVxdWFsOiBcIlxcdTIyNjdcIiwgR3JlYXRlckdyZWF0ZXI6IFwiXFx1MkFBMlwiLCBHcmVhdGVyTGVzczogXCJcXHUyMjc3XCIsIEdyZWF0ZXJTbGFudEVxdWFsOiBcIlxcdTJBN0VcIiwgR3JlYXRlclRpbGRlOiBcIlxcdTIyNzNcIiwgR3NjcjogXCJcXHV7MUQ0QTJ9XCIsIGdzY3I6IFwiXFx1MjEwQVwiLCBnc2ltOiBcIlxcdTIyNzNcIiwgZ3NpbWU6IFwiXFx1MkE4RVwiLCBnc2ltbDogXCJcXHUyQTkwXCIsIGd0Y2M6IFwiXFx1MkFBN1wiLCBndGNpcjogXCJcXHUyQTdBXCIsIGd0OiBcIj5cIiwgR1Q6IFwiPlwiLCBHdDogXCJcXHUyMjZCXCIsIGd0ZG90OiBcIlxcdTIyRDdcIiwgZ3RsUGFyOiBcIlxcdTI5OTVcIiwgZ3RxdWVzdDogXCJcXHUyQTdDXCIsIGd0cmFwcHJveDogXCJcXHUyQTg2XCIsIGd0cmFycjogXCJcXHUyOTc4XCIsIGd0cmRvdDogXCJcXHUyMkQ3XCIsIGd0cmVxbGVzczogXCJcXHUyMkRCXCIsIGd0cmVxcWxlc3M6IFwiXFx1MkE4Q1wiLCBndHJsZXNzOiBcIlxcdTIyNzdcIiwgZ3Ryc2ltOiBcIlxcdTIyNzNcIiwgZ3ZlcnRuZXFxOiBcIlxcdTIyNjlcXHVGRTAwXCIsIGd2bkU6IFwiXFx1MjI2OVxcdUZFMDBcIiwgSGFjZWs6IFwiXFx1MDJDN1wiLCBoYWlyc3A6IFwiXFx1MjAwQVwiLCBoYWxmOiBcIlxceEJEXCIsIGhhbWlsdDogXCJcXHUyMTBCXCIsIEhBUkRjeTogXCJcXHUwNDJBXCIsIGhhcmRjeTogXCJcXHUwNDRBXCIsIGhhcnJjaXI6IFwiXFx1Mjk0OFwiLCBoYXJyOiBcIlxcdTIxOTRcIiwgaEFycjogXCJcXHUyMUQ0XCIsIGhhcnJ3OiBcIlxcdTIxQURcIiwgSGF0OiBcIl5cIiwgaGJhcjogXCJcXHUyMTBGXCIsIEhjaXJjOiBcIlxcdTAxMjRcIiwgaGNpcmM6IFwiXFx1MDEyNVwiLCBoZWFydHM6IFwiXFx1MjY2NVwiLCBoZWFydHN1aXQ6IFwiXFx1MjY2NVwiLCBoZWxsaXA6IFwiXFx1MjAyNlwiLCBoZXJjb246IFwiXFx1MjJCOVwiLCBoZnI6IFwiXFx1ezFENTI1fVwiLCBIZnI6IFwiXFx1MjEwQ1wiLCBIaWxiZXJ0U3BhY2U6IFwiXFx1MjEwQlwiLCBoa3NlYXJvdzogXCJcXHUyOTI1XCIsIGhrc3dhcm93OiBcIlxcdTI5MjZcIiwgaG9hcnI6IFwiXFx1MjFGRlwiLCBob210aHQ6IFwiXFx1MjIzQlwiLCBob29rbGVmdGFycm93OiBcIlxcdTIxQTlcIiwgaG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFBQVwiLCBob3BmOiBcIlxcdXsxRDU1OX1cIiwgSG9wZjogXCJcXHUyMTBEXCIsIGhvcmJhcjogXCJcXHUyMDE1XCIsIEhvcml6b250YWxMaW5lOiBcIlxcdTI1MDBcIiwgaHNjcjogXCJcXHV7MUQ0QkR9XCIsIEhzY3I6IFwiXFx1MjEwQlwiLCBoc2xhc2g6IFwiXFx1MjEwRlwiLCBIc3Ryb2s6IFwiXFx1MDEyNlwiLCBoc3Ryb2s6IFwiXFx1MDEyN1wiLCBIdW1wRG93bkh1bXA6IFwiXFx1MjI0RVwiLCBIdW1wRXF1YWw6IFwiXFx1MjI0RlwiLCBoeWJ1bGw6IFwiXFx1MjA0M1wiLCBoeXBoZW46IFwiXFx1MjAxMFwiLCBJYWN1dGU6IFwiXFx4Q0RcIiwgaWFjdXRlOiBcIlxceEVEXCIsIGljOiBcIlxcdTIwNjNcIiwgSWNpcmM6IFwiXFx4Q0VcIiwgaWNpcmM6IFwiXFx4RUVcIiwgSWN5OiBcIlxcdTA0MThcIiwgaWN5OiBcIlxcdTA0MzhcIiwgSWRvdDogXCJcXHUwMTMwXCIsIElFY3k6IFwiXFx1MDQxNVwiLCBpZWN5OiBcIlxcdTA0MzVcIiwgaWV4Y2w6IFwiXFx4QTFcIiwgaWZmOiBcIlxcdTIxRDRcIiwgaWZyOiBcIlxcdXsxRDUyNn1cIiwgSWZyOiBcIlxcdTIxMTFcIiwgSWdyYXZlOiBcIlxceENDXCIsIGlncmF2ZTogXCJcXHhFQ1wiLCBpaTogXCJcXHUyMTQ4XCIsIGlpaWludDogXCJcXHUyQTBDXCIsIGlpaW50OiBcIlxcdTIyMkRcIiwgaWluZmluOiBcIlxcdTI5RENcIiwgaWlvdGE6IFwiXFx1MjEyOVwiLCBJSmxpZzogXCJcXHUwMTMyXCIsIGlqbGlnOiBcIlxcdTAxMzNcIiwgSW1hY3I6IFwiXFx1MDEyQVwiLCBpbWFjcjogXCJcXHUwMTJCXCIsIGltYWdlOiBcIlxcdTIxMTFcIiwgSW1hZ2luYXJ5STogXCJcXHUyMTQ4XCIsIGltYWdsaW5lOiBcIlxcdTIxMTBcIiwgaW1hZ3BhcnQ6IFwiXFx1MjExMVwiLCBpbWF0aDogXCJcXHUwMTMxXCIsIEltOiBcIlxcdTIxMTFcIiwgaW1vZjogXCJcXHUyMkI3XCIsIGltcGVkOiBcIlxcdTAxQjVcIiwgSW1wbGllczogXCJcXHUyMUQyXCIsIGluY2FyZTogXCJcXHUyMTA1XCIsIGluOiBcIlxcdTIyMDhcIiwgaW5maW46IFwiXFx1MjIxRVwiLCBpbmZpbnRpZTogXCJcXHUyOUREXCIsIGlub2RvdDogXCJcXHUwMTMxXCIsIGludGNhbDogXCJcXHUyMkJBXCIsIGludDogXCJcXHUyMjJCXCIsIEludDogXCJcXHUyMjJDXCIsIGludGVnZXJzOiBcIlxcdTIxMjRcIiwgSW50ZWdyYWw6IFwiXFx1MjIyQlwiLCBpbnRlcmNhbDogXCJcXHUyMkJBXCIsIEludGVyc2VjdGlvbjogXCJcXHUyMkMyXCIsIGludGxhcmhrOiBcIlxcdTJBMTdcIiwgaW50cHJvZDogXCJcXHUyQTNDXCIsIEludmlzaWJsZUNvbW1hOiBcIlxcdTIwNjNcIiwgSW52aXNpYmxlVGltZXM6IFwiXFx1MjA2MlwiLCBJT2N5OiBcIlxcdTA0MDFcIiwgaW9jeTogXCJcXHUwNDUxXCIsIElvZ29uOiBcIlxcdTAxMkVcIiwgaW9nb246IFwiXFx1MDEyRlwiLCBJb3BmOiBcIlxcdXsxRDU0MH1cIiwgaW9wZjogXCJcXHV7MUQ1NUF9XCIsIElvdGE6IFwiXFx1MDM5OVwiLCBpb3RhOiBcIlxcdTAzQjlcIiwgaXByb2Q6IFwiXFx1MkEzQ1wiLCBpcXVlc3Q6IFwiXFx4QkZcIiwgaXNjcjogXCJcXHV7MUQ0QkV9XCIsIElzY3I6IFwiXFx1MjExMFwiLCBpc2luOiBcIlxcdTIyMDhcIiwgaXNpbmRvdDogXCJcXHUyMkY1XCIsIGlzaW5FOiBcIlxcdTIyRjlcIiwgaXNpbnM6IFwiXFx1MjJGNFwiLCBpc2luc3Y6IFwiXFx1MjJGM1wiLCBpc2ludjogXCJcXHUyMjA4XCIsIGl0OiBcIlxcdTIwNjJcIiwgSXRpbGRlOiBcIlxcdTAxMjhcIiwgaXRpbGRlOiBcIlxcdTAxMjlcIiwgSXVrY3k6IFwiXFx1MDQwNlwiLCBpdWtjeTogXCJcXHUwNDU2XCIsIEl1bWw6IFwiXFx4Q0ZcIiwgaXVtbDogXCJcXHhFRlwiLCBKY2lyYzogXCJcXHUwMTM0XCIsIGpjaXJjOiBcIlxcdTAxMzVcIiwgSmN5OiBcIlxcdTA0MTlcIiwgamN5OiBcIlxcdTA0MzlcIiwgSmZyOiBcIlxcdXsxRDUwRH1cIiwgamZyOiBcIlxcdXsxRDUyN31cIiwgam1hdGg6IFwiXFx1MDIzN1wiLCBKb3BmOiBcIlxcdXsxRDU0MX1cIiwgam9wZjogXCJcXHV7MUQ1NUJ9XCIsIEpzY3I6IFwiXFx1ezFENEE1fVwiLCBqc2NyOiBcIlxcdXsxRDRCRn1cIiwgSnNlcmN5OiBcIlxcdTA0MDhcIiwganNlcmN5OiBcIlxcdTA0NThcIiwgSnVrY3k6IFwiXFx1MDQwNFwiLCBqdWtjeTogXCJcXHUwNDU0XCIsIEthcHBhOiBcIlxcdTAzOUFcIiwga2FwcGE6IFwiXFx1MDNCQVwiLCBrYXBwYXY6IFwiXFx1MDNGMFwiLCBLY2VkaWw6IFwiXFx1MDEzNlwiLCBrY2VkaWw6IFwiXFx1MDEzN1wiLCBLY3k6IFwiXFx1MDQxQVwiLCBrY3k6IFwiXFx1MDQzQVwiLCBLZnI6IFwiXFx1ezFENTBFfVwiLCBrZnI6IFwiXFx1ezFENTI4fVwiLCBrZ3JlZW46IFwiXFx1MDEzOFwiLCBLSGN5OiBcIlxcdTA0MjVcIiwga2hjeTogXCJcXHUwNDQ1XCIsIEtKY3k6IFwiXFx1MDQwQ1wiLCBramN5OiBcIlxcdTA0NUNcIiwgS29wZjogXCJcXHV7MUQ1NDJ9XCIsIGtvcGY6IFwiXFx1ezFENTVDfVwiLCBLc2NyOiBcIlxcdXsxRDRBNn1cIiwga3NjcjogXCJcXHV7MUQ0QzB9XCIsIGxBYXJyOiBcIlxcdTIxREFcIiwgTGFjdXRlOiBcIlxcdTAxMzlcIiwgbGFjdXRlOiBcIlxcdTAxM0FcIiwgbGFlbXB0eXY6IFwiXFx1MjlCNFwiLCBsYWdyYW46IFwiXFx1MjExMlwiLCBMYW1iZGE6IFwiXFx1MDM5QlwiLCBsYW1iZGE6IFwiXFx1MDNCQlwiLCBsYW5nOiBcIlxcdTI3RThcIiwgTGFuZzogXCJcXHUyN0VBXCIsIGxhbmdkOiBcIlxcdTI5OTFcIiwgbGFuZ2xlOiBcIlxcdTI3RThcIiwgbGFwOiBcIlxcdTJBODVcIiwgTGFwbGFjZXRyZjogXCJcXHUyMTEyXCIsIGxhcXVvOiBcIlxceEFCXCIsIGxhcnJiOiBcIlxcdTIxRTRcIiwgbGFycmJmczogXCJcXHUyOTFGXCIsIGxhcnI6IFwiXFx1MjE5MFwiLCBMYXJyOiBcIlxcdTIxOUVcIiwgbEFycjogXCJcXHUyMUQwXCIsIGxhcnJmczogXCJcXHUyOTFEXCIsIGxhcnJoazogXCJcXHUyMUE5XCIsIGxhcnJscDogXCJcXHUyMUFCXCIsIGxhcnJwbDogXCJcXHUyOTM5XCIsIGxhcnJzaW06IFwiXFx1Mjk3M1wiLCBsYXJydGw6IFwiXFx1MjFBMlwiLCBsYXRhaWw6IFwiXFx1MjkxOVwiLCBsQXRhaWw6IFwiXFx1MjkxQlwiLCBsYXQ6IFwiXFx1MkFBQlwiLCBsYXRlOiBcIlxcdTJBQURcIiwgbGF0ZXM6IFwiXFx1MkFBRFxcdUZFMDBcIiwgbGJhcnI6IFwiXFx1MjkwQ1wiLCBsQmFycjogXCJcXHUyOTBFXCIsIGxiYnJrOiBcIlxcdTI3NzJcIiwgbGJyYWNlOiBcIntcIiwgbGJyYWNrOiBcIltcIiwgbGJya2U6IFwiXFx1Mjk4QlwiLCBsYnJrc2xkOiBcIlxcdTI5OEZcIiwgbGJya3NsdTogXCJcXHUyOThEXCIsIExjYXJvbjogXCJcXHUwMTNEXCIsIGxjYXJvbjogXCJcXHUwMTNFXCIsIExjZWRpbDogXCJcXHUwMTNCXCIsIGxjZWRpbDogXCJcXHUwMTNDXCIsIGxjZWlsOiBcIlxcdTIzMDhcIiwgbGN1YjogXCJ7XCIsIExjeTogXCJcXHUwNDFCXCIsIGxjeTogXCJcXHUwNDNCXCIsIGxkY2E6IFwiXFx1MjkzNlwiLCBsZHF1bzogXCJcXHUyMDFDXCIsIGxkcXVvcjogXCJcXHUyMDFFXCIsIGxkcmRoYXI6IFwiXFx1Mjk2N1wiLCBsZHJ1c2hhcjogXCJcXHUyOTRCXCIsIGxkc2g6IFwiXFx1MjFCMlwiLCBsZTogXCJcXHUyMjY0XCIsIGxFOiBcIlxcdTIyNjZcIiwgTGVmdEFuZ2xlQnJhY2tldDogXCJcXHUyN0U4XCIsIExlZnRBcnJvd0JhcjogXCJcXHUyMUU0XCIsIGxlZnRhcnJvdzogXCJcXHUyMTkwXCIsIExlZnRBcnJvdzogXCJcXHUyMTkwXCIsIExlZnRhcnJvdzogXCJcXHUyMUQwXCIsIExlZnRBcnJvd1JpZ2h0QXJyb3c6IFwiXFx1MjFDNlwiLCBsZWZ0YXJyb3d0YWlsOiBcIlxcdTIxQTJcIiwgTGVmdENlaWxpbmc6IFwiXFx1MjMwOFwiLCBMZWZ0RG91YmxlQnJhY2tldDogXCJcXHUyN0U2XCIsIExlZnREb3duVGVlVmVjdG9yOiBcIlxcdTI5NjFcIiwgTGVmdERvd25WZWN0b3JCYXI6IFwiXFx1Mjk1OVwiLCBMZWZ0RG93blZlY3RvcjogXCJcXHUyMUMzXCIsIExlZnRGbG9vcjogXCJcXHUyMzBBXCIsIGxlZnRoYXJwb29uZG93bjogXCJcXHUyMUJEXCIsIGxlZnRoYXJwb29udXA6IFwiXFx1MjFCQ1wiLCBsZWZ0bGVmdGFycm93czogXCJcXHUyMUM3XCIsIGxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIiwgTGVmdFJpZ2h0QXJyb3c6IFwiXFx1MjE5NFwiLCBMZWZ0cmlnaHRhcnJvdzogXCJcXHUyMUQ0XCIsIGxlZnRyaWdodGFycm93czogXCJcXHUyMUM2XCIsIGxlZnRyaWdodGhhcnBvb25zOiBcIlxcdTIxQ0JcIiwgbGVmdHJpZ2h0c3F1aWdhcnJvdzogXCJcXHUyMUFEXCIsIExlZnRSaWdodFZlY3RvcjogXCJcXHUyOTRFXCIsIExlZnRUZWVBcnJvdzogXCJcXHUyMUE0XCIsIExlZnRUZWU6IFwiXFx1MjJBM1wiLCBMZWZ0VGVlVmVjdG9yOiBcIlxcdTI5NUFcIiwgbGVmdHRocmVldGltZXM6IFwiXFx1MjJDQlwiLCBMZWZ0VHJpYW5nbGVCYXI6IFwiXFx1MjlDRlwiLCBMZWZ0VHJpYW5nbGU6IFwiXFx1MjJCMlwiLCBMZWZ0VHJpYW5nbGVFcXVhbDogXCJcXHUyMkI0XCIsIExlZnRVcERvd25WZWN0b3I6IFwiXFx1Mjk1MVwiLCBMZWZ0VXBUZWVWZWN0b3I6IFwiXFx1Mjk2MFwiLCBMZWZ0VXBWZWN0b3JCYXI6IFwiXFx1Mjk1OFwiLCBMZWZ0VXBWZWN0b3I6IFwiXFx1MjFCRlwiLCBMZWZ0VmVjdG9yQmFyOiBcIlxcdTI5NTJcIiwgTGVmdFZlY3RvcjogXCJcXHUyMUJDXCIsIGxFZzogXCJcXHUyQThCXCIsIGxlZzogXCJcXHUyMkRBXCIsIGxlcTogXCJcXHUyMjY0XCIsIGxlcXE6IFwiXFx1MjI2NlwiLCBsZXFzbGFudDogXCJcXHUyQTdEXCIsIGxlc2NjOiBcIlxcdTJBQThcIiwgbGVzOiBcIlxcdTJBN0RcIiwgbGVzZG90OiBcIlxcdTJBN0ZcIiwgbGVzZG90bzogXCJcXHUyQTgxXCIsIGxlc2RvdG9yOiBcIlxcdTJBODNcIiwgbGVzZzogXCJcXHUyMkRBXFx1RkUwMFwiLCBsZXNnZXM6IFwiXFx1MkE5M1wiLCBsZXNzYXBwcm94OiBcIlxcdTJBODVcIiwgbGVzc2RvdDogXCJcXHUyMkQ2XCIsIGxlc3NlcWd0cjogXCJcXHUyMkRBXCIsIGxlc3NlcXFndHI6IFwiXFx1MkE4QlwiLCBMZXNzRXF1YWxHcmVhdGVyOiBcIlxcdTIyREFcIiwgTGVzc0Z1bGxFcXVhbDogXCJcXHUyMjY2XCIsIExlc3NHcmVhdGVyOiBcIlxcdTIyNzZcIiwgbGVzc2d0cjogXCJcXHUyMjc2XCIsIExlc3NMZXNzOiBcIlxcdTJBQTFcIiwgbGVzc3NpbTogXCJcXHUyMjcyXCIsIExlc3NTbGFudEVxdWFsOiBcIlxcdTJBN0RcIiwgTGVzc1RpbGRlOiBcIlxcdTIyNzJcIiwgbGZpc2h0OiBcIlxcdTI5N0NcIiwgbGZsb29yOiBcIlxcdTIzMEFcIiwgTGZyOiBcIlxcdXsxRDUwRn1cIiwgbGZyOiBcIlxcdXsxRDUyOX1cIiwgbGc6IFwiXFx1MjI3NlwiLCBsZ0U6IFwiXFx1MkE5MVwiLCBsSGFyOiBcIlxcdTI5NjJcIiwgbGhhcmQ6IFwiXFx1MjFCRFwiLCBsaGFydTogXCJcXHUyMUJDXCIsIGxoYXJ1bDogXCJcXHUyOTZBXCIsIGxoYmxrOiBcIlxcdTI1ODRcIiwgTEpjeTogXCJcXHUwNDA5XCIsIGxqY3k6IFwiXFx1MDQ1OVwiLCBsbGFycjogXCJcXHUyMUM3XCIsIGxsOiBcIlxcdTIyNkFcIiwgTGw6IFwiXFx1MjJEOFwiLCBsbGNvcm5lcjogXCJcXHUyMzFFXCIsIExsZWZ0YXJyb3c6IFwiXFx1MjFEQVwiLCBsbGhhcmQ6IFwiXFx1Mjk2QlwiLCBsbHRyaTogXCJcXHUyNUZBXCIsIExtaWRvdDogXCJcXHUwMTNGXCIsIGxtaWRvdDogXCJcXHUwMTQwXCIsIGxtb3VzdGFjaGU6IFwiXFx1MjNCMFwiLCBsbW91c3Q6IFwiXFx1MjNCMFwiLCBsbmFwOiBcIlxcdTJBODlcIiwgbG5hcHByb3g6IFwiXFx1MkE4OVwiLCBsbmU6IFwiXFx1MkE4N1wiLCBsbkU6IFwiXFx1MjI2OFwiLCBsbmVxOiBcIlxcdTJBODdcIiwgbG5lcXE6IFwiXFx1MjI2OFwiLCBsbnNpbTogXCJcXHUyMkU2XCIsIGxvYW5nOiBcIlxcdTI3RUNcIiwgbG9hcnI6IFwiXFx1MjFGRFwiLCBsb2JyazogXCJcXHUyN0U2XCIsIGxvbmdsZWZ0YXJyb3c6IFwiXFx1MjdGNVwiLCBMb25nTGVmdEFycm93OiBcIlxcdTI3RjVcIiwgTG9uZ2xlZnRhcnJvdzogXCJcXHUyN0Y4XCIsIGxvbmdsZWZ0cmlnaHRhcnJvdzogXCJcXHUyN0Y3XCIsIExvbmdMZWZ0UmlnaHRBcnJvdzogXCJcXHUyN0Y3XCIsIExvbmdsZWZ0cmlnaHRhcnJvdzogXCJcXHUyN0ZBXCIsIGxvbmdtYXBzdG86IFwiXFx1MjdGQ1wiLCBsb25ncmlnaHRhcnJvdzogXCJcXHUyN0Y2XCIsIExvbmdSaWdodEFycm93OiBcIlxcdTI3RjZcIiwgTG9uZ3JpZ2h0YXJyb3c6IFwiXFx1MjdGOVwiLCBsb29wYXJyb3dsZWZ0OiBcIlxcdTIxQUJcIiwgbG9vcGFycm93cmlnaHQ6IFwiXFx1MjFBQ1wiLCBsb3BhcjogXCJcXHUyOTg1XCIsIExvcGY6IFwiXFx1ezFENTQzfVwiLCBsb3BmOiBcIlxcdXsxRDU1RH1cIiwgbG9wbHVzOiBcIlxcdTJBMkRcIiwgbG90aW1lczogXCJcXHUyQTM0XCIsIGxvd2FzdDogXCJcXHUyMjE3XCIsIGxvd2JhcjogXCJfXCIsIExvd2VyTGVmdEFycm93OiBcIlxcdTIxOTlcIiwgTG93ZXJSaWdodEFycm93OiBcIlxcdTIxOThcIiwgbG96OiBcIlxcdTI1Q0FcIiwgbG96ZW5nZTogXCJcXHUyNUNBXCIsIGxvemY6IFwiXFx1MjlFQlwiLCBscGFyOiBcIihcIiwgbHBhcmx0OiBcIlxcdTI5OTNcIiwgbHJhcnI6IFwiXFx1MjFDNlwiLCBscmNvcm5lcjogXCJcXHUyMzFGXCIsIGxyaGFyOiBcIlxcdTIxQ0JcIiwgbHJoYXJkOiBcIlxcdTI5NkRcIiwgbHJtOiBcIlxcdTIwMEVcIiwgbHJ0cmk6IFwiXFx1MjJCRlwiLCBsc2FxdW86IFwiXFx1MjAzOVwiLCBsc2NyOiBcIlxcdXsxRDRDMX1cIiwgTHNjcjogXCJcXHUyMTEyXCIsIGxzaDogXCJcXHUyMUIwXCIsIExzaDogXCJcXHUyMUIwXCIsIGxzaW06IFwiXFx1MjI3MlwiLCBsc2ltZTogXCJcXHUyQThEXCIsIGxzaW1nOiBcIlxcdTJBOEZcIiwgbHNxYjogXCJbXCIsIGxzcXVvOiBcIlxcdTIwMThcIiwgbHNxdW9yOiBcIlxcdTIwMUFcIiwgTHN0cm9rOiBcIlxcdTAxNDFcIiwgbHN0cm9rOiBcIlxcdTAxNDJcIiwgbHRjYzogXCJcXHUyQUE2XCIsIGx0Y2lyOiBcIlxcdTJBNzlcIiwgbHQ6IFwiPFwiLCBMVDogXCI8XCIsIEx0OiBcIlxcdTIyNkFcIiwgbHRkb3Q6IFwiXFx1MjJENlwiLCBsdGhyZWU6IFwiXFx1MjJDQlwiLCBsdGltZXM6IFwiXFx1MjJDOVwiLCBsdGxhcnI6IFwiXFx1Mjk3NlwiLCBsdHF1ZXN0OiBcIlxcdTJBN0JcIiwgbHRyaTogXCJcXHUyNUMzXCIsIGx0cmllOiBcIlxcdTIyQjRcIiwgbHRyaWY6IFwiXFx1MjVDMlwiLCBsdHJQYXI6IFwiXFx1Mjk5NlwiLCBsdXJkc2hhcjogXCJcXHUyOTRBXCIsIGx1cnVoYXI6IFwiXFx1Mjk2NlwiLCBsdmVydG5lcXE6IFwiXFx1MjI2OFxcdUZFMDBcIiwgbHZuRTogXCJcXHUyMjY4XFx1RkUwMFwiLCBtYWNyOiBcIlxceEFGXCIsIG1hbGU6IFwiXFx1MjY0MlwiLCBtYWx0OiBcIlxcdTI3MjBcIiwgbWFsdGVzZTogXCJcXHUyNzIwXCIsIE1hcDogXCJcXHUyOTA1XCIsIG1hcDogXCJcXHUyMUE2XCIsIG1hcHN0bzogXCJcXHUyMUE2XCIsIG1hcHN0b2Rvd246IFwiXFx1MjFBN1wiLCBtYXBzdG9sZWZ0OiBcIlxcdTIxQTRcIiwgbWFwc3RvdXA6IFwiXFx1MjFBNVwiLCBtYXJrZXI6IFwiXFx1MjVBRVwiLCBtY29tbWE6IFwiXFx1MkEyOVwiLCBNY3k6IFwiXFx1MDQxQ1wiLCBtY3k6IFwiXFx1MDQzQ1wiLCBtZGFzaDogXCJcXHUyMDE0XCIsIG1ERG90OiBcIlxcdTIyM0FcIiwgbWVhc3VyZWRhbmdsZTogXCJcXHUyMjIxXCIsIE1lZGl1bVNwYWNlOiBcIlxcdTIwNUZcIiwgTWVsbGludHJmOiBcIlxcdTIxMzNcIiwgTWZyOiBcIlxcdXsxRDUxMH1cIiwgbWZyOiBcIlxcdXsxRDUyQX1cIiwgbWhvOiBcIlxcdTIxMjdcIiwgbWljcm86IFwiXFx4QjVcIiwgbWlkYXN0OiBcIipcIiwgbWlkY2lyOiBcIlxcdTJBRjBcIiwgbWlkOiBcIlxcdTIyMjNcIiwgbWlkZG90OiBcIlxceEI3XCIsIG1pbnVzYjogXCJcXHUyMjlGXCIsIG1pbnVzOiBcIlxcdTIyMTJcIiwgbWludXNkOiBcIlxcdTIyMzhcIiwgbWludXNkdTogXCJcXHUyQTJBXCIsIE1pbnVzUGx1czogXCJcXHUyMjEzXCIsIG1sY3A6IFwiXFx1MkFEQlwiLCBtbGRyOiBcIlxcdTIwMjZcIiwgbW5wbHVzOiBcIlxcdTIyMTNcIiwgbW9kZWxzOiBcIlxcdTIyQTdcIiwgTW9wZjogXCJcXHV7MUQ1NDR9XCIsIG1vcGY6IFwiXFx1ezFENTVFfVwiLCBtcDogXCJcXHUyMjEzXCIsIG1zY3I6IFwiXFx1ezFENEMyfVwiLCBNc2NyOiBcIlxcdTIxMzNcIiwgbXN0cG9zOiBcIlxcdTIyM0VcIiwgTXU6IFwiXFx1MDM5Q1wiLCBtdTogXCJcXHUwM0JDXCIsIG11bHRpbWFwOiBcIlxcdTIyQjhcIiwgbXVtYXA6IFwiXFx1MjJCOFwiLCBuYWJsYTogXCJcXHUyMjA3XCIsIE5hY3V0ZTogXCJcXHUwMTQzXCIsIG5hY3V0ZTogXCJcXHUwMTQ0XCIsIG5hbmc6IFwiXFx1MjIyMFxcdTIwRDJcIiwgbmFwOiBcIlxcdTIyNDlcIiwgbmFwRTogXCJcXHUyQTcwXFx1MDMzOFwiLCBuYXBpZDogXCJcXHUyMjRCXFx1MDMzOFwiLCBuYXBvczogXCJcXHUwMTQ5XCIsIG5hcHByb3g6IFwiXFx1MjI0OVwiLCBuYXR1cmFsOiBcIlxcdTI2NkVcIiwgbmF0dXJhbHM6IFwiXFx1MjExNVwiLCBuYXR1cjogXCJcXHUyNjZFXCIsIG5ic3A6IFwiXFx4QTBcIiwgbmJ1bXA6IFwiXFx1MjI0RVxcdTAzMzhcIiwgbmJ1bXBlOiBcIlxcdTIyNEZcXHUwMzM4XCIsIG5jYXA6IFwiXFx1MkE0M1wiLCBOY2Fyb246IFwiXFx1MDE0N1wiLCBuY2Fyb246IFwiXFx1MDE0OFwiLCBOY2VkaWw6IFwiXFx1MDE0NVwiLCBuY2VkaWw6IFwiXFx1MDE0NlwiLCBuY29uZzogXCJcXHUyMjQ3XCIsIG5jb25nZG90OiBcIlxcdTJBNkRcXHUwMzM4XCIsIG5jdXA6IFwiXFx1MkE0MlwiLCBOY3k6IFwiXFx1MDQxRFwiLCBuY3k6IFwiXFx1MDQzRFwiLCBuZGFzaDogXCJcXHUyMDEzXCIsIG5lYXJoazogXCJcXHUyOTI0XCIsIG5lYXJyOiBcIlxcdTIxOTdcIiwgbmVBcnI6IFwiXFx1MjFEN1wiLCBuZWFycm93OiBcIlxcdTIxOTdcIiwgbmU6IFwiXFx1MjI2MFwiLCBuZWRvdDogXCJcXHUyMjUwXFx1MDMzOFwiLCBOZWdhdGl2ZU1lZGl1bVNwYWNlOiBcIlxcdTIwMEJcIiwgTmVnYXRpdmVUaGlja1NwYWNlOiBcIlxcdTIwMEJcIiwgTmVnYXRpdmVUaGluU3BhY2U6IFwiXFx1MjAwQlwiLCBOZWdhdGl2ZVZlcnlUaGluU3BhY2U6IFwiXFx1MjAwQlwiLCBuZXF1aXY6IFwiXFx1MjI2MlwiLCBuZXNlYXI6IFwiXFx1MjkyOFwiLCBuZXNpbTogXCJcXHUyMjQyXFx1MDMzOFwiLCBOZXN0ZWRHcmVhdGVyR3JlYXRlcjogXCJcXHUyMjZCXCIsIE5lc3RlZExlc3NMZXNzOiBcIlxcdTIyNkFcIiwgTmV3TGluZTogXCJcXG5cIiwgbmV4aXN0OiBcIlxcdTIyMDRcIiwgbmV4aXN0czogXCJcXHUyMjA0XCIsIE5mcjogXCJcXHV7MUQ1MTF9XCIsIG5mcjogXCJcXHV7MUQ1MkJ9XCIsIG5nRTogXCJcXHUyMjY3XFx1MDMzOFwiLCBuZ2U6IFwiXFx1MjI3MVwiLCBuZ2VxOiBcIlxcdTIyNzFcIiwgbmdlcXE6IFwiXFx1MjI2N1xcdTAzMzhcIiwgbmdlcXNsYW50OiBcIlxcdTJBN0VcXHUwMzM4XCIsIG5nZXM6IFwiXFx1MkE3RVxcdTAzMzhcIiwgbkdnOiBcIlxcdTIyRDlcXHUwMzM4XCIsIG5nc2ltOiBcIlxcdTIyNzVcIiwgbkd0OiBcIlxcdTIyNkJcXHUyMEQyXCIsIG5ndDogXCJcXHUyMjZGXCIsIG5ndHI6IFwiXFx1MjI2RlwiLCBuR3R2OiBcIlxcdTIyNkJcXHUwMzM4XCIsIG5oYXJyOiBcIlxcdTIxQUVcIiwgbmhBcnI6IFwiXFx1MjFDRVwiLCBuaHBhcjogXCJcXHUyQUYyXCIsIG5pOiBcIlxcdTIyMEJcIiwgbmlzOiBcIlxcdTIyRkNcIiwgbmlzZDogXCJcXHUyMkZBXCIsIG5pdjogXCJcXHUyMjBCXCIsIE5KY3k6IFwiXFx1MDQwQVwiLCBuamN5OiBcIlxcdTA0NUFcIiwgbmxhcnI6IFwiXFx1MjE5QVwiLCBubEFycjogXCJcXHUyMUNEXCIsIG5sZHI6IFwiXFx1MjAyNVwiLCBubEU6IFwiXFx1MjI2NlxcdTAzMzhcIiwgbmxlOiBcIlxcdTIyNzBcIiwgbmxlZnRhcnJvdzogXCJcXHUyMTlBXCIsIG5MZWZ0YXJyb3c6IFwiXFx1MjFDRFwiLCBubGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFBRVwiLCBuTGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFDRVwiLCBubGVxOiBcIlxcdTIyNzBcIiwgbmxlcXE6IFwiXFx1MjI2NlxcdTAzMzhcIiwgbmxlcXNsYW50OiBcIlxcdTJBN0RcXHUwMzM4XCIsIG5sZXM6IFwiXFx1MkE3RFxcdTAzMzhcIiwgbmxlc3M6IFwiXFx1MjI2RVwiLCBuTGw6IFwiXFx1MjJEOFxcdTAzMzhcIiwgbmxzaW06IFwiXFx1MjI3NFwiLCBuTHQ6IFwiXFx1MjI2QVxcdTIwRDJcIiwgbmx0OiBcIlxcdTIyNkVcIiwgbmx0cmk6IFwiXFx1MjJFQVwiLCBubHRyaWU6IFwiXFx1MjJFQ1wiLCBuTHR2OiBcIlxcdTIyNkFcXHUwMzM4XCIsIG5taWQ6IFwiXFx1MjIyNFwiLCBOb0JyZWFrOiBcIlxcdTIwNjBcIiwgTm9uQnJlYWtpbmdTcGFjZTogXCJcXHhBMFwiLCBub3BmOiBcIlxcdXsxRDU1Rn1cIiwgTm9wZjogXCJcXHUyMTE1XCIsIE5vdDogXCJcXHUyQUVDXCIsIG5vdDogXCJcXHhBQ1wiLCBOb3RDb25ncnVlbnQ6IFwiXFx1MjI2MlwiLCBOb3RDdXBDYXA6IFwiXFx1MjI2RFwiLCBOb3REb3VibGVWZXJ0aWNhbEJhcjogXCJcXHUyMjI2XCIsIE5vdEVsZW1lbnQ6IFwiXFx1MjIwOVwiLCBOb3RFcXVhbDogXCJcXHUyMjYwXCIsIE5vdEVxdWFsVGlsZGU6IFwiXFx1MjI0MlxcdTAzMzhcIiwgTm90RXhpc3RzOiBcIlxcdTIyMDRcIiwgTm90R3JlYXRlcjogXCJcXHUyMjZGXCIsIE5vdEdyZWF0ZXJFcXVhbDogXCJcXHUyMjcxXCIsIE5vdEdyZWF0ZXJGdWxsRXF1YWw6IFwiXFx1MjI2N1xcdTAzMzhcIiwgTm90R3JlYXRlckdyZWF0ZXI6IFwiXFx1MjI2QlxcdTAzMzhcIiwgTm90R3JlYXRlckxlc3M6IFwiXFx1MjI3OVwiLCBOb3RHcmVhdGVyU2xhbnRFcXVhbDogXCJcXHUyQTdFXFx1MDMzOFwiLCBOb3RHcmVhdGVyVGlsZGU6IFwiXFx1MjI3NVwiLCBOb3RIdW1wRG93bkh1bXA6IFwiXFx1MjI0RVxcdTAzMzhcIiwgTm90SHVtcEVxdWFsOiBcIlxcdTIyNEZcXHUwMzM4XCIsIG5vdGluOiBcIlxcdTIyMDlcIiwgbm90aW5kb3Q6IFwiXFx1MjJGNVxcdTAzMzhcIiwgbm90aW5FOiBcIlxcdTIyRjlcXHUwMzM4XCIsIG5vdGludmE6IFwiXFx1MjIwOVwiLCBub3RpbnZiOiBcIlxcdTIyRjdcIiwgbm90aW52YzogXCJcXHUyMkY2XCIsIE5vdExlZnRUcmlhbmdsZUJhcjogXCJcXHUyOUNGXFx1MDMzOFwiLCBOb3RMZWZ0VHJpYW5nbGU6IFwiXFx1MjJFQVwiLCBOb3RMZWZ0VHJpYW5nbGVFcXVhbDogXCJcXHUyMkVDXCIsIE5vdExlc3M6IFwiXFx1MjI2RVwiLCBOb3RMZXNzRXF1YWw6IFwiXFx1MjI3MFwiLCBOb3RMZXNzR3JlYXRlcjogXCJcXHUyMjc4XCIsIE5vdExlc3NMZXNzOiBcIlxcdTIyNkFcXHUwMzM4XCIsIE5vdExlc3NTbGFudEVxdWFsOiBcIlxcdTJBN0RcXHUwMzM4XCIsIE5vdExlc3NUaWxkZTogXCJcXHUyMjc0XCIsIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyOiBcIlxcdTJBQTJcXHUwMzM4XCIsIE5vdE5lc3RlZExlc3NMZXNzOiBcIlxcdTJBQTFcXHUwMzM4XCIsIG5vdG5pOiBcIlxcdTIyMENcIiwgbm90bml2YTogXCJcXHUyMjBDXCIsIG5vdG5pdmI6IFwiXFx1MjJGRVwiLCBub3RuaXZjOiBcIlxcdTIyRkRcIiwgTm90UHJlY2VkZXM6IFwiXFx1MjI4MFwiLCBOb3RQcmVjZWRlc0VxdWFsOiBcIlxcdTJBQUZcXHUwMzM4XCIsIE5vdFByZWNlZGVzU2xhbnRFcXVhbDogXCJcXHUyMkUwXCIsIE5vdFJldmVyc2VFbGVtZW50OiBcIlxcdTIyMENcIiwgTm90UmlnaHRUcmlhbmdsZUJhcjogXCJcXHUyOUQwXFx1MDMzOFwiLCBOb3RSaWdodFRyaWFuZ2xlOiBcIlxcdTIyRUJcIiwgTm90UmlnaHRUcmlhbmdsZUVxdWFsOiBcIlxcdTIyRURcIiwgTm90U3F1YXJlU3Vic2V0OiBcIlxcdTIyOEZcXHUwMzM4XCIsIE5vdFNxdWFyZVN1YnNldEVxdWFsOiBcIlxcdTIyRTJcIiwgTm90U3F1YXJlU3VwZXJzZXQ6IFwiXFx1MjI5MFxcdTAzMzhcIiwgTm90U3F1YXJlU3VwZXJzZXRFcXVhbDogXCJcXHUyMkUzXCIsIE5vdFN1YnNldDogXCJcXHUyMjgyXFx1MjBEMlwiLCBOb3RTdWJzZXRFcXVhbDogXCJcXHUyMjg4XCIsIE5vdFN1Y2NlZWRzOiBcIlxcdTIyODFcIiwgTm90U3VjY2VlZHNFcXVhbDogXCJcXHUyQUIwXFx1MDMzOFwiLCBOb3RTdWNjZWVkc1NsYW50RXF1YWw6IFwiXFx1MjJFMVwiLCBOb3RTdWNjZWVkc1RpbGRlOiBcIlxcdTIyN0ZcXHUwMzM4XCIsIE5vdFN1cGVyc2V0OiBcIlxcdTIyODNcXHUyMEQyXCIsIE5vdFN1cGVyc2V0RXF1YWw6IFwiXFx1MjI4OVwiLCBOb3RUaWxkZTogXCJcXHUyMjQxXCIsIE5vdFRpbGRlRXF1YWw6IFwiXFx1MjI0NFwiLCBOb3RUaWxkZUZ1bGxFcXVhbDogXCJcXHUyMjQ3XCIsIE5vdFRpbGRlVGlsZGU6IFwiXFx1MjI0OVwiLCBOb3RWZXJ0aWNhbEJhcjogXCJcXHUyMjI0XCIsIG5wYXJhbGxlbDogXCJcXHUyMjI2XCIsIG5wYXI6IFwiXFx1MjIyNlwiLCBucGFyc2w6IFwiXFx1MkFGRFxcdTIwRTVcIiwgbnBhcnQ6IFwiXFx1MjIwMlxcdTAzMzhcIiwgbnBvbGludDogXCJcXHUyQTE0XCIsIG5wcjogXCJcXHUyMjgwXCIsIG5wcmN1ZTogXCJcXHUyMkUwXCIsIG5wcmVjOiBcIlxcdTIyODBcIiwgbnByZWNlcTogXCJcXHUyQUFGXFx1MDMzOFwiLCBucHJlOiBcIlxcdTJBQUZcXHUwMzM4XCIsIG5yYXJyYzogXCJcXHUyOTMzXFx1MDMzOFwiLCBucmFycjogXCJcXHUyMTlCXCIsIG5yQXJyOiBcIlxcdTIxQ0ZcIiwgbnJhcnJ3OiBcIlxcdTIxOURcXHUwMzM4XCIsIG5yaWdodGFycm93OiBcIlxcdTIxOUJcIiwgblJpZ2h0YXJyb3c6IFwiXFx1MjFDRlwiLCBucnRyaTogXCJcXHUyMkVCXCIsIG5ydHJpZTogXCJcXHUyMkVEXCIsIG5zYzogXCJcXHUyMjgxXCIsIG5zY2N1ZTogXCJcXHUyMkUxXCIsIG5zY2U6IFwiXFx1MkFCMFxcdTAzMzhcIiwgTnNjcjogXCJcXHV7MUQ0QTl9XCIsIG5zY3I6IFwiXFx1ezFENEMzfVwiLCBuc2hvcnRtaWQ6IFwiXFx1MjIyNFwiLCBuc2hvcnRwYXJhbGxlbDogXCJcXHUyMjI2XCIsIG5zaW06IFwiXFx1MjI0MVwiLCBuc2ltZTogXCJcXHUyMjQ0XCIsIG5zaW1lcTogXCJcXHUyMjQ0XCIsIG5zbWlkOiBcIlxcdTIyMjRcIiwgbnNwYXI6IFwiXFx1MjIyNlwiLCBuc3FzdWJlOiBcIlxcdTIyRTJcIiwgbnNxc3VwZTogXCJcXHUyMkUzXCIsIG5zdWI6IFwiXFx1MjI4NFwiLCBuc3ViRTogXCJcXHUyQUM1XFx1MDMzOFwiLCBuc3ViZTogXCJcXHUyMjg4XCIsIG5zdWJzZXQ6IFwiXFx1MjI4MlxcdTIwRDJcIiwgbnN1YnNldGVxOiBcIlxcdTIyODhcIiwgbnN1YnNldGVxcTogXCJcXHUyQUM1XFx1MDMzOFwiLCBuc3VjYzogXCJcXHUyMjgxXCIsIG5zdWNjZXE6IFwiXFx1MkFCMFxcdTAzMzhcIiwgbnN1cDogXCJcXHUyMjg1XCIsIG5zdXBFOiBcIlxcdTJBQzZcXHUwMzM4XCIsIG5zdXBlOiBcIlxcdTIyODlcIiwgbnN1cHNldDogXCJcXHUyMjgzXFx1MjBEMlwiLCBuc3Vwc2V0ZXE6IFwiXFx1MjI4OVwiLCBuc3Vwc2V0ZXFxOiBcIlxcdTJBQzZcXHUwMzM4XCIsIG50Z2w6IFwiXFx1MjI3OVwiLCBOdGlsZGU6IFwiXFx4RDFcIiwgbnRpbGRlOiBcIlxceEYxXCIsIG50bGc6IFwiXFx1MjI3OFwiLCBudHJpYW5nbGVsZWZ0OiBcIlxcdTIyRUFcIiwgbnRyaWFuZ2xlbGVmdGVxOiBcIlxcdTIyRUNcIiwgbnRyaWFuZ2xlcmlnaHQ6IFwiXFx1MjJFQlwiLCBudHJpYW5nbGVyaWdodGVxOiBcIlxcdTIyRURcIiwgTnU6IFwiXFx1MDM5RFwiLCBudTogXCJcXHUwM0JEXCIsIG51bTogXCIjXCIsIG51bWVybzogXCJcXHUyMTE2XCIsIG51bXNwOiBcIlxcdTIwMDdcIiwgbnZhcDogXCJcXHUyMjREXFx1MjBEMlwiLCBudmRhc2g6IFwiXFx1MjJBQ1wiLCBudkRhc2g6IFwiXFx1MjJBRFwiLCBuVmRhc2g6IFwiXFx1MjJBRVwiLCBuVkRhc2g6IFwiXFx1MjJBRlwiLCBudmdlOiBcIlxcdTIyNjVcXHUyMEQyXCIsIG52Z3Q6IFwiPlxcdTIwRDJcIiwgbnZIYXJyOiBcIlxcdTI5MDRcIiwgbnZpbmZpbjogXCJcXHUyOURFXCIsIG52bEFycjogXCJcXHUyOTAyXCIsIG52bGU6IFwiXFx1MjI2NFxcdTIwRDJcIiwgbnZsdDogXCI8XFx1MjBEMlwiLCBudmx0cmllOiBcIlxcdTIyQjRcXHUyMEQyXCIsIG52ckFycjogXCJcXHUyOTAzXCIsIG52cnRyaWU6IFwiXFx1MjJCNVxcdTIwRDJcIiwgbnZzaW06IFwiXFx1MjIzQ1xcdTIwRDJcIiwgbndhcmhrOiBcIlxcdTI5MjNcIiwgbndhcnI6IFwiXFx1MjE5NlwiLCBud0FycjogXCJcXHUyMUQ2XCIsIG53YXJyb3c6IFwiXFx1MjE5NlwiLCBud25lYXI6IFwiXFx1MjkyN1wiLCBPYWN1dGU6IFwiXFx4RDNcIiwgb2FjdXRlOiBcIlxceEYzXCIsIG9hc3Q6IFwiXFx1MjI5QlwiLCBPY2lyYzogXCJcXHhENFwiLCBvY2lyYzogXCJcXHhGNFwiLCBvY2lyOiBcIlxcdTIyOUFcIiwgT2N5OiBcIlxcdTA0MUVcIiwgb2N5OiBcIlxcdTA0M0VcIiwgb2Rhc2g6IFwiXFx1MjI5RFwiLCBPZGJsYWM6IFwiXFx1MDE1MFwiLCBvZGJsYWM6IFwiXFx1MDE1MVwiLCBvZGl2OiBcIlxcdTJBMzhcIiwgb2RvdDogXCJcXHUyMjk5XCIsIG9kc29sZDogXCJcXHUyOUJDXCIsIE9FbGlnOiBcIlxcdTAxNTJcIiwgb2VsaWc6IFwiXFx1MDE1M1wiLCBvZmNpcjogXCJcXHUyOUJGXCIsIE9mcjogXCJcXHV7MUQ1MTJ9XCIsIG9mcjogXCJcXHV7MUQ1MkN9XCIsIG9nb246IFwiXFx1MDJEQlwiLCBPZ3JhdmU6IFwiXFx4RDJcIiwgb2dyYXZlOiBcIlxceEYyXCIsIG9ndDogXCJcXHUyOUMxXCIsIG9oYmFyOiBcIlxcdTI5QjVcIiwgb2htOiBcIlxcdTAzQTlcIiwgb2ludDogXCJcXHUyMjJFXCIsIG9sYXJyOiBcIlxcdTIxQkFcIiwgb2xjaXI6IFwiXFx1MjlCRVwiLCBvbGNyb3NzOiBcIlxcdTI5QkJcIiwgb2xpbmU6IFwiXFx1MjAzRVwiLCBvbHQ6IFwiXFx1MjlDMFwiLCBPbWFjcjogXCJcXHUwMTRDXCIsIG9tYWNyOiBcIlxcdTAxNERcIiwgT21lZ2E6IFwiXFx1MDNBOVwiLCBvbWVnYTogXCJcXHUwM0M5XCIsIE9taWNyb246IFwiXFx1MDM5RlwiLCBvbWljcm9uOiBcIlxcdTAzQkZcIiwgb21pZDogXCJcXHUyOUI2XCIsIG9taW51czogXCJcXHUyMjk2XCIsIE9vcGY6IFwiXFx1ezFENTQ2fVwiLCBvb3BmOiBcIlxcdXsxRDU2MH1cIiwgb3BhcjogXCJcXHUyOUI3XCIsIE9wZW5DdXJseURvdWJsZVF1b3RlOiBcIlxcdTIwMUNcIiwgT3BlbkN1cmx5UXVvdGU6IFwiXFx1MjAxOFwiLCBvcGVycDogXCJcXHUyOUI5XCIsIG9wbHVzOiBcIlxcdTIyOTVcIiwgb3JhcnI6IFwiXFx1MjFCQlwiLCBPcjogXCJcXHUyQTU0XCIsIG9yOiBcIlxcdTIyMjhcIiwgb3JkOiBcIlxcdTJBNURcIiwgb3JkZXI6IFwiXFx1MjEzNFwiLCBvcmRlcm9mOiBcIlxcdTIxMzRcIiwgb3JkZjogXCJcXHhBQVwiLCBvcmRtOiBcIlxceEJBXCIsIG9yaWdvZjogXCJcXHUyMkI2XCIsIG9yb3I6IFwiXFx1MkE1NlwiLCBvcnNsb3BlOiBcIlxcdTJBNTdcIiwgb3J2OiBcIlxcdTJBNUJcIiwgb1M6IFwiXFx1MjRDOFwiLCBPc2NyOiBcIlxcdXsxRDRBQX1cIiwgb3NjcjogXCJcXHUyMTM0XCIsIE9zbGFzaDogXCJcXHhEOFwiLCBvc2xhc2g6IFwiXFx4RjhcIiwgb3NvbDogXCJcXHUyMjk4XCIsIE90aWxkZTogXCJcXHhENVwiLCBvdGlsZGU6IFwiXFx4RjVcIiwgb3RpbWVzYXM6IFwiXFx1MkEzNlwiLCBPdGltZXM6IFwiXFx1MkEzN1wiLCBvdGltZXM6IFwiXFx1MjI5N1wiLCBPdW1sOiBcIlxceEQ2XCIsIG91bWw6IFwiXFx4RjZcIiwgb3ZiYXI6IFwiXFx1MjMzRFwiLCBPdmVyQmFyOiBcIlxcdTIwM0VcIiwgT3ZlckJyYWNlOiBcIlxcdTIzREVcIiwgT3ZlckJyYWNrZXQ6IFwiXFx1MjNCNFwiLCBPdmVyUGFyZW50aGVzaXM6IFwiXFx1MjNEQ1wiLCBwYXJhOiBcIlxceEI2XCIsIHBhcmFsbGVsOiBcIlxcdTIyMjVcIiwgcGFyOiBcIlxcdTIyMjVcIiwgcGFyc2ltOiBcIlxcdTJBRjNcIiwgcGFyc2w6IFwiXFx1MkFGRFwiLCBwYXJ0OiBcIlxcdTIyMDJcIiwgUGFydGlhbEQ6IFwiXFx1MjIwMlwiLCBQY3k6IFwiXFx1MDQxRlwiLCBwY3k6IFwiXFx1MDQzRlwiLCBwZXJjbnQ6IFwiJVwiLCBwZXJpb2Q6IFwiLlwiLCBwZXJtaWw6IFwiXFx1MjAzMFwiLCBwZXJwOiBcIlxcdTIyQTVcIiwgcGVydGVuazogXCJcXHUyMDMxXCIsIFBmcjogXCJcXHV7MUQ1MTN9XCIsIHBmcjogXCJcXHV7MUQ1MkR9XCIsIFBoaTogXCJcXHUwM0E2XCIsIHBoaTogXCJcXHUwM0M2XCIsIHBoaXY6IFwiXFx1MDNENVwiLCBwaG1tYXQ6IFwiXFx1MjEzM1wiLCBwaG9uZTogXCJcXHUyNjBFXCIsIFBpOiBcIlxcdTAzQTBcIiwgcGk6IFwiXFx1MDNDMFwiLCBwaXRjaGZvcms6IFwiXFx1MjJENFwiLCBwaXY6IFwiXFx1MDNENlwiLCBwbGFuY2s6IFwiXFx1MjEwRlwiLCBwbGFuY2toOiBcIlxcdTIxMEVcIiwgcGxhbmt2OiBcIlxcdTIxMEZcIiwgcGx1c2FjaXI6IFwiXFx1MkEyM1wiLCBwbHVzYjogXCJcXHUyMjlFXCIsIHBsdXNjaXI6IFwiXFx1MkEyMlwiLCBwbHVzOiBcIitcIiwgcGx1c2RvOiBcIlxcdTIyMTRcIiwgcGx1c2R1OiBcIlxcdTJBMjVcIiwgcGx1c2U6IFwiXFx1MkE3MlwiLCBQbHVzTWludXM6IFwiXFx4QjFcIiwgcGx1c21uOiBcIlxceEIxXCIsIHBsdXNzaW06IFwiXFx1MkEyNlwiLCBwbHVzdHdvOiBcIlxcdTJBMjdcIiwgcG06IFwiXFx4QjFcIiwgUG9pbmNhcmVwbGFuZTogXCJcXHUyMTBDXCIsIHBvaW50aW50OiBcIlxcdTJBMTVcIiwgcG9wZjogXCJcXHV7MUQ1NjF9XCIsIFBvcGY6IFwiXFx1MjExOVwiLCBwb3VuZDogXCJcXHhBM1wiLCBwcmFwOiBcIlxcdTJBQjdcIiwgUHI6IFwiXFx1MkFCQlwiLCBwcjogXCJcXHUyMjdBXCIsIHByY3VlOiBcIlxcdTIyN0NcIiwgcHJlY2FwcHJveDogXCJcXHUyQUI3XCIsIHByZWM6IFwiXFx1MjI3QVwiLCBwcmVjY3VybHllcTogXCJcXHUyMjdDXCIsIFByZWNlZGVzOiBcIlxcdTIyN0FcIiwgUHJlY2VkZXNFcXVhbDogXCJcXHUyQUFGXCIsIFByZWNlZGVzU2xhbnRFcXVhbDogXCJcXHUyMjdDXCIsIFByZWNlZGVzVGlsZGU6IFwiXFx1MjI3RVwiLCBwcmVjZXE6IFwiXFx1MkFBRlwiLCBwcmVjbmFwcHJveDogXCJcXHUyQUI5XCIsIHByZWNuZXFxOiBcIlxcdTJBQjVcIiwgcHJlY25zaW06IFwiXFx1MjJFOFwiLCBwcmU6IFwiXFx1MkFBRlwiLCBwckU6IFwiXFx1MkFCM1wiLCBwcmVjc2ltOiBcIlxcdTIyN0VcIiwgcHJpbWU6IFwiXFx1MjAzMlwiLCBQcmltZTogXCJcXHUyMDMzXCIsIHByaW1lczogXCJcXHUyMTE5XCIsIHBybmFwOiBcIlxcdTJBQjlcIiwgcHJuRTogXCJcXHUyQUI1XCIsIHBybnNpbTogXCJcXHUyMkU4XCIsIHByb2Q6IFwiXFx1MjIwRlwiLCBQcm9kdWN0OiBcIlxcdTIyMEZcIiwgcHJvZmFsYXI6IFwiXFx1MjMyRVwiLCBwcm9mbGluZTogXCJcXHUyMzEyXCIsIHByb2ZzdXJmOiBcIlxcdTIzMTNcIiwgcHJvcDogXCJcXHUyMjFEXCIsIFByb3BvcnRpb25hbDogXCJcXHUyMjFEXCIsIFByb3BvcnRpb246IFwiXFx1MjIzN1wiLCBwcm9wdG86IFwiXFx1MjIxRFwiLCBwcnNpbTogXCJcXHUyMjdFXCIsIHBydXJlbDogXCJcXHUyMkIwXCIsIFBzY3I6IFwiXFx1ezFENEFCfVwiLCBwc2NyOiBcIlxcdXsxRDRDNX1cIiwgUHNpOiBcIlxcdTAzQThcIiwgcHNpOiBcIlxcdTAzQzhcIiwgcHVuY3NwOiBcIlxcdTIwMDhcIiwgUWZyOiBcIlxcdXsxRDUxNH1cIiwgcWZyOiBcIlxcdXsxRDUyRX1cIiwgcWludDogXCJcXHUyQTBDXCIsIHFvcGY6IFwiXFx1ezFENTYyfVwiLCBRb3BmOiBcIlxcdTIxMUFcIiwgcXByaW1lOiBcIlxcdTIwNTdcIiwgUXNjcjogXCJcXHV7MUQ0QUN9XCIsIHFzY3I6IFwiXFx1ezFENEM2fVwiLCBxdWF0ZXJuaW9uczogXCJcXHUyMTBEXCIsIHF1YXRpbnQ6IFwiXFx1MkExNlwiLCBxdWVzdDogXCI/XCIsIHF1ZXN0ZXE6IFwiXFx1MjI1RlwiLCBxdW90OiAnXCInLCBRVU9UOiAnXCInLCByQWFycjogXCJcXHUyMURCXCIsIHJhY2U6IFwiXFx1MjIzRFxcdTAzMzFcIiwgUmFjdXRlOiBcIlxcdTAxNTRcIiwgcmFjdXRlOiBcIlxcdTAxNTVcIiwgcmFkaWM6IFwiXFx1MjIxQVwiLCByYWVtcHR5djogXCJcXHUyOUIzXCIsIHJhbmc6IFwiXFx1MjdFOVwiLCBSYW5nOiBcIlxcdTI3RUJcIiwgcmFuZ2Q6IFwiXFx1Mjk5MlwiLCByYW5nZTogXCJcXHUyOUE1XCIsIHJhbmdsZTogXCJcXHUyN0U5XCIsIHJhcXVvOiBcIlxceEJCXCIsIHJhcnJhcDogXCJcXHUyOTc1XCIsIHJhcnJiOiBcIlxcdTIxRTVcIiwgcmFycmJmczogXCJcXHUyOTIwXCIsIHJhcnJjOiBcIlxcdTI5MzNcIiwgcmFycjogXCJcXHUyMTkyXCIsIFJhcnI6IFwiXFx1MjFBMFwiLCByQXJyOiBcIlxcdTIxRDJcIiwgcmFycmZzOiBcIlxcdTI5MUVcIiwgcmFycmhrOiBcIlxcdTIxQUFcIiwgcmFycmxwOiBcIlxcdTIxQUNcIiwgcmFycnBsOiBcIlxcdTI5NDVcIiwgcmFycnNpbTogXCJcXHUyOTc0XCIsIFJhcnJ0bDogXCJcXHUyOTE2XCIsIHJhcnJ0bDogXCJcXHUyMUEzXCIsIHJhcnJ3OiBcIlxcdTIxOURcIiwgcmF0YWlsOiBcIlxcdTI5MUFcIiwgckF0YWlsOiBcIlxcdTI5MUNcIiwgcmF0aW86IFwiXFx1MjIzNlwiLCByYXRpb25hbHM6IFwiXFx1MjExQVwiLCByYmFycjogXCJcXHUyOTBEXCIsIHJCYXJyOiBcIlxcdTI5MEZcIiwgUkJhcnI6IFwiXFx1MjkxMFwiLCByYmJyazogXCJcXHUyNzczXCIsIHJicmFjZTogXCJ9XCIsIHJicmFjazogXCJdXCIsIHJicmtlOiBcIlxcdTI5OENcIiwgcmJya3NsZDogXCJcXHUyOThFXCIsIHJicmtzbHU6IFwiXFx1Mjk5MFwiLCBSY2Fyb246IFwiXFx1MDE1OFwiLCByY2Fyb246IFwiXFx1MDE1OVwiLCBSY2VkaWw6IFwiXFx1MDE1NlwiLCByY2VkaWw6IFwiXFx1MDE1N1wiLCByY2VpbDogXCJcXHUyMzA5XCIsIHJjdWI6IFwifVwiLCBSY3k6IFwiXFx1MDQyMFwiLCByY3k6IFwiXFx1MDQ0MFwiLCByZGNhOiBcIlxcdTI5MzdcIiwgcmRsZGhhcjogXCJcXHUyOTY5XCIsIHJkcXVvOiBcIlxcdTIwMURcIiwgcmRxdW9yOiBcIlxcdTIwMURcIiwgcmRzaDogXCJcXHUyMUIzXCIsIHJlYWw6IFwiXFx1MjExQ1wiLCByZWFsaW5lOiBcIlxcdTIxMUJcIiwgcmVhbHBhcnQ6IFwiXFx1MjExQ1wiLCByZWFsczogXCJcXHUyMTFEXCIsIFJlOiBcIlxcdTIxMUNcIiwgcmVjdDogXCJcXHUyNUFEXCIsIHJlZzogXCJcXHhBRVwiLCBSRUc6IFwiXFx4QUVcIiwgUmV2ZXJzZUVsZW1lbnQ6IFwiXFx1MjIwQlwiLCBSZXZlcnNlRXF1aWxpYnJpdW06IFwiXFx1MjFDQlwiLCBSZXZlcnNlVXBFcXVpbGlicml1bTogXCJcXHUyOTZGXCIsIHJmaXNodDogXCJcXHUyOTdEXCIsIHJmbG9vcjogXCJcXHUyMzBCXCIsIHJmcjogXCJcXHV7MUQ1MkZ9XCIsIFJmcjogXCJcXHUyMTFDXCIsIHJIYXI6IFwiXFx1Mjk2NFwiLCByaGFyZDogXCJcXHUyMUMxXCIsIHJoYXJ1OiBcIlxcdTIxQzBcIiwgcmhhcnVsOiBcIlxcdTI5NkNcIiwgUmhvOiBcIlxcdTAzQTFcIiwgcmhvOiBcIlxcdTAzQzFcIiwgcmhvdjogXCJcXHUwM0YxXCIsIFJpZ2h0QW5nbGVCcmFja2V0OiBcIlxcdTI3RTlcIiwgUmlnaHRBcnJvd0JhcjogXCJcXHUyMUU1XCIsIHJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLCBSaWdodEFycm93OiBcIlxcdTIxOTJcIiwgUmlnaHRhcnJvdzogXCJcXHUyMUQyXCIsIFJpZ2h0QXJyb3dMZWZ0QXJyb3c6IFwiXFx1MjFDNFwiLCByaWdodGFycm93dGFpbDogXCJcXHUyMUEzXCIsIFJpZ2h0Q2VpbGluZzogXCJcXHUyMzA5XCIsIFJpZ2h0RG91YmxlQnJhY2tldDogXCJcXHUyN0U3XCIsIFJpZ2h0RG93blRlZVZlY3RvcjogXCJcXHUyOTVEXCIsIFJpZ2h0RG93blZlY3RvckJhcjogXCJcXHUyOTU1XCIsIFJpZ2h0RG93blZlY3RvcjogXCJcXHUyMUMyXCIsIFJpZ2h0Rmxvb3I6IFwiXFx1MjMwQlwiLCByaWdodGhhcnBvb25kb3duOiBcIlxcdTIxQzFcIiwgcmlnaHRoYXJwb29udXA6IFwiXFx1MjFDMFwiLCByaWdodGxlZnRhcnJvd3M6IFwiXFx1MjFDNFwiLCByaWdodGxlZnRoYXJwb29uczogXCJcXHUyMUNDXCIsIHJpZ2h0cmlnaHRhcnJvd3M6IFwiXFx1MjFDOVwiLCByaWdodHNxdWlnYXJyb3c6IFwiXFx1MjE5RFwiLCBSaWdodFRlZUFycm93OiBcIlxcdTIxQTZcIiwgUmlnaHRUZWU6IFwiXFx1MjJBMlwiLCBSaWdodFRlZVZlY3RvcjogXCJcXHUyOTVCXCIsIHJpZ2h0dGhyZWV0aW1lczogXCJcXHUyMkNDXCIsIFJpZ2h0VHJpYW5nbGVCYXI6IFwiXFx1MjlEMFwiLCBSaWdodFRyaWFuZ2xlOiBcIlxcdTIyQjNcIiwgUmlnaHRUcmlhbmdsZUVxdWFsOiBcIlxcdTIyQjVcIiwgUmlnaHRVcERvd25WZWN0b3I6IFwiXFx1Mjk0RlwiLCBSaWdodFVwVGVlVmVjdG9yOiBcIlxcdTI5NUNcIiwgUmlnaHRVcFZlY3RvckJhcjogXCJcXHUyOTU0XCIsIFJpZ2h0VXBWZWN0b3I6IFwiXFx1MjFCRVwiLCBSaWdodFZlY3RvckJhcjogXCJcXHUyOTUzXCIsIFJpZ2h0VmVjdG9yOiBcIlxcdTIxQzBcIiwgcmluZzogXCJcXHUwMkRBXCIsIHJpc2luZ2RvdHNlcTogXCJcXHUyMjUzXCIsIHJsYXJyOiBcIlxcdTIxQzRcIiwgcmxoYXI6IFwiXFx1MjFDQ1wiLCBybG06IFwiXFx1MjAwRlwiLCBybW91c3RhY2hlOiBcIlxcdTIzQjFcIiwgcm1vdXN0OiBcIlxcdTIzQjFcIiwgcm5taWQ6IFwiXFx1MkFFRVwiLCByb2FuZzogXCJcXHUyN0VEXCIsIHJvYXJyOiBcIlxcdTIxRkVcIiwgcm9icms6IFwiXFx1MjdFN1wiLCByb3BhcjogXCJcXHUyOTg2XCIsIHJvcGY6IFwiXFx1ezFENTYzfVwiLCBSb3BmOiBcIlxcdTIxMURcIiwgcm9wbHVzOiBcIlxcdTJBMkVcIiwgcm90aW1lczogXCJcXHUyQTM1XCIsIFJvdW5kSW1wbGllczogXCJcXHUyOTcwXCIsIHJwYXI6IFwiKVwiLCBycGFyZ3Q6IFwiXFx1Mjk5NFwiLCBycHBvbGludDogXCJcXHUyQTEyXCIsIHJyYXJyOiBcIlxcdTIxQzlcIiwgUnJpZ2h0YXJyb3c6IFwiXFx1MjFEQlwiLCByc2FxdW86IFwiXFx1MjAzQVwiLCByc2NyOiBcIlxcdXsxRDRDN31cIiwgUnNjcjogXCJcXHUyMTFCXCIsIHJzaDogXCJcXHUyMUIxXCIsIFJzaDogXCJcXHUyMUIxXCIsIHJzcWI6IFwiXVwiLCByc3F1bzogXCJcXHUyMDE5XCIsIHJzcXVvcjogXCJcXHUyMDE5XCIsIHJ0aHJlZTogXCJcXHUyMkNDXCIsIHJ0aW1lczogXCJcXHUyMkNBXCIsIHJ0cmk6IFwiXFx1MjVCOVwiLCBydHJpZTogXCJcXHUyMkI1XCIsIHJ0cmlmOiBcIlxcdTI1QjhcIiwgcnRyaWx0cmk6IFwiXFx1MjlDRVwiLCBSdWxlRGVsYXllZDogXCJcXHUyOUY0XCIsIHJ1bHVoYXI6IFwiXFx1Mjk2OFwiLCByeDogXCJcXHUyMTFFXCIsIFNhY3V0ZTogXCJcXHUwMTVBXCIsIHNhY3V0ZTogXCJcXHUwMTVCXCIsIHNicXVvOiBcIlxcdTIwMUFcIiwgc2NhcDogXCJcXHUyQUI4XCIsIFNjYXJvbjogXCJcXHUwMTYwXCIsIHNjYXJvbjogXCJcXHUwMTYxXCIsIFNjOiBcIlxcdTJBQkNcIiwgc2M6IFwiXFx1MjI3QlwiLCBzY2N1ZTogXCJcXHUyMjdEXCIsIHNjZTogXCJcXHUyQUIwXCIsIHNjRTogXCJcXHUyQUI0XCIsIFNjZWRpbDogXCJcXHUwMTVFXCIsIHNjZWRpbDogXCJcXHUwMTVGXCIsIFNjaXJjOiBcIlxcdTAxNUNcIiwgc2NpcmM6IFwiXFx1MDE1RFwiLCBzY25hcDogXCJcXHUyQUJBXCIsIHNjbkU6IFwiXFx1MkFCNlwiLCBzY25zaW06IFwiXFx1MjJFOVwiLCBzY3BvbGludDogXCJcXHUyQTEzXCIsIHNjc2ltOiBcIlxcdTIyN0ZcIiwgU2N5OiBcIlxcdTA0MjFcIiwgc2N5OiBcIlxcdTA0NDFcIiwgc2RvdGI6IFwiXFx1MjJBMVwiLCBzZG90OiBcIlxcdTIyQzVcIiwgc2RvdGU6IFwiXFx1MkE2NlwiLCBzZWFyaGs6IFwiXFx1MjkyNVwiLCBzZWFycjogXCJcXHUyMTk4XCIsIHNlQXJyOiBcIlxcdTIxRDhcIiwgc2VhcnJvdzogXCJcXHUyMTk4XCIsIHNlY3Q6IFwiXFx4QTdcIiwgc2VtaTogXCI7XCIsIHNlc3dhcjogXCJcXHUyOTI5XCIsIHNldG1pbnVzOiBcIlxcdTIyMTZcIiwgc2V0bW46IFwiXFx1MjIxNlwiLCBzZXh0OiBcIlxcdTI3MzZcIiwgU2ZyOiBcIlxcdXsxRDUxNn1cIiwgc2ZyOiBcIlxcdXsxRDUzMH1cIiwgc2Zyb3duOiBcIlxcdTIzMjJcIiwgc2hhcnA6IFwiXFx1MjY2RlwiLCBTSENIY3k6IFwiXFx1MDQyOVwiLCBzaGNoY3k6IFwiXFx1MDQ0OVwiLCBTSGN5OiBcIlxcdTA0MjhcIiwgc2hjeTogXCJcXHUwNDQ4XCIsIFNob3J0RG93bkFycm93OiBcIlxcdTIxOTNcIiwgU2hvcnRMZWZ0QXJyb3c6IFwiXFx1MjE5MFwiLCBzaG9ydG1pZDogXCJcXHUyMjIzXCIsIHNob3J0cGFyYWxsZWw6IFwiXFx1MjIyNVwiLCBTaG9ydFJpZ2h0QXJyb3c6IFwiXFx1MjE5MlwiLCBTaG9ydFVwQXJyb3c6IFwiXFx1MjE5MVwiLCBzaHk6IFwiXFx4QURcIiwgU2lnbWE6IFwiXFx1MDNBM1wiLCBzaWdtYTogXCJcXHUwM0MzXCIsIHNpZ21hZjogXCJcXHUwM0MyXCIsIHNpZ21hdjogXCJcXHUwM0MyXCIsIHNpbTogXCJcXHUyMjNDXCIsIHNpbWRvdDogXCJcXHUyQTZBXCIsIHNpbWU6IFwiXFx1MjI0M1wiLCBzaW1lcTogXCJcXHUyMjQzXCIsIHNpbWc6IFwiXFx1MkE5RVwiLCBzaW1nRTogXCJcXHUyQUEwXCIsIHNpbWw6IFwiXFx1MkE5RFwiLCBzaW1sRTogXCJcXHUyQTlGXCIsIHNpbW5lOiBcIlxcdTIyNDZcIiwgc2ltcGx1czogXCJcXHUyQTI0XCIsIHNpbXJhcnI6IFwiXFx1Mjk3MlwiLCBzbGFycjogXCJcXHUyMTkwXCIsIFNtYWxsQ2lyY2xlOiBcIlxcdTIyMThcIiwgc21hbGxzZXRtaW51czogXCJcXHUyMjE2XCIsIHNtYXNocDogXCJcXHUyQTMzXCIsIHNtZXBhcnNsOiBcIlxcdTI5RTRcIiwgc21pZDogXCJcXHUyMjIzXCIsIHNtaWxlOiBcIlxcdTIzMjNcIiwgc210OiBcIlxcdTJBQUFcIiwgc210ZTogXCJcXHUyQUFDXCIsIHNtdGVzOiBcIlxcdTJBQUNcXHVGRTAwXCIsIFNPRlRjeTogXCJcXHUwNDJDXCIsIHNvZnRjeTogXCJcXHUwNDRDXCIsIHNvbGJhcjogXCJcXHUyMzNGXCIsIHNvbGI6IFwiXFx1MjlDNFwiLCBzb2w6IFwiL1wiLCBTb3BmOiBcIlxcdXsxRDU0QX1cIiwgc29wZjogXCJcXHV7MUQ1NjR9XCIsIHNwYWRlczogXCJcXHUyNjYwXCIsIHNwYWRlc3VpdDogXCJcXHUyNjYwXCIsIHNwYXI6IFwiXFx1MjIyNVwiLCBzcWNhcDogXCJcXHUyMjkzXCIsIHNxY2FwczogXCJcXHUyMjkzXFx1RkUwMFwiLCBzcWN1cDogXCJcXHUyMjk0XCIsIHNxY3VwczogXCJcXHUyMjk0XFx1RkUwMFwiLCBTcXJ0OiBcIlxcdTIyMUFcIiwgc3FzdWI6IFwiXFx1MjI4RlwiLCBzcXN1YmU6IFwiXFx1MjI5MVwiLCBzcXN1YnNldDogXCJcXHUyMjhGXCIsIHNxc3Vic2V0ZXE6IFwiXFx1MjI5MVwiLCBzcXN1cDogXCJcXHUyMjkwXCIsIHNxc3VwZTogXCJcXHUyMjkyXCIsIHNxc3Vwc2V0OiBcIlxcdTIyOTBcIiwgc3FzdXBzZXRlcTogXCJcXHUyMjkyXCIsIHNxdWFyZTogXCJcXHUyNUExXCIsIFNxdWFyZTogXCJcXHUyNUExXCIsIFNxdWFyZUludGVyc2VjdGlvbjogXCJcXHUyMjkzXCIsIFNxdWFyZVN1YnNldDogXCJcXHUyMjhGXCIsIFNxdWFyZVN1YnNldEVxdWFsOiBcIlxcdTIyOTFcIiwgU3F1YXJlU3VwZXJzZXQ6IFwiXFx1MjI5MFwiLCBTcXVhcmVTdXBlcnNldEVxdWFsOiBcIlxcdTIyOTJcIiwgU3F1YXJlVW5pb246IFwiXFx1MjI5NFwiLCBzcXVhcmY6IFwiXFx1MjVBQVwiLCBzcXU6IFwiXFx1MjVBMVwiLCBzcXVmOiBcIlxcdTI1QUFcIiwgc3JhcnI6IFwiXFx1MjE5MlwiLCBTc2NyOiBcIlxcdXsxRDRBRX1cIiwgc3NjcjogXCJcXHV7MUQ0Qzh9XCIsIHNzZXRtbjogXCJcXHUyMjE2XCIsIHNzbWlsZTogXCJcXHUyMzIzXCIsIHNzdGFyZjogXCJcXHUyMkM2XCIsIFN0YXI6IFwiXFx1MjJDNlwiLCBzdGFyOiBcIlxcdTI2MDZcIiwgc3RhcmY6IFwiXFx1MjYwNVwiLCBzdHJhaWdodGVwc2lsb246IFwiXFx1MDNGNVwiLCBzdHJhaWdodHBoaTogXCJcXHUwM0Q1XCIsIHN0cm5zOiBcIlxceEFGXCIsIHN1YjogXCJcXHUyMjgyXCIsIFN1YjogXCJcXHUyMkQwXCIsIHN1YmRvdDogXCJcXHUyQUJEXCIsIHN1YkU6IFwiXFx1MkFDNVwiLCBzdWJlOiBcIlxcdTIyODZcIiwgc3ViZWRvdDogXCJcXHUyQUMzXCIsIHN1Ym11bHQ6IFwiXFx1MkFDMVwiLCBzdWJuRTogXCJcXHUyQUNCXCIsIHN1Ym5lOiBcIlxcdTIyOEFcIiwgc3VicGx1czogXCJcXHUyQUJGXCIsIHN1YnJhcnI6IFwiXFx1Mjk3OVwiLCBzdWJzZXQ6IFwiXFx1MjI4MlwiLCBTdWJzZXQ6IFwiXFx1MjJEMFwiLCBzdWJzZXRlcTogXCJcXHUyMjg2XCIsIHN1YnNldGVxcTogXCJcXHUyQUM1XCIsIFN1YnNldEVxdWFsOiBcIlxcdTIyODZcIiwgc3Vic2V0bmVxOiBcIlxcdTIyOEFcIiwgc3Vic2V0bmVxcTogXCJcXHUyQUNCXCIsIHN1YnNpbTogXCJcXHUyQUM3XCIsIHN1YnN1YjogXCJcXHUyQUQ1XCIsIHN1YnN1cDogXCJcXHUyQUQzXCIsIHN1Y2NhcHByb3g6IFwiXFx1MkFCOFwiLCBzdWNjOiBcIlxcdTIyN0JcIiwgc3VjY2N1cmx5ZXE6IFwiXFx1MjI3RFwiLCBTdWNjZWVkczogXCJcXHUyMjdCXCIsIFN1Y2NlZWRzRXF1YWw6IFwiXFx1MkFCMFwiLCBTdWNjZWVkc1NsYW50RXF1YWw6IFwiXFx1MjI3RFwiLCBTdWNjZWVkc1RpbGRlOiBcIlxcdTIyN0ZcIiwgc3VjY2VxOiBcIlxcdTJBQjBcIiwgc3VjY25hcHByb3g6IFwiXFx1MkFCQVwiLCBzdWNjbmVxcTogXCJcXHUyQUI2XCIsIHN1Y2Nuc2ltOiBcIlxcdTIyRTlcIiwgc3VjY3NpbTogXCJcXHUyMjdGXCIsIFN1Y2hUaGF0OiBcIlxcdTIyMEJcIiwgc3VtOiBcIlxcdTIyMTFcIiwgU3VtOiBcIlxcdTIyMTFcIiwgc3VuZzogXCJcXHUyNjZBXCIsIHN1cDE6IFwiXFx4QjlcIiwgc3VwMjogXCJcXHhCMlwiLCBzdXAzOiBcIlxceEIzXCIsIHN1cDogXCJcXHUyMjgzXCIsIFN1cDogXCJcXHUyMkQxXCIsIHN1cGRvdDogXCJcXHUyQUJFXCIsIHN1cGRzdWI6IFwiXFx1MkFEOFwiLCBzdXBFOiBcIlxcdTJBQzZcIiwgc3VwZTogXCJcXHUyMjg3XCIsIHN1cGVkb3Q6IFwiXFx1MkFDNFwiLCBTdXBlcnNldDogXCJcXHUyMjgzXCIsIFN1cGVyc2V0RXF1YWw6IFwiXFx1MjI4N1wiLCBzdXBoc29sOiBcIlxcdTI3QzlcIiwgc3VwaHN1YjogXCJcXHUyQUQ3XCIsIHN1cGxhcnI6IFwiXFx1Mjk3QlwiLCBzdXBtdWx0OiBcIlxcdTJBQzJcIiwgc3VwbkU6IFwiXFx1MkFDQ1wiLCBzdXBuZTogXCJcXHUyMjhCXCIsIHN1cHBsdXM6IFwiXFx1MkFDMFwiLCBzdXBzZXQ6IFwiXFx1MjI4M1wiLCBTdXBzZXQ6IFwiXFx1MjJEMVwiLCBzdXBzZXRlcTogXCJcXHUyMjg3XCIsIHN1cHNldGVxcTogXCJcXHUyQUM2XCIsIHN1cHNldG5lcTogXCJcXHUyMjhCXCIsIHN1cHNldG5lcXE6IFwiXFx1MkFDQ1wiLCBzdXBzaW06IFwiXFx1MkFDOFwiLCBzdXBzdWI6IFwiXFx1MkFENFwiLCBzdXBzdXA6IFwiXFx1MkFENlwiLCBzd2FyaGs6IFwiXFx1MjkyNlwiLCBzd2FycjogXCJcXHUyMTk5XCIsIHN3QXJyOiBcIlxcdTIxRDlcIiwgc3dhcnJvdzogXCJcXHUyMTk5XCIsIHN3bndhcjogXCJcXHUyOTJBXCIsIHN6bGlnOiBcIlxceERGXCIsIFRhYjogXCJcdFwiLCB0YXJnZXQ6IFwiXFx1MjMxNlwiLCBUYXU6IFwiXFx1MDNBNFwiLCB0YXU6IFwiXFx1MDNDNFwiLCB0YnJrOiBcIlxcdTIzQjRcIiwgVGNhcm9uOiBcIlxcdTAxNjRcIiwgdGNhcm9uOiBcIlxcdTAxNjVcIiwgVGNlZGlsOiBcIlxcdTAxNjJcIiwgdGNlZGlsOiBcIlxcdTAxNjNcIiwgVGN5OiBcIlxcdTA0MjJcIiwgdGN5OiBcIlxcdTA0NDJcIiwgdGRvdDogXCJcXHUyMERCXCIsIHRlbHJlYzogXCJcXHUyMzE1XCIsIFRmcjogXCJcXHV7MUQ1MTd9XCIsIHRmcjogXCJcXHV7MUQ1MzF9XCIsIHRoZXJlNDogXCJcXHUyMjM0XCIsIHRoZXJlZm9yZTogXCJcXHUyMjM0XCIsIFRoZXJlZm9yZTogXCJcXHUyMjM0XCIsIFRoZXRhOiBcIlxcdTAzOThcIiwgdGhldGE6IFwiXFx1MDNCOFwiLCB0aGV0YXN5bTogXCJcXHUwM0QxXCIsIHRoZXRhdjogXCJcXHUwM0QxXCIsIHRoaWNrYXBwcm94OiBcIlxcdTIyNDhcIiwgdGhpY2tzaW06IFwiXFx1MjIzQ1wiLCBUaGlja1NwYWNlOiBcIlxcdTIwNUZcXHUyMDBBXCIsIFRoaW5TcGFjZTogXCJcXHUyMDA5XCIsIHRoaW5zcDogXCJcXHUyMDA5XCIsIHRoa2FwOiBcIlxcdTIyNDhcIiwgdGhrc2ltOiBcIlxcdTIyM0NcIiwgVEhPUk46IFwiXFx4REVcIiwgdGhvcm46IFwiXFx4RkVcIiwgdGlsZGU6IFwiXFx1MDJEQ1wiLCBUaWxkZTogXCJcXHUyMjNDXCIsIFRpbGRlRXF1YWw6IFwiXFx1MjI0M1wiLCBUaWxkZUZ1bGxFcXVhbDogXCJcXHUyMjQ1XCIsIFRpbGRlVGlsZGU6IFwiXFx1MjI0OFwiLCB0aW1lc2JhcjogXCJcXHUyQTMxXCIsIHRpbWVzYjogXCJcXHUyMkEwXCIsIHRpbWVzOiBcIlxceEQ3XCIsIHRpbWVzZDogXCJcXHUyQTMwXCIsIHRpbnQ6IFwiXFx1MjIyRFwiLCB0b2VhOiBcIlxcdTI5MjhcIiwgdG9wYm90OiBcIlxcdTIzMzZcIiwgdG9wY2lyOiBcIlxcdTJBRjFcIiwgdG9wOiBcIlxcdTIyQTRcIiwgVG9wZjogXCJcXHV7MUQ1NEJ9XCIsIHRvcGY6IFwiXFx1ezFENTY1fVwiLCB0b3Bmb3JrOiBcIlxcdTJBREFcIiwgdG9zYTogXCJcXHUyOTI5XCIsIHRwcmltZTogXCJcXHUyMDM0XCIsIHRyYWRlOiBcIlxcdTIxMjJcIiwgVFJBREU6IFwiXFx1MjEyMlwiLCB0cmlhbmdsZTogXCJcXHUyNUI1XCIsIHRyaWFuZ2xlZG93bjogXCJcXHUyNUJGXCIsIHRyaWFuZ2xlbGVmdDogXCJcXHUyNUMzXCIsIHRyaWFuZ2xlbGVmdGVxOiBcIlxcdTIyQjRcIiwgdHJpYW5nbGVxOiBcIlxcdTIyNUNcIiwgdHJpYW5nbGVyaWdodDogXCJcXHUyNUI5XCIsIHRyaWFuZ2xlcmlnaHRlcTogXCJcXHUyMkI1XCIsIHRyaWRvdDogXCJcXHUyNUVDXCIsIHRyaWU6IFwiXFx1MjI1Q1wiLCB0cmltaW51czogXCJcXHUyQTNBXCIsIFRyaXBsZURvdDogXCJcXHUyMERCXCIsIHRyaXBsdXM6IFwiXFx1MkEzOVwiLCB0cmlzYjogXCJcXHUyOUNEXCIsIHRyaXRpbWU6IFwiXFx1MkEzQlwiLCB0cnBleml1bTogXCJcXHUyM0UyXCIsIFRzY3I6IFwiXFx1ezFENEFGfVwiLCB0c2NyOiBcIlxcdXsxRDRDOX1cIiwgVFNjeTogXCJcXHUwNDI2XCIsIHRzY3k6IFwiXFx1MDQ0NlwiLCBUU0hjeTogXCJcXHUwNDBCXCIsIHRzaGN5OiBcIlxcdTA0NUJcIiwgVHN0cm9rOiBcIlxcdTAxNjZcIiwgdHN0cm9rOiBcIlxcdTAxNjdcIiwgdHdpeHQ6IFwiXFx1MjI2Q1wiLCB0d29oZWFkbGVmdGFycm93OiBcIlxcdTIxOUVcIiwgdHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFBMFwiLCBVYWN1dGU6IFwiXFx4REFcIiwgdWFjdXRlOiBcIlxceEZBXCIsIHVhcnI6IFwiXFx1MjE5MVwiLCBVYXJyOiBcIlxcdTIxOUZcIiwgdUFycjogXCJcXHUyMUQxXCIsIFVhcnJvY2lyOiBcIlxcdTI5NDlcIiwgVWJyY3k6IFwiXFx1MDQwRVwiLCB1YnJjeTogXCJcXHUwNDVFXCIsIFVicmV2ZTogXCJcXHUwMTZDXCIsIHVicmV2ZTogXCJcXHUwMTZEXCIsIFVjaXJjOiBcIlxceERCXCIsIHVjaXJjOiBcIlxceEZCXCIsIFVjeTogXCJcXHUwNDIzXCIsIHVjeTogXCJcXHUwNDQzXCIsIHVkYXJyOiBcIlxcdTIxQzVcIiwgVWRibGFjOiBcIlxcdTAxNzBcIiwgdWRibGFjOiBcIlxcdTAxNzFcIiwgdWRoYXI6IFwiXFx1Mjk2RVwiLCB1ZmlzaHQ6IFwiXFx1Mjk3RVwiLCBVZnI6IFwiXFx1ezFENTE4fVwiLCB1ZnI6IFwiXFx1ezFENTMyfVwiLCBVZ3JhdmU6IFwiXFx4RDlcIiwgdWdyYXZlOiBcIlxceEY5XCIsIHVIYXI6IFwiXFx1Mjk2M1wiLCB1aGFybDogXCJcXHUyMUJGXCIsIHVoYXJyOiBcIlxcdTIxQkVcIiwgdWhibGs6IFwiXFx1MjU4MFwiLCB1bGNvcm46IFwiXFx1MjMxQ1wiLCB1bGNvcm5lcjogXCJcXHUyMzFDXCIsIHVsY3JvcDogXCJcXHUyMzBGXCIsIHVsdHJpOiBcIlxcdTI1RjhcIiwgVW1hY3I6IFwiXFx1MDE2QVwiLCB1bWFjcjogXCJcXHUwMTZCXCIsIHVtbDogXCJcXHhBOFwiLCBVbmRlckJhcjogXCJfXCIsIFVuZGVyQnJhY2U6IFwiXFx1MjNERlwiLCBVbmRlckJyYWNrZXQ6IFwiXFx1MjNCNVwiLCBVbmRlclBhcmVudGhlc2lzOiBcIlxcdTIzRERcIiwgVW5pb246IFwiXFx1MjJDM1wiLCBVbmlvblBsdXM6IFwiXFx1MjI4RVwiLCBVb2dvbjogXCJcXHUwMTcyXCIsIHVvZ29uOiBcIlxcdTAxNzNcIiwgVW9wZjogXCJcXHV7MUQ1NEN9XCIsIHVvcGY6IFwiXFx1ezFENTY2fVwiLCBVcEFycm93QmFyOiBcIlxcdTI5MTJcIiwgdXBhcnJvdzogXCJcXHUyMTkxXCIsIFVwQXJyb3c6IFwiXFx1MjE5MVwiLCBVcGFycm93OiBcIlxcdTIxRDFcIiwgVXBBcnJvd0Rvd25BcnJvdzogXCJcXHUyMUM1XCIsIHVwZG93bmFycm93OiBcIlxcdTIxOTVcIiwgVXBEb3duQXJyb3c6IFwiXFx1MjE5NVwiLCBVcGRvd25hcnJvdzogXCJcXHUyMUQ1XCIsIFVwRXF1aWxpYnJpdW06IFwiXFx1Mjk2RVwiLCB1cGhhcnBvb25sZWZ0OiBcIlxcdTIxQkZcIiwgdXBoYXJwb29ucmlnaHQ6IFwiXFx1MjFCRVwiLCB1cGx1czogXCJcXHUyMjhFXCIsIFVwcGVyTGVmdEFycm93OiBcIlxcdTIxOTZcIiwgVXBwZXJSaWdodEFycm93OiBcIlxcdTIxOTdcIiwgdXBzaTogXCJcXHUwM0M1XCIsIFVwc2k6IFwiXFx1MDNEMlwiLCB1cHNpaDogXCJcXHUwM0QyXCIsIFVwc2lsb246IFwiXFx1MDNBNVwiLCB1cHNpbG9uOiBcIlxcdTAzQzVcIiwgVXBUZWVBcnJvdzogXCJcXHUyMUE1XCIsIFVwVGVlOiBcIlxcdTIyQTVcIiwgdXB1cGFycm93czogXCJcXHUyMUM4XCIsIHVyY29ybjogXCJcXHUyMzFEXCIsIHVyY29ybmVyOiBcIlxcdTIzMURcIiwgdXJjcm9wOiBcIlxcdTIzMEVcIiwgVXJpbmc6IFwiXFx1MDE2RVwiLCB1cmluZzogXCJcXHUwMTZGXCIsIHVydHJpOiBcIlxcdTI1RjlcIiwgVXNjcjogXCJcXHV7MUQ0QjB9XCIsIHVzY3I6IFwiXFx1ezFENENBfVwiLCB1dGRvdDogXCJcXHUyMkYwXCIsIFV0aWxkZTogXCJcXHUwMTY4XCIsIHV0aWxkZTogXCJcXHUwMTY5XCIsIHV0cmk6IFwiXFx1MjVCNVwiLCB1dHJpZjogXCJcXHUyNUI0XCIsIHV1YXJyOiBcIlxcdTIxQzhcIiwgVXVtbDogXCJcXHhEQ1wiLCB1dW1sOiBcIlxceEZDXCIsIHV3YW5nbGU6IFwiXFx1MjlBN1wiLCB2YW5ncnQ6IFwiXFx1Mjk5Q1wiLCB2YXJlcHNpbG9uOiBcIlxcdTAzRjVcIiwgdmFya2FwcGE6IFwiXFx1MDNGMFwiLCB2YXJub3RoaW5nOiBcIlxcdTIyMDVcIiwgdmFycGhpOiBcIlxcdTAzRDVcIiwgdmFycGk6IFwiXFx1MDNENlwiLCB2YXJwcm9wdG86IFwiXFx1MjIxRFwiLCB2YXJyOiBcIlxcdTIxOTVcIiwgdkFycjogXCJcXHUyMUQ1XCIsIHZhcnJobzogXCJcXHUwM0YxXCIsIHZhcnNpZ21hOiBcIlxcdTAzQzJcIiwgdmFyc3Vic2V0bmVxOiBcIlxcdTIyOEFcXHVGRTAwXCIsIHZhcnN1YnNldG5lcXE6IFwiXFx1MkFDQlxcdUZFMDBcIiwgdmFyc3Vwc2V0bmVxOiBcIlxcdTIyOEJcXHVGRTAwXCIsIHZhcnN1cHNldG5lcXE6IFwiXFx1MkFDQ1xcdUZFMDBcIiwgdmFydGhldGE6IFwiXFx1MDNEMVwiLCB2YXJ0cmlhbmdsZWxlZnQ6IFwiXFx1MjJCMlwiLCB2YXJ0cmlhbmdsZXJpZ2h0OiBcIlxcdTIyQjNcIiwgdkJhcjogXCJcXHUyQUU4XCIsIFZiYXI6IFwiXFx1MkFFQlwiLCB2QmFydjogXCJcXHUyQUU5XCIsIFZjeTogXCJcXHUwNDEyXCIsIHZjeTogXCJcXHUwNDMyXCIsIHZkYXNoOiBcIlxcdTIyQTJcIiwgdkRhc2g6IFwiXFx1MjJBOFwiLCBWZGFzaDogXCJcXHUyMkE5XCIsIFZEYXNoOiBcIlxcdTIyQUJcIiwgVmRhc2hsOiBcIlxcdTJBRTZcIiwgdmVlYmFyOiBcIlxcdTIyQkJcIiwgdmVlOiBcIlxcdTIyMjhcIiwgVmVlOiBcIlxcdTIyQzFcIiwgdmVlZXE6IFwiXFx1MjI1QVwiLCB2ZWxsaXA6IFwiXFx1MjJFRVwiLCB2ZXJiYXI6IFwifFwiLCBWZXJiYXI6IFwiXFx1MjAxNlwiLCB2ZXJ0OiBcInxcIiwgVmVydDogXCJcXHUyMDE2XCIsIFZlcnRpY2FsQmFyOiBcIlxcdTIyMjNcIiwgVmVydGljYWxMaW5lOiBcInxcIiwgVmVydGljYWxTZXBhcmF0b3I6IFwiXFx1Mjc1OFwiLCBWZXJ0aWNhbFRpbGRlOiBcIlxcdTIyNDBcIiwgVmVyeVRoaW5TcGFjZTogXCJcXHUyMDBBXCIsIFZmcjogXCJcXHV7MUQ1MTl9XCIsIHZmcjogXCJcXHV7MUQ1MzN9XCIsIHZsdHJpOiBcIlxcdTIyQjJcIiwgdm5zdWI6IFwiXFx1MjI4MlxcdTIwRDJcIiwgdm5zdXA6IFwiXFx1MjI4M1xcdTIwRDJcIiwgVm9wZjogXCJcXHV7MUQ1NER9XCIsIHZvcGY6IFwiXFx1ezFENTY3fVwiLCB2cHJvcDogXCJcXHUyMjFEXCIsIHZydHJpOiBcIlxcdTIyQjNcIiwgVnNjcjogXCJcXHV7MUQ0QjF9XCIsIHZzY3I6IFwiXFx1ezFENENCfVwiLCB2c3VibkU6IFwiXFx1MkFDQlxcdUZFMDBcIiwgdnN1Ym5lOiBcIlxcdTIyOEFcXHVGRTAwXCIsIHZzdXBuRTogXCJcXHUyQUNDXFx1RkUwMFwiLCB2c3VwbmU6IFwiXFx1MjI4QlxcdUZFMDBcIiwgVnZkYXNoOiBcIlxcdTIyQUFcIiwgdnppZ3phZzogXCJcXHUyOTlBXCIsIFdjaXJjOiBcIlxcdTAxNzRcIiwgd2NpcmM6IFwiXFx1MDE3NVwiLCB3ZWRiYXI6IFwiXFx1MkE1RlwiLCB3ZWRnZTogXCJcXHUyMjI3XCIsIFdlZGdlOiBcIlxcdTIyQzBcIiwgd2VkZ2VxOiBcIlxcdTIyNTlcIiwgd2VpZXJwOiBcIlxcdTIxMThcIiwgV2ZyOiBcIlxcdXsxRDUxQX1cIiwgd2ZyOiBcIlxcdXsxRDUzNH1cIiwgV29wZjogXCJcXHV7MUQ1NEV9XCIsIHdvcGY6IFwiXFx1ezFENTY4fVwiLCB3cDogXCJcXHUyMTE4XCIsIHdyOiBcIlxcdTIyNDBcIiwgd3JlYXRoOiBcIlxcdTIyNDBcIiwgV3NjcjogXCJcXHV7MUQ0QjJ9XCIsIHdzY3I6IFwiXFx1ezFENENDfVwiLCB4Y2FwOiBcIlxcdTIyQzJcIiwgeGNpcmM6IFwiXFx1MjVFRlwiLCB4Y3VwOiBcIlxcdTIyQzNcIiwgeGR0cmk6IFwiXFx1MjVCRFwiLCBYZnI6IFwiXFx1ezFENTFCfVwiLCB4ZnI6IFwiXFx1ezFENTM1fVwiLCB4aGFycjogXCJcXHUyN0Y3XCIsIHhoQXJyOiBcIlxcdTI3RkFcIiwgWGk6IFwiXFx1MDM5RVwiLCB4aTogXCJcXHUwM0JFXCIsIHhsYXJyOiBcIlxcdTI3RjVcIiwgeGxBcnI6IFwiXFx1MjdGOFwiLCB4bWFwOiBcIlxcdTI3RkNcIiwgeG5pczogXCJcXHUyMkZCXCIsIHhvZG90OiBcIlxcdTJBMDBcIiwgWG9wZjogXCJcXHV7MUQ1NEZ9XCIsIHhvcGY6IFwiXFx1ezFENTY5fVwiLCB4b3BsdXM6IFwiXFx1MkEwMVwiLCB4b3RpbWU6IFwiXFx1MkEwMlwiLCB4cmFycjogXCJcXHUyN0Y2XCIsIHhyQXJyOiBcIlxcdTI3RjlcIiwgWHNjcjogXCJcXHV7MUQ0QjN9XCIsIHhzY3I6IFwiXFx1ezFENENEfVwiLCB4c3FjdXA6IFwiXFx1MkEwNlwiLCB4dXBsdXM6IFwiXFx1MkEwNFwiLCB4dXRyaTogXCJcXHUyNUIzXCIsIHh2ZWU6IFwiXFx1MjJDMVwiLCB4d2VkZ2U6IFwiXFx1MjJDMFwiLCBZYWN1dGU6IFwiXFx4RERcIiwgeWFjdXRlOiBcIlxceEZEXCIsIFlBY3k6IFwiXFx1MDQyRlwiLCB5YWN5OiBcIlxcdTA0NEZcIiwgWWNpcmM6IFwiXFx1MDE3NlwiLCB5Y2lyYzogXCJcXHUwMTc3XCIsIFljeTogXCJcXHUwNDJCXCIsIHljeTogXCJcXHUwNDRCXCIsIHllbjogXCJcXHhBNVwiLCBZZnI6IFwiXFx1ezFENTFDfVwiLCB5ZnI6IFwiXFx1ezFENTM2fVwiLCBZSWN5OiBcIlxcdTA0MDdcIiwgeWljeTogXCJcXHUwNDU3XCIsIFlvcGY6IFwiXFx1ezFENTUwfVwiLCB5b3BmOiBcIlxcdXsxRDU2QX1cIiwgWXNjcjogXCJcXHV7MUQ0QjR9XCIsIHlzY3I6IFwiXFx1ezFENENFfVwiLCBZVWN5OiBcIlxcdTA0MkVcIiwgeXVjeTogXCJcXHUwNDRFXCIsIHl1bWw6IFwiXFx4RkZcIiwgWXVtbDogXCJcXHUwMTc4XCIsIFphY3V0ZTogXCJcXHUwMTc5XCIsIHphY3V0ZTogXCJcXHUwMTdBXCIsIFpjYXJvbjogXCJcXHUwMTdEXCIsIHpjYXJvbjogXCJcXHUwMTdFXCIsIFpjeTogXCJcXHUwNDE3XCIsIHpjeTogXCJcXHUwNDM3XCIsIFpkb3Q6IFwiXFx1MDE3QlwiLCB6ZG90OiBcIlxcdTAxN0NcIiwgemVldHJmOiBcIlxcdTIxMjhcIiwgWmVyb1dpZHRoU3BhY2U6IFwiXFx1MjAwQlwiLCBaZXRhOiBcIlxcdTAzOTZcIiwgemV0YTogXCJcXHUwM0I2XCIsIHpmcjogXCJcXHV7MUQ1Mzd9XCIsIFpmcjogXCJcXHUyMTI4XCIsIFpIY3k6IFwiXFx1MDQxNlwiLCB6aGN5OiBcIlxcdTA0MzZcIiwgemlncmFycjogXCJcXHUyMUREXCIsIHpvcGY6IFwiXFx1ezFENTZCfVwiLCBab3BmOiBcIlxcdTIxMjRcIiwgWnNjcjogXCJcXHV7MUQ0QjV9XCIsIHpzY3I6IFwiXFx1ezFENENGfVwiLCB6d2o6IFwiXFx1MjAwRFwiLCB6d25qOiBcIlxcdTIwMENcIiB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vZW50aXRpZXMuanNcbnZhciByZXF1aXJlX2VudGl0aWVzMiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2VudGl0aWVzLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlX2VudGl0aWVzKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzXG52YXIgcmVxdWlyZV9yZWdleCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IC9bIS0jJS1cXCosLVxcLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MDlGRFxcdTBBNzZcXHUwQUYwXFx1MEM4NFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0RVxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwM1tcXHVERjU1LVxcdURGNTldfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOFxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQzRCLVxcdURDNEZcXHVEQzVCXFx1REM1RFxcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERTYwLVxcdURFNkNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDZbXFx1REMzQlxcdURFM0YtXFx1REU0NlxcdURFOUEtXFx1REU5Q1xcdURFOUUtXFx1REVBMl18XFx1RDgwN1tcXHVEQzQxLVxcdURDNDVcXHVEQzcwXFx1REM3MVxcdURFRjdcXHVERUY4XXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODFCW1xcdURFOTctXFx1REU5QV18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdLztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tZHVybC9lbmNvZGUuanNcbnZhciByZXF1aXJlX2VuY29kZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tZHVybC9lbmNvZGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZW5jb2RlQ2FjaGUgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gICAgICB2YXIgaSwgY2gsIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV07XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgICAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5wdXNoKFwiJVwiICsgKFwiMFwiICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FjaGVbZXhjbHVkZS5jaGFyQ29kZUF0KGkpXSA9IGV4Y2x1ZGVbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShzdHJpbmcsIGV4Y2x1ZGUsIGtlZXBFc2NhcGVkKSB7XG4gICAgICB2YXIgaSwgbCwgY29kZTIsIG5leHRDb2RlLCBjYWNoZSwgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBrZWVwRXNjYXBlZCA9IGV4Y2x1ZGU7XG4gICAgICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29kZTIgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUyID09PSAzNyAmJiBpICsgMiA8IGwpIHtcbiAgICAgICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUyIDwgMTI4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGUyXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZTIgPj0gNTUyOTYgJiYgY29kZTIgPD0gNTczNDMpIHtcbiAgICAgICAgICBpZiAoY29kZTIgPj0gNTUyOTYgJiYgY29kZTIgPD0gNTYzMTkgJiYgaSArIDEgPCBsKSB7XG4gICAgICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q29kZSA+PSA1NjMyMCAmJiBuZXh0Q29kZSA8PSA1NzM0Mykge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gXCIlRUYlQkYlQkRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGUuZGVmYXVsdENoYXJzID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuICAgIGVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzXG52YXIgcmVxdWlyZV9kZWNvZGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWR1cmwvZGVjb2RlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGRlY29kZUNhY2hlID0ge307XG4gICAgZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICAgICAgdmFyIGksIGNoLCBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICAgIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGNhY2hlLnB1c2goY2gpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBleGNsdWRlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNhY2hlW2NoXSA9IFwiJVwiICsgKFwiMFwiICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZXhjbHVkZSkge1xuICAgICAgdmFyIGNhY2hlO1xuICAgICAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xuICAgICAgfVxuICAgICAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICAgICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaHIsIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBzZXEubGVuZ3RoOyBpIDwgbDsgaSArPSAzKSB7XG4gICAgICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuICAgICAgICAgIGlmIChiMSA8IDEyOCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKGIxICYgMjI0KSA9PT0gMTkyICYmIGkgKyAzIDwgbCkge1xuICAgICAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICAgICAgaWYgKChiMiAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgICAgICBjaHIgPSBiMSA8PCA2ICYgMTk4NCB8IGIyICYgNjM7XG4gICAgICAgICAgICAgIGlmIChjaHIgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXHVGRkZEXFx1RkZGRFwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChiMSAmIDI0MCkgPT09IDIyNCAmJiBpICsgNiA8IGwpIHtcbiAgICAgICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcbiAgICAgICAgICAgIGlmICgoYjIgJiAxOTIpID09PSAxMjggJiYgKGIzICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgICAgIGNociA9IGIxIDw8IDEyICYgNjE0NDAgfCBiMiA8PCA2ICYgNDAzMiB8IGIzICYgNjM7XG4gICAgICAgICAgICAgIGlmIChjaHIgPCAyMDQ4IHx8IGNociA+PSA1NTI5NiAmJiBjaHIgPD0gNTczNDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXHVGRkZEXFx1RkZGRFxcdUZGRkRcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgoYjEgJiAyNDgpID09PSAyNDAgJiYgaSArIDkgPCBsKSB7XG4gICAgICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgICAgICBiNCA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMTAsIGkgKyAxMiksIDE2KTtcbiAgICAgICAgICAgIGlmICgoYjIgJiAxOTIpID09PSAxMjggJiYgKGIzICYgMTkyKSA9PT0gMTI4ICYmIChiNCAmIDE5MikgPT09IDEyOCkge1xuICAgICAgICAgICAgICBjaHIgPSBiMSA8PCAxOCAmIDE4MzUwMDggfCBiMiA8PCAxMiAmIDI1ODA0OCB8IGIzIDw8IDYgJiA0MDMyIHwgYjQgJiA2MztcbiAgICAgICAgICAgICAgaWYgKGNociA8IDY1NTM2IHx8IGNociA+IDExMTQxMTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXHVGRkZEXFx1RkZGRFxcdUZGRkRcXHVGRkZEXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hyIC09IDY1NTM2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2ICsgKGNociA+PiAxMCksIDU2MzIwICsgKGNociAmIDEwMjMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gXCJcXHVGRkZEXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvZGUuZGVmYXVsdENoYXJzID0gXCI7Lz86QCY9KyQsI1wiO1xuICAgIGRlY29kZS5jb21wb25lbnRDaGFycyA9IFwiXCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWR1cmwvZm9ybWF0LmpzXG52YXIgcmVxdWlyZV9mb3JtYXQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWR1cmwvZm9ybWF0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JtYXQyKHVybCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8IFwiXCI7XG4gICAgICByZXN1bHQgKz0gdXJsLnNsYXNoZXMgPyBcIi8vXCIgOiBcIlwiO1xuICAgICAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyBcIkBcIiA6IFwiXCI7XG4gICAgICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiW1wiICsgdXJsLmhvc3RuYW1lICsgXCJdXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8IFwiXCI7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gdXJsLnBvcnQgPyBcIjpcIiArIHVybC5wb3J0IDogXCJcIjtcbiAgICAgIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgXCJcIjtcbiAgICAgIHJlc3VsdCArPSB1cmwuc2VhcmNoIHx8IFwiXCI7XG4gICAgICByZXN1bHQgKz0gdXJsLmhhc2ggfHwgXCJcIjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tZHVybC9wYXJzZS5qc1xudmFyIHJlcXVpcmVfcGFyc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWR1cmwvcGFyc2UuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBVcmwoKSB7XG4gICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gICAgICB0aGlzLmF1dGggPSBudWxsO1xuICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgdGhpcy5oYXNoID0gbnVsbDtcbiAgICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaTtcbiAgICB2YXIgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvO1xuICAgIHZhciBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC87XG4gICAgdmFyIGRlbGltcyA9IFtcIjxcIiwgXCI+XCIsICdcIicsIFwiYFwiLCBcIiBcIiwgXCJcXHJcIiwgXCJcXG5cIiwgXCJcdFwiXTtcbiAgICB2YXIgdW53aXNlID0gW1wie1wiLCBcIn1cIiwgXCJ8XCIsIFwiXFxcXFwiLCBcIl5cIiwgXCJgXCJdLmNvbmNhdChkZWxpbXMpO1xuICAgIHZhciBhdXRvRXNjYXBlID0gW1wiJ1wiXS5jb25jYXQodW53aXNlKTtcbiAgICB2YXIgbm9uSG9zdENoYXJzID0gW1wiJVwiLCBcIi9cIiwgXCI/XCIsIFwiO1wiLCBcIiNcIl0uY29uY2F0KGF1dG9Fc2NhcGUpO1xuICAgIHZhciBob3N0RW5kaW5nQ2hhcnMgPSBbXCIvXCIsIFwiP1wiLCBcIiNcIl07XG4gICAgdmFyIGhvc3RuYW1lTWF4TGVuID0gMjU1O1xuICAgIHZhciBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvO1xuICAgIHZhciBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLztcbiAgICB2YXIgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgIFwiamF2YXNjcmlwdFwiOiB0cnVlLFxuICAgICAgXCJqYXZhc2NyaXB0OlwiOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgXCJodHRwXCI6IHRydWUsXG4gICAgICBcImh0dHBzXCI6IHRydWUsXG4gICAgICBcImZ0cFwiOiB0cnVlLFxuICAgICAgXCJnb3BoZXJcIjogdHJ1ZSxcbiAgICAgIFwiZmlsZVwiOiB0cnVlLFxuICAgICAgXCJodHRwOlwiOiB0cnVlLFxuICAgICAgXCJodHRwczpcIjogdHJ1ZSxcbiAgICAgIFwiZnRwOlwiOiB0cnVlLFxuICAgICAgXCJnb3BoZXI6XCI6IHRydWUsXG4gICAgICBcImZpbGU6XCI6IHRydWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVybFBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICAgIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgICB9XG4gICAgICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgICAgIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICAgIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsIHJlc3QgPSB1cmw7XG4gICAgICByZXN0ID0gcmVzdC50cmltKCk7XG4gICAgICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdChcIiNcIikubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICAgICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICAgICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICAgICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSBcIi8vXCI7XG4gICAgICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYgKHNsYXNoZXMgfHwgcHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoXCJAXCIsIGhvc3RFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB9XG4gICAgICAgIGhvc3RFbmQgPSAtMTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICBob3N0RW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcbiAgICAgICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSBcIltcIiAmJiB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09IFwiXVwiO1xuICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld3BhcnQgPSBcIlwiO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBcInhcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbihcIi5cIikgKyByZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoXCIjXCIpO1xuICAgICAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgICAgIH1cbiAgICAgIHZhciBxbSA9IHJlc3QuaW5kZXhPZihcIj9cIik7XG4gICAgICBpZiAocW0gIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdCkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgICAgIH1cbiAgICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiYgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gICAgICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gICAgICBpZiAocG9ydCkge1xuICAgICAgICBwb3J0ID0gcG9ydFswXTtcbiAgICAgICAgaWYgKHBvcnQgIT09IFwiOlwiKSB7XG4gICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG4gICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21kdXJsL2luZGV4LmpzXG52YXIgcmVxdWlyZV9tZHVybCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmVfZW5jb2RlKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZV9kZWNvZGUoKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5mb3JtYXQgPSByZXF1aXJlX2Zvcm1hdCgpO1xuICAgIG1vZHVsZS5leHBvcnRzLnBhcnNlID0gcmVxdWlyZV9wYXJzZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzXG52YXIgcmVxdWlyZV9yZWdleDIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvdWMubWljcm8vcHJvcGVydGllcy9BbnkvcmVnZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IC9bXFwwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0vO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXguanNcbnZhciByZXF1aXJlX3JlZ2V4MyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAvW1xcMC1cXHgxRlxceDdGLVxceDlGXS87XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9DZi9yZWdleC5qc1xudmFyIHJlcXVpcmVfcmVnZXg0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IC9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS87XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzXG52YXIgcmVxdWlyZV9yZWdleDUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAvWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2luZGV4LmpzXG52YXIgcmVxdWlyZV91YyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBleHBvcnRzLkFueSA9IHJlcXVpcmVfcmVnZXgyKCk7XG4gICAgZXhwb3J0cy5DYyA9IHJlcXVpcmVfcmVnZXgzKCk7XG4gICAgZXhwb3J0cy5DZiA9IHJlcXVpcmVfcmVnZXg0KCk7XG4gICAgZXhwb3J0cy5QID0gcmVxdWlyZV9yZWdleCgpO1xuICAgIGV4cG9ydHMuWiA9IHJlcXVpcmVfcmVnZXg1KCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qc1xudmFyIHJlcXVpcmVfdXRpbHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi91dGlscy5qc1wiKGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBfY2xhc3Mob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgICAgcmV0dXJuIF9jbGFzcyhvYmopID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xuICAgIH1cbiAgICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnbihvYmopIHtcbiAgICAgIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArIFwibXVzdCBiZSBvYmplY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoc3JjLnNsaWNlKDAsIHBvcyksIG5ld0VsZW1lbnRzLCBzcmMuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkRW50aXR5Q29kZShjKSB7XG4gICAgICBpZiAoYyA+PSA1NTI5NiAmJiBjIDw9IDU3MzQzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDY0OTc2ICYmIGMgPD0gNjUwMDcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKChjICYgNjU1MzUpID09PSA2NTUzNSB8fCAoYyAmIDY1NTM1KSA9PT0gNjU1MzQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gMCAmJiBjIDw9IDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDExKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDE0ICYmIGMgPD0gMzEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGMgPj0gMTI3ICYmIGMgPD0gMTU5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID4gMTExNDExMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjKSB7XG4gICAgICBpZiAoYyA+IDY1NTM1KSB7XG4gICAgICAgIGMgLT0gNjU1MzY7XG4gICAgICAgIHZhciBzdXJyb2dhdGUxID0gNTUyOTYgKyAoYyA+PiAxMCksIHN1cnJvZ2F0ZTIgPSA1NjMyMCArIChjICYgMTAyMyk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgfVxuICAgIHZhciBVTkVTQ0FQRV9NRF9SRSA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLlxcLzo7PD0+P0BbXFxcXFxcXV5fYHt8fX5dKS9nO1xuICAgIHZhciBFTlRJVFlfUkUgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xuICAgIHZhciBVTkVTQ0FQRV9BTExfUkUgPSBuZXcgUmVnRXhwKFVORVNDQVBFX01EX1JFLnNvdXJjZSArIFwifFwiICsgRU5USVRZX1JFLnNvdXJjZSwgXCJnaVwiKTtcbiAgICB2YXIgRElHSVRBTF9FTlRJVFlfVEVTVF9SRSA9IC9eIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSkvaTtcbiAgICB2YXIgZW50aXRpZXMgPSByZXF1aXJlX2VudGl0aWVzMigpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gICAgICB2YXIgY29kZTIgPSAwO1xuICAgICAgaWYgKGhhcyhlbnRpdGllcywgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0aWVzW25hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMzUgJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvZGUyID0gbmFtZVsxXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIiA/IHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KSA6IHBhcnNlSW50KG5hbWUuc2xpY2UoMSksIDEwKTtcbiAgICAgICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUyKSkge1xuICAgICAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKFwiXFxcXFwiKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgXCIkMVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVBbGwoc3RyKSB7XG4gICAgICBpZiAoc3RyLmluZGV4T2YoXCJcXFxcXCIpIDwgMCAmJiBzdHIuaW5kZXhPZihcIiZcIikgPCAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBIVE1MX0VTQ0FQRV9URVNUX1JFID0gL1smPD5cIl0vO1xuICAgIHZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbiAgICB2YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgICAgJ1wiJzogXCImcXVvdDtcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgICAgIHJldHVybiBIVE1MX1JFUExBQ0VNRU5UU1tjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZUh0bWwyKHN0cikge1xuICAgICAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG4gICAgZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgXCJcXFxcJCZcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU3BhY2UoY29kZTIpIHtcbiAgICAgIHN3aXRjaCAoY29kZTIpIHtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZTIpIHtcbiAgICAgIGlmIChjb2RlMiA+PSA4MTkyICYmIGNvZGUyIDw9IDgyMDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNvZGUyKSB7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgIGNhc2UgNTc2MDpcbiAgICAgICAgY2FzZSA4MjM5OlxuICAgICAgICBjYXNlIDgyODc6XG4gICAgICAgIGNhc2UgMTIyODg6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZV9yZWdleCgpO1xuICAgIGZ1bmN0aW9uIGlzUHVuY3RDaGFyKGNoKSB7XG4gICAgICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgY2FzZSAzODpcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgY2FzZSA0NDpcbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgY2FzZSA5NDpcbiAgICAgICAgY2FzZSA5NTpcbiAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGNhc2UgMTI0OlxuICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gICAgICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICAgICAgaWYgKFwiXFx1MUU5RVwiLnRvTG93ZXJDYXNlKCkgPT09IFwiXFx1MUU3RVwiKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/hup4vZywgXCJcXHhERlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBleHBvcnRzLmxpYiA9IHt9O1xuICAgIGV4cG9ydHMubGliLm1kdXJsID0gcmVxdWlyZV9tZHVybCgpO1xuICAgIGV4cG9ydHMubGliLnVjbWljcm8gPSByZXF1aXJlX3VjKCk7XG4gICAgZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG4gICAgZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGV4cG9ydHMuaGFzID0gaGFzO1xuICAgIGV4cG9ydHMudW5lc2NhcGVNZCA9IHVuZXNjYXBlTWQ7XG4gICAgZXhwb3J0cy51bmVzY2FwZUFsbCA9IHVuZXNjYXBlQWxsO1xuICAgIGV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgPSBpc1ZhbGlkRW50aXR5Q29kZTtcbiAgICBleHBvcnRzLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50O1xuICAgIGV4cG9ydHMuZXNjYXBlSHRtbCA9IGVzY2FwZUh0bWwyO1xuICAgIGV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgPSBhcnJheVJlcGxhY2VBdDtcbiAgICBleHBvcnRzLmlzU3BhY2UgPSBpc1NwYWNlO1xuICAgIGV4cG9ydHMuaXNXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlO1xuICAgIGV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgPSBpc01kQXNjaWlQdW5jdDtcbiAgICBleHBvcnRzLmlzUHVuY3RDaGFyID0gaXNQdW5jdENoYXI7XG4gICAgZXhwb3J0cy5lc2NhcGVSRSA9IGVzY2FwZVJFO1xuICAgIGV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlID0gbm9ybWFsaXplUmVmZXJlbmNlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfbGFiZWwuanNcbnZhciByZXF1aXJlX3BhcnNlX2xpbmtfbGFiZWwgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwoc3RhdGUsIHN0YXJ0LCBkaXNhYmxlTmVzdGVkKSB7XG4gICAgICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsIGxhYmVsRW5kID0gLTEsIG1heDIgPSBzdGF0ZS5wb3NNYXgsIG9sZFBvcyA9IHN0YXRlLnBvcztcbiAgICAgIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgICAgIGxldmVsID0gMTtcbiAgICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgyKSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDkzKSB7XG4gICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2UG9zID0gc3RhdGUucG9zO1xuICAgICAgICBzdGF0ZS5tZC5pbmxpbmUuc2tpcFRva2VuKHN0YXRlKTtcbiAgICAgICAgaWYgKG1hcmtlciA9PT0gOTEpIHtcbiAgICAgICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBsYWJlbEVuZCA9IHN0YXRlLnBvcztcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBsYWJlbEVuZDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanNcbnZhciByZXF1aXJlX3BhcnNlX2xpbmtfZGVzdGluYXRpb24gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmVfdXRpbHMoKS51bmVzY2FwZUFsbDtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgyKSB7XG4gICAgICB2YXIgY29kZTIsIGxldmVsLCBsaW5lcyA9IDAsIHN0YXJ0ID0gcG9zLCByZXN1bHQgPSB7XG4gICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICBsaW5lczogMCxcbiAgICAgICAgc3RyOiBcIlwiXG4gICAgICB9O1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDYwKSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgIGNvZGUyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoY29kZTIgPT09IDEwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDYwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDYyKSB7XG4gICAgICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDkyICYmIHBvcyArIDEgPCBtYXgyKSB7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV2ZWwgPSAwO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgY29kZTIgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY29kZTIgPT09IDMyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUyIDwgMzIgfHwgY29kZTIgPT09IDEyNykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlMiA9PT0gOTIgJiYgcG9zICsgMSA8IG1heDIpIHtcbiAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDMyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUyID09PSA0MCkge1xuICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgaWYgKGxldmVsID4gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlMiA9PT0gNDEpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5wb3MgPSBwb3M7XG4gICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfdGl0bGUuanNcbnZhciByZXF1aXJlX3BhcnNlX2xpbmtfdGl0bGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmVfdXRpbHMoKS51bmVzY2FwZUFsbDtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgyKSB7XG4gICAgICB2YXIgY29kZTIsIG1hcmtlciwgbGluZXMgPSAwLCBzdGFydCA9IHBvcywgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogXCJcIlxuICAgICAgfTtcbiAgICAgIGlmIChwb3MgPj0gbWF4Mikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbWFya2VyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChtYXJrZXIgIT09IDM0ICYmIG1hcmtlciAhPT0gMzkgJiYgbWFya2VyICE9PSA0MCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcG9zKys7XG4gICAgICBpZiAobWFya2VyID09PSA0MCkge1xuICAgICAgICBtYXJrZXIgPSA0MTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNvZGUyID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNvZGUyID09PSBtYXJrZXIpIHtcbiAgICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgICAgICByZXN1bHQuc3RyID0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKSk7XG4gICAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUyID09PSA0MCAmJiBtYXJrZXIgPT09IDQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlMiA9PT0gMTApIHtcbiAgICAgICAgICBsaW5lcysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUyID09PSA5MiAmJiBwb3MgKyAxIDwgbWF4Mikge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICAgbGluZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanNcbnZhciByZXF1aXJlX2hlbHBlcnMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCA9IHJlcXVpcmVfcGFyc2VfbGlua19sYWJlbCgpO1xuICAgIGV4cG9ydHMucGFyc2VMaW5rRGVzdGluYXRpb24gPSByZXF1aXJlX3BhcnNlX2xpbmtfZGVzdGluYXRpb24oKTtcbiAgICBleHBvcnRzLnBhcnNlTGlua1RpdGxlID0gcmVxdWlyZV9wYXJzZV9saW5rX3RpdGxlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3JlbmRlcmVyLmpzXG52YXIgcmVxdWlyZV9yZW5kZXJlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYXNzaWduID0gcmVxdWlyZV91dGlscygpLmFzc2lnbjtcbiAgICB2YXIgdW5lc2NhcGVBbGwgPSByZXF1aXJlX3V0aWxzKCkudW5lc2NhcGVBbGw7XG4gICAgdmFyIGVzY2FwZUh0bWwyID0gcmVxdWlyZV91dGlscygpLmVzY2FwZUh0bWw7XG4gICAgdmFyIGRlZmF1bHRfcnVsZXMgPSB7fTtcbiAgICBkZWZhdWx0X3J1bGVzLmNvZGVfaW5saW5lID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgICAgIHJldHVybiBcIjxjb2RlXCIgKyBzbGYucmVuZGVyQXR0cnModG9rZW4pICsgXCI+XCIgKyBlc2NhcGVIdG1sMih0b2tlbnNbaWR4XS5jb250ZW50KSArIFwiPC9jb2RlPlwiO1xuICAgIH07XG4gICAgZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgICAgIHJldHVybiBcIjxwcmVcIiArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyBcIj48Y29kZT5cIiArIGVzY2FwZUh0bWwyKHRva2Vuc1tpZHhdLmNvbnRlbnQpICsgXCI8L2NvZGU+PC9wcmU+XFxuXCI7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSwgaW5mbyA9IHRva2VuLmluZm8gPyB1bmVzY2FwZUFsbCh0b2tlbi5pbmZvKS50cmltKCkgOiBcIlwiLCBsYW5nTmFtZSA9IFwiXCIsIGxhbmdBdHRycyA9IFwiXCIsIGhpZ2hsaWdodGVkLCBpLCBhcnIsIHRtcEF0dHJzLCB0bXBUb2tlbjtcbiAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgIGFyciA9IGluZm8uc3BsaXQoLyhcXHMrKS9nKTtcbiAgICAgICAgbGFuZ05hbWUgPSBhcnJbMF07XG4gICAgICAgIGxhbmdBdHRycyA9IGFyci5zbGljZSgyKS5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQodG9rZW4uY29udGVudCwgbGFuZ05hbWUsIGxhbmdBdHRycykgfHwgZXNjYXBlSHRtbDIodG9rZW4uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaWdobGlnaHRlZCA9IGVzY2FwZUh0bWwyKHRva2VuLmNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGhpZ2hsaWdodGVkLmluZGV4T2YoXCI8cHJlXCIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBoaWdobGlnaHRlZCArIFwiXFxuXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpID0gdG9rZW4uYXR0ckluZGV4KFwiY2xhc3NcIik7XG4gICAgICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgIHRtcEF0dHJzLnB1c2goW1wiY2xhc3NcIiwgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXBBdHRyc1tpXSA9IHRtcEF0dHJzW2ldLnNsaWNlKCk7XG4gICAgICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gXCIgXCIgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0bXBUb2tlbiA9IHtcbiAgICAgICAgICBhdHRyczogdG1wQXR0cnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFwiPHByZT48Y29kZVwiICsgc2xmLnJlbmRlckF0dHJzKHRtcFRva2VuKSArIFwiPlwiICsgaGlnaGxpZ2h0ZWQgKyBcIjwvY29kZT48L3ByZT5cXG5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIjxwcmU+PGNvZGVcIiArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyBcIj5cIiArIGhpZ2hsaWdodGVkICsgXCI8L2NvZGU+PC9wcmU+XFxuXCI7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcbiAgICAgIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleChcImFsdFwiKV1bMV0gPSBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgICAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBkZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy54aHRtbE91dCA/IFwiPGJyIC8+XFxuXCIgOiBcIjxicj5cXG5cIjtcbiAgICB9O1xuICAgIGRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IG9wdGlvbnMueGh0bWxPdXQgPyBcIjxiciAvPlxcblwiIDogXCI8YnI+XFxuXCIgOiBcIlxcblwiO1xuICAgIH07XG4gICAgZGVmYXVsdF9ydWxlcy50ZXh0ID0gZnVuY3Rpb24odG9rZW5zLCBpZHgpIHtcbiAgICAgIHJldHVybiBlc2NhcGVIdG1sMih0b2tlbnNbaWR4XS5jb250ZW50KTtcbiAgICB9O1xuICAgIGRlZmF1bHRfcnVsZXMuaHRtbF9ibG9jayA9IGZ1bmN0aW9uKHRva2VucywgaWR4KSB7XG4gICAgICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbiAgICB9O1xuICAgIGRlZmF1bHRfcnVsZXMuaHRtbF9pbmxpbmUgPSBmdW5jdGlvbih0b2tlbnMsIGlkeCkge1xuICAgICAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xuICAgIH1cbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICAgICAgdmFyIGksIGwsIHJlc3VsdDtcbiAgICAgIGlmICghdG9rZW4uYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBcIlwiO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyBlc2NhcGVIdG1sMih0b2tlbi5hdHRyc1tpXVswXSkgKyAnPVwiJyArIGVzY2FwZUh0bWwyKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBuZXh0VG9rZW4sIHJlc3VsdCA9IFwiXCIsIG5lZWRMZiA9IGZhbHNlLCB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuICAgICAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgICAgICByZXN1bHQgKz0gXCJcXG5cIjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyBcIjwvXCIgOiBcIjxcIikgKyB0b2tlbi50YWc7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJBdHRycyh0b2tlbik7XG4gICAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiAvXCI7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4uYmxvY2spIHtcbiAgICAgICAgbmVlZExmID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gXCJpbmxpbmVcIiB8fCBuZXh0VG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgICAgIG5lZWRMZiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IG5lZWRMZiA/IFwiPlxcblwiIDogXCI+XCI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gICAgICB2YXIgdHlwZSwgcmVzdWx0ID0gXCJcIiwgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24odG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodG9rZW5zW2ldLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHRva2Vuc1tpXS5jb250ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSBcInNvZnRicmVha1wiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24odG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgICAgIHZhciBpLCBsZW4sIHR5cGUsIHJlc3VsdCA9IFwiXCIsIHJ1bGVzID0gdGhpcy5ydWxlcztcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gcnVsZXNbdG9rZW5zW2ldLnR5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlci5qc1xudmFyIHJlcXVpcmVfcnVsZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gUnVsZXIoKSB7XG4gICAgICB0aGlzLl9fcnVsZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgIH1cbiAgICBSdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9fcnVsZXNfX1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYWlucyA9IFtcIlwiXTtcbiAgICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICBpZiAoIXJ1bGUuZW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydWxlLmFsdC5mb3JFYWNoKGZ1bmN0aW9uKGFsdE5hbWUpIHtcbiAgICAgICAgICBpZiAoY2hhaW5zLmluZGV4T2YoYWx0TmFtZSkgPCAwKSB7XG4gICAgICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzZWxmLl9fY2FjaGVfXyA9IHt9O1xuICAgICAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24oY2hhaW4pIHtcbiAgICAgICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgICAgIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgIGlmICghcnVsZS5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dLnB1c2gocnVsZS5mbik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihuYW1lLCBmbiwgb3B0aW9ucykge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgcnVsZSBub3QgZm91bmQ6IFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uZm4gPSBmbjtcbiAgICAgIHRoaXMuX19ydWxlc19fW2luZGV4XS5hbHQgPSBvcHQuYWx0IHx8IFtdO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgIH07XG4gICAgUnVsZXIucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKTtcbiAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgcnVsZSBub3QgZm91bmQ6IFwiICsgYmVmb3JlTmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICAgICAgbmFtZTogcnVsZU5hbWUsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZuLFxuICAgICAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgIH07XG4gICAgUnVsZXIucHJvdG90eXBlLmFmdGVyID0gZnVuY3Rpb24oYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18oYWZ0ZXJOYW1lKTtcbiAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZXIgcnVsZSBub3QgZm91bmQ6IFwiICsgYWZ0ZXJOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICAgICAgbmFtZTogcnVsZU5hbWUsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZuLFxuICAgICAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgIH07XG4gICAgUnVsZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgICAgIG5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBmbixcbiAgICAgICAgYWx0OiBvcHQuYWx0IHx8IFtdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbihsaXN0MiwgaWdub3JlSW52YWxpZCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QyKSkge1xuICAgICAgICBsaXN0MiA9IFtsaXN0Ml07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBsaXN0Mi5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZXMgbWFuYWdlcjogaW52YWxpZCBydWxlIG5hbWUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5lbmFibGVPbmx5ID0gZnVuY3Rpb24obGlzdDIsIGlnbm9yZUludmFsaWQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0MikpIHtcbiAgICAgICAgbGlzdDIgPSBbbGlzdDJdO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgIHJ1bGUuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVuYWJsZShsaXN0MiwgaWdub3JlSW52YWxpZCk7XG4gICAgfTtcbiAgICBSdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGxpc3QyLCBpZ25vcmVJbnZhbGlkKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdDIpKSB7XG4gICAgICAgIGxpc3QyID0gW2xpc3QyXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGxpc3QyLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKTtcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICBpZiAoaWdub3JlSW52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFJ1bGVyLnByb3RvdHlwZS5nZXRSdWxlcyA9IGZ1bmN0aW9uKGNoYWluTmFtZSkge1xuICAgICAgaWYgKHRoaXMuX19jYWNoZV9fID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX19jb21waWxlX18oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanNcbnZhciByZXF1aXJlX25vcm1hbGl6ZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgTkVXTElORVNfUkUgPSAvXFxyXFxuP3xcXG4vZztcbiAgICB2YXIgTlVMTF9SRSA9IC9cXDAvZztcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShzdGF0ZSkge1xuICAgICAgdmFyIHN0cjtcbiAgICAgIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCBcIlxcblwiKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsIFwiXFx1RkZGRFwiKTtcbiAgICAgIHN0YXRlLnNyYyA9IHN0cjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzXG52YXIgcmVxdWlyZV9ibG9jayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2szKHN0YXRlKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICBpZiAoc3RhdGUuaW5saW5lTW9kZSkge1xuICAgICAgICB0b2tlbiA9IG5ldyBzdGF0ZS5Ub2tlbihcImlubGluZVwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYztcbiAgICAgICAgdG9rZW4ubWFwID0gWzAsIDFdO1xuICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgICBzdGF0ZS50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5tZC5ibG9jay5wYXJzZShzdGF0ZS5zcmMsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHN0YXRlLnRva2Vucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanNcbnZhciByZXF1aXJlX2lubGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZTMoc3RhdGUpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIHRvaywgaSwgbDtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRvayA9IHRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRvay50eXBlID09PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzXG52YXIgcmVxdWlyZV9saW5raWZ5ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2xpbmtpZnkuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYXJyYXlSZXBsYWNlQXQgPSByZXF1aXJlX3V0aWxzKCkuYXJyYXlSZXBsYWNlQXQ7XG4gICAgZnVuY3Rpb24gaXNMaW5rT3BlbihzdHIpIHtcbiAgICAgIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpbmtDbG9zZShzdHIpIHtcbiAgICAgIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua2lmeShzdGF0ZSkge1xuICAgICAgdmFyIGksIGosIGwsIHRva2VucywgdG9rZW4sIGN1cnJlbnRUb2tlbiwgbm9kZXMsIGxuLCB0ZXh0MiwgcG9zLCBsYXN0UG9zLCBsZXZlbCwgaHRtbExpbmtMZXZlbCwgdXJsLCBmdWxsVXJsLCB1cmxUZXh0LCBibG9ja1Rva2VucyA9IHN0YXRlLnRva2VucywgbGlua3M7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMubGlua2lmeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSBcImlubGluZVwiIHx8ICFzdGF0ZS5tZC5saW5raWZ5LnByZXRlc3QoYmxvY2tUb2tlbnNbal0uY29udGVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcbiAgICAgICAgaHRtbExpbmtMZXZlbCA9IDA7XG4gICAgICAgIGZvciAoaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICBpZiAoY3VycmVudFRva2VuLnR5cGUgPT09IFwibGlua19jbG9zZVwiKSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09IFwibGlua19vcGVuXCIpIHtcbiAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gXCJodG1sX2lubGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgaHRtbExpbmtMZXZlbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgICAgICBodG1sTGlua0xldmVsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgc3RhdGUubWQubGlua2lmeS50ZXN0KGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgICAgdGV4dDIgPSBjdXJyZW50VG9rZW4uY29udGVudDtcbiAgICAgICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0Mik7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgbGV2ZWwgPSBjdXJyZW50VG9rZW4ubGV2ZWw7XG4gICAgICAgICAgICBsYXN0UG9zID0gMDtcbiAgICAgICAgICAgIGZvciAobG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xuICAgICAgICAgICAgICB1cmwgPSBsaW5rc1tsbl0udXJsO1xuICAgICAgICAgICAgICBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVybFRleHQgPSBsaW5rc1tsbl0udGV4dDtcbiAgICAgICAgICAgICAgaWYgKCFsaW5rc1tsbl0uc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KFwiaHR0cDovL1wiICsgdXJsVGV4dCkucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgXCJcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobGlua3NbbG5dLnNjaGVtYSA9PT0gXCJtYWlsdG86XCIgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgICAgICB1cmxUZXh0ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQoXCJtYWlsdG86XCIgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sIFwiXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb3MgPSBsaW5rc1tsbl0uaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oXCJ0ZXh0XCIsIFwiXCIsIDApO1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0Mi5zbGljZShsYXN0UG9zLCBwb3MpO1xuICAgICAgICAgICAgICAgIHRva2VuLmxldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oXCJsaW5rX29wZW5cIiwgXCJhXCIsIDEpO1xuICAgICAgICAgICAgICB0b2tlbi5hdHRycyA9IFtbXCJocmVmXCIsIGZ1bGxVcmxdXTtcbiAgICAgICAgICAgICAgdG9rZW4ubGV2ZWwgPSBsZXZlbCsrO1xuICAgICAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImxpbmtpZnlcIjtcbiAgICAgICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgdG9rZW4gPSBuZXcgc3RhdGUuVG9rZW4oXCJ0ZXh0XCIsIFwiXCIsIDApO1xuICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdXJsVGV4dDtcbiAgICAgICAgICAgICAgdG9rZW4ubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKFwibGlua19jbG9zZVwiLCBcImFcIiwgLTEpO1xuICAgICAgICAgICAgICB0b2tlbi5sZXZlbCA9IC0tbGV2ZWw7XG4gICAgICAgICAgICAgIHRva2VuLm1hcmt1cCA9IFwibGlua2lmeVwiO1xuICAgICAgICAgICAgICB0b2tlbi5pbmZvID0gXCJhdXRvXCI7XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICBsYXN0UG9zID0gbGlua3NbbG5dLmxhc3RJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dDIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gbmV3IHN0YXRlLlRva2VuKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQyLnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgICAgICB0b2tlbi5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanNcbnZhciByZXF1aXJlX3JlcGxhY2VtZW50cyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG4gICAgdmFyIFNDT1BFRF9BQkJSX1RFU1RfUkUgPSAvXFwoKGN8dG18cnxwKVxcKS9pO1xuICAgIHZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xuICAgIHZhciBTQ09QRURfQUJCUiA9IHtcbiAgICAgIGM6IFwiXFx4QTlcIixcbiAgICAgIHI6IFwiXFx4QUVcIixcbiAgICAgIHA6IFwiXFx4QTdcIixcbiAgICAgIHRtOiBcIlxcdTIxMjJcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gICAgICByZXR1cm4gU0NPUEVEX0FCQlJbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGFjZV9zY29wZWQoaW5saW5lVG9rZW5zKSB7XG4gICAgICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG4gICAgICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcInRleHRcIiAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZShTQ09QRURfQUJCUl9SRSwgcmVwbGFjZUZuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJsaW5rX29wZW5cIiAmJiB0b2tlbi5pbmZvID09PSBcImF1dG9cIikge1xuICAgICAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImxpbmtfY2xvc2VcIiAmJiB0b2tlbi5pbmZvID09PSBcImF1dG9cIikge1xuICAgICAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2VfcmFyZShpbmxpbmVUb2tlbnMpIHtcbiAgICAgIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcbiAgICAgIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwidGV4dFwiICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgICAgICBpZiAoUkFSRV9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKC9cXCstL2csIFwiXFx4QjFcIikucmVwbGFjZSgvXFwuezIsfS9nLCBcIlxcdTIwMjZcIikucmVwbGFjZSgvKFs/IV0p4oCmL2csIFwiJDEuLlwiKS5yZXBsYWNlKC8oWz8hXSl7NCx9L2csIFwiJDEkMSQxXCIpLnJlcGxhY2UoLyx7Mix9L2csIFwiLFwiKS5yZXBsYWNlKC8oXnxbXi1dKS0tLSg/PVteLV18JCkvbWcsIFwiJDFcXHUyMDE0XCIpLnJlcGxhY2UoLyhefFxccyktLSg/PVxcc3wkKS9tZywgXCIkMVxcdTIwMTNcIikucmVwbGFjZSgvKF58W14tXFxzXSktLSg/PVteLVxcc118JCkvbWcsIFwiJDFcXHUyMDEzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJsaW5rX29wZW5cIiAmJiB0b2tlbi5pbmZvID09PSBcImF1dG9cIikge1xuICAgICAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImxpbmtfY2xvc2VcIiAmJiB0b2tlbi5pbmZvID09PSBcImF1dG9cIikge1xuICAgICAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICAgICAgdmFyIGJsa0lkeDtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcbiAgICAgICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU0NPUEVEX0FCQlJfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgICAgICByZXBsYWNlX3JhcmUoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5qc1xudmFyIHJlcXVpcmVfc21hcnRxdW90ZXMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNXaGl0ZVNwYWNlID0gcmVxdWlyZV91dGlscygpLmlzV2hpdGVTcGFjZTtcbiAgICB2YXIgaXNQdW5jdENoYXIgPSByZXF1aXJlX3V0aWxzKCkuaXNQdW5jdENoYXI7XG4gICAgdmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZV91dGlscygpLmlzTWRBc2NpaVB1bmN0O1xuICAgIHZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbiAgICB2YXIgUVVPVEVfUkUgPSAvWydcIl0vZztcbiAgICB2YXIgQVBPU1RST1BIRSA9IFwiXFx1MjAxOVwiO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaW5kZXgpICsgY2ggKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NfaW5saW5lcyh0b2tlbnMsIHN0YXRlKSB7XG4gICAgICB2YXIgaSwgdG9rZW4sIHRleHQyLCB0LCBwb3MsIG1heDIsIHRoaXNMZXZlbCwgaXRlbTIsIGxhc3RDaGFyLCBuZXh0Q2hhciwgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRQdW5jdENoYXIsIGlzTGFzdFdoaXRlU3BhY2UsIGlzTmV4dFdoaXRlU3BhY2UsIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcbiAgICAgIHN0YWNrID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICB0aGlzTGV2ZWwgPSB0b2tlbnNbaV0ubGV2ZWw7XG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDw9IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0MiA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgIHBvcyA9IDA7XG4gICAgICAgIG1heDIgPSB0ZXh0Mi5sZW5ndGg7XG4gICAgICAgIE9VVEVSOlxuICAgICAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0Mik7XG4gICAgICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICAgICAgICBpc1NpbmdsZSA9IHRbMF0gPT09IFwiJ1wiO1xuICAgICAgICAgICAgbGFzdENoYXIgPSAzMjtcbiAgICAgICAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgIGxhc3RDaGFyID0gdGV4dDIuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09IFwic29mdGJyZWFrXCIgfHwgdG9rZW5zW2pdLnR5cGUgPT09IFwiaGFyZGJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIXRva2Vuc1tqXS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGFzdENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KHRva2Vuc1tqXS5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Q2hhciA9IDMyO1xuICAgICAgICAgICAgaWYgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgICAgICAgbmV4dENoYXIgPSB0ZXh0Mi5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSA9PT0gXCJzb2Z0YnJlYWtcIiB8fCB0b2tlbnNbal0udHlwZSA9PT0gXCJoYXJkYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5zW2pdLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gICAgICAgICAgICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuICAgICAgICAgICAgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcik7XG4gICAgICAgICAgICBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKTtcbiAgICAgICAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICAgICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gMzQgJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICBpZiAobGFzdENoYXIgPj0gNDggJiYgbGFzdENoYXIgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICBjYW5DbG9zZSA9IGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgY2FuT3BlbiA9IGlzTGFzdFB1bmN0Q2hhcjtcbiAgICAgICAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbk9wZW4gJiYgIWNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBpdGVtMiA9IHN0YWNrW2pdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtMi5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW0yID0gc3RhY2tbal07XG4gICAgICAgICAgICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMl07XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1szXTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIGNsb3NlUXVvdGUpO1xuICAgICAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0yLnRva2VuXS5jb250ZW50ID0gcmVwbGFjZUF0KHRva2Vuc1tpdGVtMi50b2tlbl0uY29udGVudCwgaXRlbTIucG9zLCBvcGVuUXVvdGUpO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IGNsb3NlUXVvdGUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtMi50b2tlbiA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0ZXh0MiA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICBtYXgyID0gdGV4dDIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgICAgIHZhciBibGtJZHg7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG4gICAgICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSBcImlubGluZVwiIHx8ICFRVU9URV9URVNUX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzX2lubGluZXMoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5qc1xudmFyIHJlcXVpcmVfdG9rZW4gPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3Rva2VuLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgIHRoaXMubWFwID0gbnVsbDtcbiAgICAgIHRoaXMubmVzdGluZyA9IG5lc3Rpbmc7XG4gICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICAgIHRoaXMubWFya3VwID0gXCJcIjtcbiAgICAgIHRoaXMuaW5mbyA9IFwiXCI7XG4gICAgICB0aGlzLm1ldGEgPSBudWxsO1xuICAgICAgdGhpcy5ibG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XG4gICAgICB2YXIgYXR0cnMsIGksIGxlbjtcbiAgICAgIGlmICghdGhpcy5hdHRycykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBhdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBhdHRycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmF0dHJQdXNoID0gZnVuY3Rpb24gYXR0clB1c2goYXR0ckRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJzID0gW2F0dHJEYXRhXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFRva2VuLnByb3RvdHlwZS5hdHRyU2V0ID0gZnVuY3Rpb24gYXR0clNldChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCBhdHRyRGF0YSA9IFtuYW1lLCB2YWx1ZV07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICB0aGlzLmF0dHJQdXNoKGF0dHJEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cnNbaWR4XSA9IGF0dHJEYXRhO1xuICAgICAgfVxuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSwgdmFsdWUgPSBudWxsO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgVG9rZW4ucHJvdG90eXBlLmF0dHJKb2luID0gZnVuY3Rpb24gYXR0ckpvaW4obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKTtcbiAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgIHRoaXMuYXR0clB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJzW2lkeF1bMV0gPSB0aGlzLmF0dHJzW2lkeF1bMV0gKyBcIiBcIiArIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzXG52YXIgcmVxdWlyZV9zdGF0ZV9jb3JlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3N0YXRlX2NvcmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgVG9rZW4gPSByZXF1aXJlX3Rva2VuKCk7XG4gICAgZnVuY3Rpb24gU3RhdGVDb3JlKHNyYywgbWQsIGVudikge1xuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICB0aGlzLmVudiA9IGVudjtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubWQgPSBtZDtcbiAgICB9XG4gICAgU3RhdGVDb3JlLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuICAgIG1vZHVsZS5leHBvcnRzID0gU3RhdGVDb3JlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qc1xudmFyIHJlcXVpcmVfcGFyc2VyX2NvcmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3BhcnNlcl9jb3JlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFJ1bGVyID0gcmVxdWlyZV9ydWxlcigpO1xuICAgIHZhciBfcnVsZXMgPSBbXG4gICAgICBbXCJub3JtYWxpemVcIiwgcmVxdWlyZV9ub3JtYWxpemUoKV0sXG4gICAgICBbXCJibG9ja1wiLCByZXF1aXJlX2Jsb2NrKCldLFxuICAgICAgW1wiaW5saW5lXCIsIHJlcXVpcmVfaW5saW5lKCldLFxuICAgICAgW1wibGlua2lmeVwiLCByZXF1aXJlX2xpbmtpZnkoKV0sXG4gICAgICBbXCJyZXBsYWNlbWVudHNcIiwgcmVxdWlyZV9yZXBsYWNlbWVudHMoKV0sXG4gICAgICBbXCJzbWFydHF1b3Rlc1wiLCByZXF1aXJlX3NtYXJ0cXVvdGVzKCldXG4gICAgXTtcbiAgICBmdW5jdGlvbiBDb3JlKCkge1xuICAgICAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICB2YXIgaSwgbCwgcnVsZXM7XG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIik7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZV9zdGF0ZV9jb3JlKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qc1xudmFyIHJlcXVpcmVfdGFibGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzU3BhY2UgPSByZXF1aXJlX3V0aWxzKCkuaXNTcGFjZTtcbiAgICBmdW5jdGlvbiBnZXRMaW5lMihzdGF0ZSwgbGluZSkge1xuICAgICAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLnRTaGlmdFtsaW5lXSwgbWF4MiA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcbiAgICAgIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4MiAtIHBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgcG9zID0gMCwgbWF4MiA9IHN0ci5sZW5ndGgsIGNoLCBpc0VzY2FwZWQgPSBmYWxzZSwgbGFzdFBvcyA9IDAsIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgaWYgKGNoID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAoIWlzRXNjYXBlZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCArIHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb3MgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ICs9IHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zIC0gMSk7XG4gICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc0VzY2FwZWQgPSBjaCA9PT0gOTI7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChjdXJyZW50ICsgc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlMyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbCwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbiwgYWxpZ25zLCB0LCB0YWJsZUxpbmVzLCB0Ym9keUxpbmVzLCBvbGRQYXJlbnRUeXBlLCB0ZXJtaW5hdGUsIHRlcm1pbmF0b3JSdWxlcywgZmlyc3RDaCwgc2Vjb25kQ2g7XG4gICAgICBpZiAoc3RhcnRMaW5lICsgMiA+IGVuZExpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgaWYgKHBvcyA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZpcnN0Q2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAoZmlyc3RDaCAhPT0gMTI0ICYmIGZpcnN0Q2ggIT09IDQ1ICYmIGZpcnN0Q2ggIT09IDU4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzZWNvbmRDaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgIGlmIChzZWNvbmRDaCAhPT0gMTI0ICYmIHNlY29uZENoICE9PSA0NSAmJiBzZWNvbmRDaCAhPT0gNTggJiYgIWlzU3BhY2Uoc2Vjb25kQ2gpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdENoID09PSA0NSAmJiBpc1NwYWNlKHNlY29uZENoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zIDwgc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjaCAhPT0gMTI0ICYmIGNoICE9PSA0NSAmJiBjaCAhPT0gNTggJiYgIWlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgbGluZVRleHQgPSBnZXRMaW5lMihzdGF0ZSwgc3RhcnRMaW5lICsgMSk7XG4gICAgICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoXCJ8XCIpO1xuICAgICAgYWxpZ25zID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXjo/LSs6PyQvLnRlc3QodCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSA1OCkge1xuICAgICAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gNTggPyBcImNlbnRlclwiIDogXCJyaWdodFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDU4KSB7XG4gICAgICAgICAgYWxpZ25zLnB1c2goXCJsZWZ0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsaWducy5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lVGV4dCA9IGdldExpbmUyKHN0YXRlLCBzdGFydExpbmUpLnRyaW0oKTtcbiAgICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKFwifFwiKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0KTtcbiAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zWzBdID09PSBcIlwiKVxuICAgICAgICBjb2x1bW5zLnNoaWZ0KCk7XG4gICAgICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdID09PSBcIlwiKVxuICAgICAgICBjb2x1bW5zLnBvcCgpO1xuICAgICAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcbiAgICAgIGlmIChjb2x1bW5Db3VudCA9PT0gMCB8fCBjb2x1bW5Db3VudCAhPT0gYWxpZ25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gXCJ0YWJsZVwiO1xuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJibG9ja3F1b3RlXCIpO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGFibGVfb3BlblwiLCBcInRhYmxlXCIsIDEpO1xuICAgICAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFtzdGFydExpbmUsIDBdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGhlYWRfb3BlblwiLCBcInRoZWFkXCIsIDEpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhcnRMaW5lICsgMV07XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0cl9vcGVuXCIsIFwidHJcIiwgMSk7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRoX29wZW5cIiwgXCJ0aFwiLCAxKTtcbiAgICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICAgIHRva2VuLmF0dHJzID0gW1tcInN0eWxlXCIsIFwidGV4dC1hbGlnbjpcIiArIGFsaWduc1tpXV1dO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImlubGluZVwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0aF9jbG9zZVwiLCBcInRoXCIsIC0xKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRyX2Nsb3NlXCIsIFwidHJcIiwgLTEpO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGhlYWRfY2xvc2VcIiwgXCJ0aGVhZFwiLCAtMSk7XG4gICAgICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMjsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsaW5lVGV4dCA9IGdldExpbmUyKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgICAgICBpZiAoIWxpbmVUZXh0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zWzBdID09PSBcIlwiKVxuICAgICAgICAgIGNvbHVtbnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSA9PT0gXCJcIilcbiAgICAgICAgICBjb2x1bW5zLnBvcCgpO1xuICAgICAgICBpZiAobmV4dExpbmUgPT09IHN0YXJ0TGluZSArIDIpIHtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0Ym9keV9vcGVuXCIsIFwidGJvZHlcIiwgMSk7XG4gICAgICAgICAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFtzdGFydExpbmUgKyAyLCAwXTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0cl9vcGVuXCIsIFwidHJcIiwgMSk7XG4gICAgICAgIHRva2VuLm1hcCA9IFtuZXh0TGluZSwgbmV4dExpbmUgKyAxXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0ZF9vcGVuXCIsIFwidGRcIiwgMSk7XG4gICAgICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICAgICAgdG9rZW4uYXR0cnMgPSBbW1wic3R5bGVcIiwgXCJ0ZXh0LWFsaWduOlwiICsgYWxpZ25zW2ldXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImlubGluZVwiLCBcIlwiLCAwKTtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogXCJcIjtcbiAgICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRkX2Nsb3NlXCIsIFwidGRcIiwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRyX2Nsb3NlXCIsIFwidHJcIiwgLTEpO1xuICAgICAgfVxuICAgICAgaWYgKHRib2R5TGluZXMpIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGJvZHlfY2xvc2VcIiwgXCJ0Ym9keVwiLCAtMSk7XG4gICAgICAgIHRib2R5TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRhYmxlX2Nsb3NlXCIsIFwidGFibGVcIiwgLTEpO1xuICAgICAgdGFibGVMaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzXG52YXIgcmVxdWlyZV9jb2RlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2RlMihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICBpZiAoc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPCA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gICAgICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgICAgIGlmIChzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKSkge1xuICAgICAgICAgIG5leHRMaW5lKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICAgIG5leHRMaW5lKys7XG4gICAgICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGluZSA9IGxhc3Q7XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJjb2RlX2Jsb2NrXCIsIFwiY29kZVwiLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIGxhc3QsIDQgKyBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKSArIFwiXFxuXCI7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2ZlbmNlLmpzXG52YXIgcmVxdWlyZV9mZW5jZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlMyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgICAgIHZhciBtYXJrZXIsIGxlbiwgcGFyYW1zLCBuZXh0TGluZSwgbWVtLCB0b2tlbiwgbWFya3VwLCBoYXZlRW5kTWFya2VyID0gZmFsc2UsIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyArIDMgPiBtYXgyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAobWFya2VyICE9PSAxMjYgJiYgbWFya2VyICE9PSA5Nikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtZW0gPSBwb3M7XG4gICAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpO1xuICAgICAgbGVuID0gcG9zIC0gbWVtO1xuICAgICAgaWYgKGxlbiA8IDMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgICAgIHBhcmFtcyA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heDIpO1xuICAgICAgaWYgKG1hcmtlciA9PT0gOTYpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIG5leHRMaW5lKys7XG4gICAgICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICAgIG1heDIgPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IG1hcmtlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG4gICAgICAgIGlmIChwb3MgPCBtYXgyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG4gICAgICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImZlbmNlXCIsIFwiY29kZVwiLCAwKTtcbiAgICAgIHRva2VuLmluZm8gPSBwYXJhbXM7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBtYXJrdXA7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanNcbnZhciByZXF1aXJlX2Jsb2NrcXVvdGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2txdW90ZTIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgYWRqdXN0VGFiLCBjaCwgaSwgaW5pdGlhbCwgbCwgbGFzdExpbmVFbXB0eSwgbGluZXMsIG5leHRMaW5lLCBvZmZzZXQsIG9sZEJNYXJrcywgb2xkQlNDb3VudCwgb2xkSW5kZW50LCBvbGRQYXJlbnRUeXBlLCBvbGRTQ291bnQsIG9sZFRTaGlmdCwgc3BhY2VBZnRlck1hcmtlciwgdGVybWluYXRlLCB0ZXJtaW5hdG9yUnVsZXMsIHRva2VuLCBpc091dGRlbnRlZCwgb2xkTGluZU1heCA9IHN0YXRlLmxpbmVNYXgsIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gNjIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDE7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMzIpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gOSkge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgaWYgKChzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGluaXRpYWwrKztcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvbGRCTWFya3MgPSBbc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV1dO1xuICAgICAgc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gPSBwb3M7XG4gICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICBvbGRCU0NvdW50ID0gW3N0YXRlLmJzQ291bnRbc3RhcnRMaW5lXV07XG4gICAgICBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcbiAgICAgIGxhc3RMaW5lRW1wdHkgPSBwb3MgPj0gbWF4MjtcbiAgICAgIG9sZFNDb3VudCA9IFtzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXV07XG4gICAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG4gICAgICBvbGRUU2hpZnQgPSBbc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV1dO1xuICAgICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwiYmxvY2txdW90ZVwiKTtcbiAgICAgIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IFwiYmxvY2txdW90ZVwiO1xuICAgICAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgICAgICBpc091dGRlbnRlZCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gNjIgJiYgIWlzT3V0ZGVudGVkKSB7XG4gICAgICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxO1xuICAgICAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAzMikge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA5KSB7XG4gICAgICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG4gICAgICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSArIChhZGp1c3RUYWIgPyAxIDogMCkpICUgNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXgyO1xuICAgICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgICAgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMSArIChzcGFjZUFmdGVyTWFya2VyID8gMSA6IDApO1xuICAgICAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBwb3MgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0TGluZUVtcHR5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG4gICAgICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gLTE7XG4gICAgICB9XG4gICAgICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICBzdGF0ZS5ibGtJbmRlbnQgPSAwO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiYmxvY2txdW90ZV9vcGVuXCIsIFwiYmxvY2txdW90ZVwiLCAxKTtcbiAgICAgIHRva2VuLm1hcmt1cCA9IFwiPlwiO1xuICAgICAgdG9rZW4ubWFwID0gbGluZXMgPSBbc3RhcnRMaW5lLCAwXTtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImJsb2NrcXVvdGVfY2xvc2VcIiwgXCJibG9ja3F1b3RlXCIsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCA9IFwiPlwiO1xuICAgICAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgIGxpbmVzWzFdID0gc3RhdGUubGluZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGRUU2hpZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgICAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gICAgICAgIHN0YXRlLnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZFNDb3VudFtpXTtcbiAgICAgICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gICAgICB9XG4gICAgICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5qc1xudmFyIHJlcXVpcmVfaHIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzU3BhY2UgPSByZXF1aXJlX3V0aWxzKCkuaXNTcGFjZTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhyMihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgICAgIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLCBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgIGlmIChtYXJrZXIgIT09IDQyICYmIG1hcmtlciAhPT0gNDUgJiYgbWFya2VyICE9PSA5NSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjbnQgPSAxO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09IG1hcmtlcikge1xuICAgICAgICAgIGNudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY250IDwgMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJoclwiLCBcImhyXCIsIDApO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzXG52YXIgcmVxdWlyZV9saXN0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGlzU3BhY2UgPSByZXF1aXJlX3V0aWxzKCkuaXNTcGFjZTtcbiAgICBmdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gICAgICB2YXIgbWFya2VyLCBwb3MsIG1heDIsIGNoO1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICAgIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgIGlmIChtYXJrZXIgIT09IDQyICYmIG1hcmtlciAhPT0gNDUgJiYgbWFya2VyICE9PSA0Mykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgbWF4Mikge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gICAgICB2YXIgY2gsIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSwgcG9zID0gc3RhcnQsIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIGlmIChwb3MgKyAxID49IG1heDIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAoY2ggPCA0OCB8fCBjaCA+IDU3KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBpZiAocG9zID49IG1heDIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1Nykge1xuICAgICAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09IDQxIHx8IGNoID09PSA0Nikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgaWR4KSB7XG4gICAgICB2YXIgaSwgbCwgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDI7XG4gICAgICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09IFwicGFyYWdyYXBoX29wZW5cIikge1xuICAgICAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0MihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgY29udGVudFN0YXJ0LCBpLCBpbmRlbnQsIGluZGVudEFmdGVyTWFya2VyLCBpbml0aWFsLCBpc09yZGVyZWQsIGl0ZW1MaW5lcywgbCwgbGlzdExpbmVzLCBsaXN0VG9rSWR4LCBtYXJrZXJDaGFyQ29kZSwgbWFya2VyVmFsdWUsIG1heDIsIG5leHRMaW5lLCBvZmZzZXQsIG9sZExpc3RJbmRlbnQsIG9sZFBhcmVudFR5cGUsIG9sZFNDb3VudCwgb2xkVFNoaWZ0LCBvbGRUaWdodCwgcG9zLCBwb3NBZnRlck1hcmtlciwgcHJldkVtcHR5RW5kLCBzdGFydCwgdGVybWluYXRlLCB0ZXJtaW5hdG9yUnVsZXMsIHRva2VuLCBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsIHRpZ2h0ID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUubGlzdEluZGVudCA+PSAwICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUubGlzdEluZGVudCA+PSA0ICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gXCJwYXJhZ3JhcGhcIikge1xuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICAgICAgaXNPcmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICAgICAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSkpO1xuICAgICAgICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCAmJiBtYXJrZXJWYWx1ZSAhPT0gMSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgICAgIGlzT3JkZXJlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGgpIHtcbiAgICAgICAgaWYgKHN0YXRlLnNraXBTcGFjZXMocG9zQWZ0ZXJNYXJrZXIpID49IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcbiAgICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwib3JkZXJlZF9saXN0X29wZW5cIiwgXCJvbFwiLCAxKTtcbiAgICAgICAgaWYgKG1hcmtlclZhbHVlICE9PSAxKSB7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgPSBbW1wic3RhcnRcIiwgbWFya2VyVmFsdWVdXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiYnVsbGV0X2xpc3Rfb3BlblwiLCBcInVsXCIsIDEpO1xuICAgICAgfVxuICAgICAgdG9rZW4ubWFwID0gbGlzdExpbmVzID0gW3N0YXJ0TGluZSwgMF07XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICAgICAgcHJldkVtcHR5RW5kID0gZmFsc2U7XG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcyhcImxpc3RcIik7XG4gICAgICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBcImxpc3RcIjtcbiAgICAgIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICAgICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgICAgIG1heDIgPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIHBvc0FmdGVyTWFya2VyIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoY2ggPT09IDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMzIpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFN0YXJ0ID0gcG9zO1xuICAgICAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heDIpIHtcbiAgICAgICAgICBpbmRlbnRBZnRlck1hcmtlciA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIGluZGVudEFmdGVyTWFya2VyID4gNCkge1xuICAgICAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImxpc3RfaXRlbV9vcGVuXCIsIFwibGlcIiwgMSk7XG4gICAgICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuICAgICAgICB0b2tlbi5tYXAgPSBpdGVtTGluZXMgPSBbc3RhcnRMaW5lLCAwXTtcbiAgICAgICAgaWYgKGlzT3JkZXJlZCkge1xuICAgICAgICAgIHRva2VuLmluZm8gPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgb2xkVGlnaHQgPSBzdGF0ZS50aWdodDtcbiAgICAgICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgICAgIG9sZFNDb3VudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgICAgICBvbGRMaXN0SW5kZW50ID0gc3RhdGUubGlzdEluZGVudDtcbiAgICAgICAgc3RhdGUubGlzdEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgICAgICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuICAgICAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2Zmc2V0O1xuICAgICAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heDIgJiYgc3RhdGUuaXNFbXB0eShzdGFydExpbmUgKyAxKSkge1xuICAgICAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgICAgICB0aWdodCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByZXZFbXB0eUVuZCA9IHN0YXRlLmxpbmUgLSBzdGFydExpbmUgPiAxICYmIHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpO1xuICAgICAgICBzdGF0ZS5ibGtJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50O1xuICAgICAgICBzdGF0ZS5saXN0SW5kZW50ID0gb2xkTGlzdEluZGVudDtcbiAgICAgICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBvbGRUU2hpZnQ7XG4gICAgICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2xkU0NvdW50O1xuICAgICAgICBzdGF0ZS50aWdodCA9IG9sZFRpZ2h0O1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJsaXN0X2l0ZW1fY2xvc2VcIiwgXCJsaVwiLCAtMSk7XG4gICAgICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuICAgICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgICAgIGl0ZW1MaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgICAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwib3JkZXJlZF9saXN0X2Nsb3NlXCIsIFwib2xcIiwgLTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiYnVsbGV0X2xpc3RfY2xvc2VcIiwgXCJ1bFwiLCAtMSk7XG4gICAgICB9XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICAgIGxpc3RMaW5lc1sxXSA9IG5leHRMaW5lO1xuICAgICAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gICAgICBpZiAodGlnaHQpIHtcbiAgICAgICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9yZWZlcmVuY2UuanNcbnZhciByZXF1aXJlX3JlZmVyZW5jZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSA9IHJlcXVpcmVfdXRpbHMoKS5ub3JtYWxpemVSZWZlcmVuY2U7XG4gICAgdmFyIGlzU3BhY2UgPSByZXF1aXJlX3V0aWxzKCkuaXNTcGFjZTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIGRlc3RFbmRQb3MsIGRlc3RFbmRMaW5lTm8sIGVuZExpbmUsIGhyZWYsIGksIGwsIGxhYmVsLCBsYWJlbEVuZCwgb2xkUGFyZW50VHlwZSwgcmVzLCBzdGFydCwgc3RyLCB0ZXJtaW5hdGUsIHRlcm1pbmF0b3JSdWxlcywgdGl0bGUsIGxpbmVzID0gMCwgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSwgbWF4MiA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdLCBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSA5MSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytwb3MgPCBtYXgyKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA5MyAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gOTIpIHtcbiAgICAgICAgICBpZiAocG9zICsgMSA9PT0gbWF4Mikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSkgIT09IDU4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwicmVmZXJlbmNlXCIpO1xuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gXCJyZWZlcmVuY2VcIjtcbiAgICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICAgICAgbWF4MiA9IHN0ci5sZW5ndGg7XG4gICAgICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNoID09PSA5MSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTMpIHtcbiAgICAgICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICBsaW5lcysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChwb3MgPCBtYXgyICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDEwKSB7XG4gICAgICAgICAgICBsaW5lcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSA1OCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT09IDEwKSB7XG4gICAgICAgICAgbGluZXMrKztcbiAgICAgICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgyKTtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIGxpbmVzICs9IHJlcy5saW5lcztcbiAgICAgIGRlc3RFbmRQb3MgPSBwb3M7XG4gICAgICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG4gICAgICBzdGFydCA9IHBvcztcbiAgICAgIGZvciAoOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICBsaW5lcysrO1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heDIpO1xuICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgICBsaW5lcyArPSByZXMubGluZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZSA9IFwiXCI7XG4gICAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMTApIHtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgdGl0bGUgPSBcIlwiO1xuICAgICAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICAgICAgbGluZXMgPSBkZXN0RW5kTGluZU5vO1xuICAgICAgICAgIHdoaWxlIChwb3MgPCBtYXgyKSB7XG4gICAgICAgICAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAxMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgICAgIGlmICghbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGUsIGhyZWYgfTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIGxpbmVzICsgMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qc1xudmFyIHJlcXVpcmVfaHRtbF9ibG9ja3MgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gW1xuICAgICAgXCJhZGRyZXNzXCIsXG4gICAgICBcImFydGljbGVcIixcbiAgICAgIFwiYXNpZGVcIixcbiAgICAgIFwiYmFzZVwiLFxuICAgICAgXCJiYXNlZm9udFwiLFxuICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICBcImJvZHlcIixcbiAgICAgIFwiY2FwdGlvblwiLFxuICAgICAgXCJjZW50ZXJcIixcbiAgICAgIFwiY29sXCIsXG4gICAgICBcImNvbGdyb3VwXCIsXG4gICAgICBcImRkXCIsXG4gICAgICBcImRldGFpbHNcIixcbiAgICAgIFwiZGlhbG9nXCIsXG4gICAgICBcImRpclwiLFxuICAgICAgXCJkaXZcIixcbiAgICAgIFwiZGxcIixcbiAgICAgIFwiZHRcIixcbiAgICAgIFwiZmllbGRzZXRcIixcbiAgICAgIFwiZmlnY2FwdGlvblwiLFxuICAgICAgXCJmaWd1cmVcIixcbiAgICAgIFwiZm9vdGVyXCIsXG4gICAgICBcImZvcm1cIixcbiAgICAgIFwiZnJhbWVcIixcbiAgICAgIFwiZnJhbWVzZXRcIixcbiAgICAgIFwiaDFcIixcbiAgICAgIFwiaDJcIixcbiAgICAgIFwiaDNcIixcbiAgICAgIFwiaDRcIixcbiAgICAgIFwiaDVcIixcbiAgICAgIFwiaDZcIixcbiAgICAgIFwiaGVhZFwiLFxuICAgICAgXCJoZWFkZXJcIixcbiAgICAgIFwiaHJcIixcbiAgICAgIFwiaHRtbFwiLFxuICAgICAgXCJpZnJhbWVcIixcbiAgICAgIFwibGVnZW5kXCIsXG4gICAgICBcImxpXCIsXG4gICAgICBcImxpbmtcIixcbiAgICAgIFwibWFpblwiLFxuICAgICAgXCJtZW51XCIsXG4gICAgICBcIm1lbnVpdGVtXCIsXG4gICAgICBcIm5hdlwiLFxuICAgICAgXCJub2ZyYW1lc1wiLFxuICAgICAgXCJvbFwiLFxuICAgICAgXCJvcHRncm91cFwiLFxuICAgICAgXCJvcHRpb25cIixcbiAgICAgIFwicFwiLFxuICAgICAgXCJwYXJhbVwiLFxuICAgICAgXCJzZWN0aW9uXCIsXG4gICAgICBcInNvdXJjZVwiLFxuICAgICAgXCJzdW1tYXJ5XCIsXG4gICAgICBcInRhYmxlXCIsXG4gICAgICBcInRib2R5XCIsXG4gICAgICBcInRkXCIsXG4gICAgICBcInRmb290XCIsXG4gICAgICBcInRoXCIsXG4gICAgICBcInRoZWFkXCIsXG4gICAgICBcInRpdGxlXCIsXG4gICAgICBcInRyXCIsXG4gICAgICBcInRyYWNrXCIsXG4gICAgICBcInVsXCJcbiAgICBdO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qc1xudmFyIHJlcXVpcmVfaHRtbF9yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYXR0cl9uYW1lID0gXCJbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKlwiO1xuICAgIHZhciB1bnF1b3RlZCA9IFwiW15cXFwiJz08PmBcXFxceDAwLVxcXFx4MjBdK1wiO1xuICAgIHZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG4gICAgdmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG4gICAgdmFyIGF0dHJfdmFsdWUgPSBcIig/OlwiICsgdW5xdW90ZWQgKyBcInxcIiArIHNpbmdsZV9xdW90ZWQgKyBcInxcIiArIGRvdWJsZV9xdW90ZWQgKyBcIilcIjtcbiAgICB2YXIgYXR0cmlidXRlID0gXCIoPzpcXFxccytcIiArIGF0dHJfbmFtZSArIFwiKD86XFxcXHMqPVxcXFxzKlwiICsgYXR0cl92YWx1ZSArIFwiKT8pXCI7XG4gICAgdmFyIG9wZW5fdGFnID0gXCI8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlwiICsgYXR0cmlidXRlICsgXCIqXFxcXHMqXFxcXC8/PlwiO1xuICAgIHZhciBjbG9zZV90YWcgPSBcIjxcXFxcL1tBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcXFxccyo+XCI7XG4gICAgdmFyIGNvbW1lbnQgPSBcIjwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT5cIjtcbiAgICB2YXIgcHJvY2Vzc2luZyA9IFwiPFs/XVtcXFxcc1xcXFxTXSo/Wz9dPlwiO1xuICAgIHZhciBkZWNsYXJhdGlvbiA9IFwiPCFbQS1aXStcXFxccytbXj5dKj5cIjtcbiAgICB2YXIgY2RhdGEgPSBcIjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPlwiO1xuICAgIHZhciBIVE1MX1RBR19SRSA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBvcGVuX3RhZyArIFwifFwiICsgY2xvc2VfdGFnICsgXCJ8XCIgKyBjb21tZW50ICsgXCJ8XCIgKyBwcm9jZXNzaW5nICsgXCJ8XCIgKyBkZWNsYXJhdGlvbiArIFwifFwiICsgY2RhdGEgKyBcIilcIik7XG4gICAgdmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBuZXcgUmVnRXhwKFwiXig/OlwiICsgb3Blbl90YWcgKyBcInxcIiArIGNsb3NlX3RhZyArIFwiKVwiKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xuICAgIG1vZHVsZS5leHBvcnRzLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzXG52YXIgcmVxdWlyZV9odG1sX2Jsb2NrID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZV9odG1sX2Jsb2NrcygpO1xuICAgIHZhciBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFID0gcmVxdWlyZV9odG1sX3JlKCkuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcbiAgICB2YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gICAgICBbL148KHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKT4vaSwgdHJ1ZV0sXG4gICAgICBbL148IS0tLywgLy0tPi8sIHRydWVdLFxuICAgICAgWy9ePFxcPy8sIC9cXD8+LywgdHJ1ZV0sXG4gICAgICBbL148IVtBLVpdLywgLz4vLCB0cnVlXSxcbiAgICAgIFsvXjwhXFxbQ0RBVEFcXFsvLCAvXFxdXFxdPi8sIHRydWVdLFxuICAgICAgW25ldyBSZWdFeHAoXCJePC8/KFwiICsgYmxvY2tfbmFtZXMuam9pbihcInxcIikgKyBcIikoPz0oXFxcXHN8Lz8+fCQpKVwiLCBcImlcIiksIC9eJC8sIHRydWVdLFxuICAgICAgW25ldyBSZWdFeHAoSFRNTF9PUEVOX0NMT1NFX1RBR19SRS5zb3VyY2UgKyBcIlxcXFxzKiRcIiksIC9eJC8sIGZhbHNlXVxuICAgIF07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICAgICAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sIG1heDIgPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcbiAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDYwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4Mik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzBdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gICAgICB9XG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG4gICAgICBpZiAoIUhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgICAgIG1heDIgPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuICAgICAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4Mik7XG4gICAgICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG5leHRMaW5lKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImh0bWxfYmxvY2tcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBuZXh0TGluZV07XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanNcbnZhciByZXF1aXJlX2hlYWRpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZzIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIGxldmVsLCB0bXAsIHRva2VuLCBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLCBtYXgyID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuYWxsb3dJbmRlbnRhdGlvbiAmJiBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjaCAhPT0gMzUgfHwgcG9zID49IG1heDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbGV2ZWwgPSAxO1xuICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gICAgICB3aGlsZSAoY2ggPT09IDM1ICYmIHBvcyA8IG1heDIgJiYgbGV2ZWwgPD0gNikge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA+IDYgfHwgcG9zIDwgbWF4MiAmJiAhaXNTcGFjZShjaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG1heDIgPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgyLCBwb3MpO1xuICAgICAgdG1wID0gc3RhdGUuc2tpcENoYXJzQmFjayhtYXgyLCAzNSwgcG9zKTtcbiAgICAgIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICAgICAgbWF4MiA9IHRtcDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19vcGVuXCIsIFwiaFwiICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBcIiMjIyMjIyMjXCIuc2xpY2UoMCwgbGV2ZWwpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJpbmxpbmVcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4MikudHJpbSgpO1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV07XG4gICAgICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19jbG9zZVwiLCBcImhcIiArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCA9IFwiIyMjIyMjIyNcIi5zbGljZSgwLCBsZXZlbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saGVhZGluZy5qc1xudmFyIHJlcXVpcmVfbGhlYWRpbmcgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgyLCBsZXZlbCwgbWFya2VyLCBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKFwicGFyYWdyYXBoXCIpO1xuICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBcInBhcmFncmFwaFwiO1xuICAgICAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmFsbG93SW5kZW50YXRpb24gJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA+PSBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgICAgICBtYXgyID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgICAgICBpZiAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDQ1IHx8IG1hcmtlciA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuICAgICAgICAgICAgICBpZiAocG9zID49IG1heDIpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IG1hcmtlciA9PT0gNjEgPyAxIDogMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWxldmVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gICAgICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaGVhZGluZ19vcGVuXCIsIFwiaFwiICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImlubGluZVwiLCBcIlwiLCAwKTtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgdG9rZW4ubWFwID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZSAtIDFdO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImhlYWRpbmdfY2xvc2VcIiwgXCJoXCIgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gICAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5qc1xudmFyIHJlcXVpcmVfcGFyYWdyYXBoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaDIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICAgICAgdmFyIGNvbnRlbnQsIHRlcm1pbmF0ZSwgaSwgbCwgdG9rZW4sIG9sZFBhcmVudFR5cGUsIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoXCJwYXJhZ3JhcGhcIiksIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuICAgICAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gICAgICBzdGF0ZS5wYXJlbnRUeXBlID0gXCJwYXJhZ3JhcGhcIjtcbiAgICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgICAgIGlmICghc3RhdGUubWQub3B0aW9ucy5hbGxvd0luZGVudGF0aW9uICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcbiAgICAgIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInBhcmFncmFwaF9vcGVuXCIsIFwicFwiLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdO1xuICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaW5saW5lXCIsIFwiXCIsIDApO1xuICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXTtcbiAgICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJwYXJhZ3JhcGhfY2xvc2VcIiwgXCJwXCIsIC0xKTtcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanNcbnZhciByZXF1aXJlX3N0YXRlX2Jsb2NrID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBUb2tlbiA9IHJlcXVpcmVfdG9rZW4oKTtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIGZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcbiAgICAgIHZhciBjaCwgczIsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcbiAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgdGhpcy5tZCA9IG1kO1xuICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIHRoaXMuYk1hcmtzID0gW107XG4gICAgICB0aGlzLmVNYXJrcyA9IFtdO1xuICAgICAgdGhpcy50U2hpZnQgPSBbXTtcbiAgICAgIHRoaXMuc0NvdW50ID0gW107XG4gICAgICB0aGlzLmJzQ291bnQgPSBbXTtcbiAgICAgIHRoaXMuYmxrSW5kZW50ID0gMDtcbiAgICAgIHRoaXMubGluZSA9IDA7XG4gICAgICB0aGlzLmxpbmVNYXggPSAwO1xuICAgICAgdGhpcy50aWdodCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZEluZGVudCA9IC0xO1xuICAgICAgdGhpcy5saXN0SW5kZW50ID0gLTE7XG4gICAgICB0aGlzLnBhcmVudFR5cGUgPSBcInJvb3RcIjtcbiAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgdGhpcy5yZXN1bHQgPSBcIlwiO1xuICAgICAgczIgPSB0aGlzLnNyYztcbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMyLmxlbmd0aDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgICAgICBjaCA9IHMyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGVudF9mb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gMTAgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgaWYgKGNoICE9PSAxMCkge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKTtcbiAgICAgICAgICB0aGlzLnRTaGlmdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApO1xuICAgICAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goczIubGVuZ3RoKTtcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2goczIubGVuZ3RoKTtcbiAgICAgIHRoaXMudFNoaWZ0LnB1c2goMCk7XG4gICAgICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG4gICAgICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gICAgICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgICAgIHRva2VuLmJsb2NrID0gdHJ1ZTtcbiAgICAgIGlmIChuZXN0aW5nIDwgMClcbiAgICAgICAgdGhpcy5sZXZlbC0tO1xuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgaWYgKG5lc3RpbmcgPiAwKVxuICAgICAgICB0aGlzLmxldmVsKys7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmJNYXJrc1tsaW5lXSArIHRoaXMudFNoaWZ0W2xpbmVdID49IHRoaXMuZU1hcmtzW2xpbmVdO1xuICAgIH07XG4gICAgU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyhmcm9tKSB7XG4gICAgICBmb3IgKHZhciBtYXgyID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4MjsgZnJvbSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb207XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyhwb3MpIHtcbiAgICAgIHZhciBjaDtcbiAgICAgIGZvciAodmFyIG1heDIgPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrKHBvcywgbWluKSB7XG4gICAgICBpZiAocG9zIDw9IG1pbikge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgICAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBTdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlMikge1xuICAgICAgZm9yICh2YXIgbWF4MiA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZTIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZTIsIG1pbikge1xuICAgICAgaWYgKHBvcyA8PSBtaW4pIHtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICAgICAgaWYgKGNvZGUyICE9PSB0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkge1xuICAgICAgICAgIHJldHVybiBwb3MgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgICAgIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsIGxpbmUgPSBiZWdpbjtcbiAgICAgIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBxdWV1ZSA9IG5ldyBBcnJheShlbmQgLSBiZWdpbik7XG4gICAgICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgICAgICBsaW5lSW5kZW50ID0gMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXTtcbiAgICAgICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuICAgICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSA5KSB7XG4gICAgICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJzdCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAgICAgcXVldWVbaV0gPSBuZXcgQXJyYXkobGluZUluZGVudCAtIGluZGVudCArIDEpLmpvaW4oXCIgXCIpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVldWUuam9pbihcIlwiKTtcbiAgICB9O1xuICAgIFN0YXRlQmxvY2sucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2suanNcbnZhciByZXF1aXJlX3BhcnNlcl9ibG9jayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIFJ1bGVyID0gcmVxdWlyZV9ydWxlcigpO1xuICAgIHZhciBfcnVsZXMgPSBbXG4gICAgICBbXCJ0YWJsZVwiLCByZXF1aXJlX3RhYmxlKCksIFtcInBhcmFncmFwaFwiLCBcInJlZmVyZW5jZVwiXV0sXG4gICAgICBbXCJjb2RlXCIsIHJlcXVpcmVfY29kZSgpXSxcbiAgICAgIFtcImZlbmNlXCIsIHJlcXVpcmVfZmVuY2UoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiLCBcImxpc3RcIl1dLFxuICAgICAgW1wiYmxvY2txdW90ZVwiLCByZXF1aXJlX2Jsb2NrcXVvdGUoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiLCBcImxpc3RcIl1dLFxuICAgICAgW1wiaHJcIiwgcmVxdWlyZV9ocigpLCBbXCJwYXJhZ3JhcGhcIiwgXCJyZWZlcmVuY2VcIiwgXCJibG9ja3F1b3RlXCIsIFwibGlzdFwiXV0sXG4gICAgICBbXCJsaXN0XCIsIHJlcXVpcmVfbGlzdCgpLCBbXCJwYXJhZ3JhcGhcIiwgXCJyZWZlcmVuY2VcIiwgXCJibG9ja3F1b3RlXCJdXSxcbiAgICAgIFtcInJlZmVyZW5jZVwiLCByZXF1aXJlX3JlZmVyZW5jZSgpXSxcbiAgICAgIFtcImh0bWxfYmxvY2tcIiwgcmVxdWlyZV9odG1sX2Jsb2NrKCksIFtcInBhcmFncmFwaFwiLCBcInJlZmVyZW5jZVwiLCBcImJsb2NrcXVvdGVcIl1dLFxuICAgICAgW1wiaGVhZGluZ1wiLCByZXF1aXJlX2hlYWRpbmcoKSwgW1wicGFyYWdyYXBoXCIsIFwicmVmZXJlbmNlXCIsIFwiYmxvY2txdW90ZVwiXV0sXG4gICAgICBbXCJsaGVhZGluZ1wiLCByZXF1aXJlX2xoZWFkaW5nKCldLFxuICAgICAgW1wicGFyYWdyYXBoXCIsIHJlcXVpcmVfcGFyYWdyYXBoKCldXG4gICAgXTtcbiAgICBmdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgICAgIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlckJsb2NrLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgICAgIHZhciBvaywgaSwgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpLCBsZW4gPSBydWxlcy5sZW5ndGgsIGxpbmUgPSBzdGFydExpbmUsIGhhc0VtcHR5TGluZXMgPSBmYWxzZSwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcbiAgICAgIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgICAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpO1xuICAgICAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG4gICAgICAgIGlmIChzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKSkge1xuICAgICAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICBzdGF0ZS5saW5lID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgICAgIHZhciBzdGF0ZTtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuICAgICAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG4gICAgfTtcbiAgICBQYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlX3N0YXRlX2Jsb2NrKCk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanNcbnZhciByZXF1aXJlX3RleHQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gaXNUZXJtaW5hdG9yQ2hhcihjaCkge1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDMzOlxuICAgICAgICBjYXNlIDM1OlxuICAgICAgICBjYXNlIDM2OlxuICAgICAgICBjYXNlIDM3OlxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDQyOlxuICAgICAgICBjYXNlIDQzOlxuICAgICAgICBjYXNlIDQ1OlxuICAgICAgICBjYXNlIDU4OlxuICAgICAgICBjYXNlIDYwOlxuICAgICAgICBjYXNlIDYxOlxuICAgICAgICBjYXNlIDYyOlxuICAgICAgICBjYXNlIDY0OlxuICAgICAgICBjYXNlIDkxOlxuICAgICAgICBjYXNlIDkyOlxuICAgICAgICBjYXNlIDkzOlxuICAgICAgICBjYXNlIDk0OlxuICAgICAgICBjYXNlIDk1OlxuICAgICAgICBjYXNlIDk2OlxuICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0MihzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgcG9zID0gc3RhdGUucG9zO1xuICAgICAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPT09IHN0YXRlLnBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcyk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5qc1xudmFyIHJlcXVpcmVfbmV3bGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgcG1heCwgbWF4Miwgd3MsIHBvcyA9IHN0YXRlLnBvcztcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAxMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxO1xuICAgICAgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIGlmIChwbWF4ID49IDAgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXgpID09PSAzMikge1xuICAgICAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHdzID0gcG1heCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAod3MgPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQod3MgLSAxKSA9PT0gMzIpXG4gICAgICAgICAgICAgIHdzLS07XG4gICAgICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCB3cyk7XG4gICAgICAgICAgICBzdGF0ZS5wdXNoKFwiaGFyZGJyZWFrXCIsIFwiYnJcIiwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHN0YXRlLnB1c2goXCJzb2Z0YnJlYWtcIiwgXCJiclwiLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHVzaChcInNvZnRicmVha1wiLCBcImJyXCIsIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzXG52YXIgcmVxdWlyZV9lc2NhcGUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIHZhciBFU0NBUEVEID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBFU0NBUEVELnB1c2goMCk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIFwiXFxcXCFcXFwiIyQlJicoKSorLC4vOjs8PT4/QFtdXl9ge3x9fi1cIi5zcGxpdChcIlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGNoKSB7XG4gICAgICBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTtcbiAgICB9KTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSA5Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3Bvc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyArPSAyO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgc3RhdGUucHVzaChcImhhcmRicmVha1wiLCBcImJyXCIsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB3aGlsZSAocG9zIDwgbWF4Mikge1xuICAgICAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5wb3MgPSBwb3M7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gXCJcXFxcXCI7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wb3MrKztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWNrdGlja3MuanNcbnZhciByZXF1aXJlX2JhY2t0aWNrcyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFja3RpY2soc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIHN0YXJ0LCBtYXgyLCBtYXJrZXIsIHRva2VuLCBtYXRjaFN0YXJ0LCBtYXRjaEVuZCwgb3BlbmVyTGVuZ3RoLCBjbG9zZXJMZW5ndGgsIHBvcyA9IHN0YXRlLnBvcywgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNoICE9PSA5Nikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHBvcztcbiAgICAgIHBvcysrO1xuICAgICAgbWF4MiA9IHN0YXRlLnBvc01heDtcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgyICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDk2KSB7XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICAgICAgb3BlbmVyTGVuZ3RoID0gbWFya2VyLmxlbmd0aDtcbiAgICAgIGlmIChzdGF0ZS5iYWNrdGlja3NTY2FubmVkICYmIChzdGF0ZS5iYWNrdGlja3Nbb3BlbmVyTGVuZ3RoXSB8fCAwKSA8PSBzdGFydCkge1xuICAgICAgICBpZiAoIXNpbGVudClcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgICAgICAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBtYXRjaFN0YXJ0ID0gbWF0Y2hFbmQgPSBwb3M7XG4gICAgICB3aGlsZSAoKG1hdGNoU3RhcnQgPSBzdGF0ZS5zcmMuaW5kZXhPZihcImBcIiwgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICAgICAgbWF0Y2hFbmQgPSBtYXRjaFN0YXJ0ICsgMTtcbiAgICAgICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDk2KSB7XG4gICAgICAgICAgbWF0Y2hFbmQrKztcbiAgICAgICAgfVxuICAgICAgICBjbG9zZXJMZW5ndGggPSBtYXRjaEVuZCAtIG1hdGNoU3RhcnQ7XG4gICAgICAgIGlmIChjbG9zZXJMZW5ndGggPT09IG9wZW5lckxlbmd0aCkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJjb2RlX2lubGluZVwiLCBcImNvZGVcIiwgMCk7XG4gICAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBtYXJrZXI7XG4gICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF0Y2hTdGFydCkucmVwbGFjZSgvXFxuL2csIFwiIFwiKS5yZXBsYWNlKC9eICguKykgJC8sIFwiJDFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2t0aWNrc1tjbG9zZXJMZW5ndGhdID0gbWF0Y2hTdGFydDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2t0aWNrc1NjYW5uZWQgPSB0cnVlO1xuICAgICAgaWYgKCFzaWxlbnQpXG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gbWFya2VyO1xuICAgICAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzXG52YXIgcmVxdWlyZV9zdHJpa2V0aHJvdWdoID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgaSwgc2Nhbm5lZCwgdG9rZW4sIGxlbiwgY2gsIHN0YXJ0ID0gc3RhdGUucG9zLCBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrZXIgIT09IDEyNikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIHRydWUpO1xuICAgICAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gJSAyKSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBjaDtcbiAgICAgICAgbGVuLS07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG4gICAgICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAgICAgbWFya2VyLFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgICB0b2tlbjogc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICBvcGVuOiBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgICAgIGNsb3NlOiBzY2FubmVkLmNhbl9jbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgICAgIHZhciBpLCBqLCBzdGFydERlbGltLCBlbmREZWxpbSwgdG9rZW4sIGxvbmVNYXJrZXJzID0gW10sIG1heDIgPSBkZWxpbWl0ZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXgyOyBpKyspIHtcbiAgICAgICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG4gICAgICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMTI2KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG4gICAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dO1xuICAgICAgICB0b2tlbi50eXBlID0gXCJzX29wZW5cIjtcbiAgICAgICAgdG9rZW4udGFnID0gXCJzXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAxO1xuICAgICAgICB0b2tlbi5tYXJrdXAgPSBcIn5+XCI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgICAgIHRva2VuLnR5cGUgPSBcInNfY2xvc2VcIjtcbiAgICAgICAgdG9rZW4udGFnID0gXCJzXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICAgICAgdG9rZW4ubWFya3VwID0gXCJ+flwiO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gXCJcIjtcbiAgICAgICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09IFwidGV4dFwiICYmIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09IFwiflwiKSB7XG4gICAgICAgICAgbG9uZU1hcmtlcnMucHVzaChlbmREZWxpbS50b2tlbiAtIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIGkgPSBsb25lTWFya2Vycy5wb3AoKTtcbiAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB3aGlsZSAoaiA8IHN0YXRlLnRva2Vucy5sZW5ndGggJiYgc3RhdGUudG9rZW5zW2pdLnR5cGUgPT09IFwic19jbG9zZVwiKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGotLTtcbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXTtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbal0gPSBzdGF0ZS50b2tlbnNbaV07XG4gICAgICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSwgbWF4MiA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcbiAgICAgIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcbiAgICAgIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanNcbnZhciByZXF1aXJlX2VtcGhhc2lzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgc3RhcnQgPSBzdGF0ZS5wb3MsIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KTtcbiAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG1hcmtlciAhPT0gOTUgJiYgbWFya2VyICE9PSA0Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gNDIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwidGV4dFwiLCBcIlwiLCAwKTtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcbiAgICAgICAgc3RhdGUuZGVsaW1pdGVycy5wdXNoKHtcbiAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcbiAgICAgICAgICB0b2tlbjogc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICBvcGVuOiBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgICAgIGNsb3NlOiBzY2FubmVkLmNhbl9jbG9zZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgICAgIHZhciBpLCBzdGFydERlbGltLCBlbmREZWxpbSwgdG9rZW4sIGNoLCBpc1N0cm9uZywgbWF4MiA9IGRlbGltaXRlcnMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gbWF4MiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuICAgICAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDk1ICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSA0Mikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuICAgICAgICBpc1N0cm9uZyA9IGkgPiAwICYmIGRlbGltaXRlcnNbaSAtIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgKyAxICYmIGRlbGltaXRlcnNbaSAtIDFdLm1hcmtlciA9PT0gc3RhcnREZWxpbS5tYXJrZXIgJiYgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmIGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmQgKyAxXS50b2tlbiA9PT0gZW5kRGVsaW0udG9rZW4gKyAxO1xuICAgICAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICAgICAgdG9rZW4udHlwZSA9IGlzU3Ryb25nID8gXCJzdHJvbmdfb3BlblwiIDogXCJlbV9vcGVuXCI7XG4gICAgICAgIHRva2VuLnRhZyA9IGlzU3Ryb25nID8gXCJzdHJvbmdcIiA6IFwiZW1cIjtcbiAgICAgICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgICAgIHRva2VuLm1hcmt1cCA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gXCJcIjtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dO1xuICAgICAgICB0b2tlbi50eXBlID0gaXNTdHJvbmcgPyBcInN0cm9uZ19jbG9zZVwiIDogXCJlbV9jbG9zZVwiO1xuICAgICAgICB0b2tlbi50YWcgPSBpc1N0cm9uZyA/IFwic3Ryb25nXCIgOiBcImVtXCI7XG4gICAgICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICAgICAgdG9rZW4ubWFya3VwID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICBpZiAoaXNTdHJvbmcpIHtcbiAgICAgICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tpIC0gMV0udG9rZW5dLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW5dLmNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSwgbWF4MiA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcbiAgICAgIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcbiAgICAgIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qc1xudmFyIHJlcXVpcmVfbGluayA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbm9ybWFsaXplUmVmZXJlbmNlID0gcmVxdWlyZV91dGlscygpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbiAgICB2YXIgaXNTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1NwYWNlO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluazIoc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIGF0dHJzLCBjb2RlMiwgbGFiZWwsIGxhYmVsRW5kLCBsYWJlbFN0YXJ0LCBwb3MsIHJlcywgcmVmLCB0b2tlbiwgaHJlZiA9IFwiXCIsIHRpdGxlID0gXCJcIiwgb2xkUG9zID0gc3RhdGUucG9zLCBtYXgyID0gc3RhdGUucG9zTWF4LCBzdGFydCA9IHN0YXRlLnBvcywgcGFyc2VSZWZlcmVuY2UgPSB0cnVlO1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcykgIT09IDkxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxhYmVsU3RhcnQgPSBzdGF0ZS5wb3MgKyAxO1xuICAgICAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpO1xuICAgICAgaWYgKGxhYmVsRW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICBwYXJzZVJlZmVyZW5jZSA9IGZhbHNlO1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGlmICghaXNTcGFjZShjb2RlMikgJiYgY29kZTIgIT09IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgIGZvciAoOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgICAgICAgaWYgKHBvcyA8IG1heDIgJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICAgICAgICBmb3IgKDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgICBpZiAoIWlzU3BhY2UoY29kZTIpICYmIGNvZGUyICE9PSAxMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gbWF4MiB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSA0MSkge1xuICAgICAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCBtYXgyICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDkxKSB7XG4gICAgICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhYmVsKSB7XG4gICAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgICAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnQ7XG4gICAgICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJsaW5rX29wZW5cIiwgXCJhXCIsIDEpO1xuICAgICAgICB0b2tlbi5hdHRycyA9IGF0dHJzID0gW1tcImhyZWZcIiwgaHJlZl1dO1xuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICBhdHRycy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubWQuaW5saW5lLnRva2VuaXplKHN0YXRlKTtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19jbG9zZVwiLCBcImFcIiwgLTEpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgc3RhdGUucG9zTWF4ID0gbWF4MjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qc1xudmFyIHJlcXVpcmVfaW1hZ2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub3JtYWxpemVSZWZlcmVuY2UgPSByZXF1aXJlX3V0aWxzKCkubm9ybWFsaXplUmVmZXJlbmNlO1xuICAgIHZhciBpc1NwYWNlID0gcmVxdWlyZV91dGlscygpLmlzU3BhY2U7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbWFnZTIoc3RhdGUsIHNpbGVudCkge1xuICAgICAgdmFyIGF0dHJzLCBjb2RlMiwgY29udGVudCwgbGFiZWwsIGxhYmVsRW5kLCBsYWJlbFN0YXJ0LCBwb3MsIHJlZiwgcmVzLCB0aXRsZSwgdG9rZW4sIHRva2Vucywgc3RhcnQsIGhyZWYgPSBcIlwiLCBvbGRQb3MgPSBzdGF0ZS5wb3MsIG1heDIgPSBzdGF0ZS5wb3NNYXg7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMzMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSA5MSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgICAgIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuICAgICAgaWYgKGxhYmVsRW5kIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA0MCkge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDI7IHBvcysrKSB7XG4gICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgIGlmICghaXNTcGFjZShjb2RlMikgJiYgY29kZTIgIT09IDEwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSBtYXgyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICBmb3IgKDsgcG9zIDwgbWF4MjsgcG9zKyspIHtcbiAgICAgICAgICBjb2RlMiA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgICAgIGZvciAoOyBwb3MgPCBtYXgyOyBwb3MrKykge1xuICAgICAgICAgICAgY29kZTIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUyKSAmJiBjb2RlMiAhPT0gMTApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IG1heDIgfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gNDEpIHtcbiAgICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgbWF4MiAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSA5MSkge1xuICAgICAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICAgICAgdGl0bGUgPSByZWYudGl0bGU7XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBjb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTtcbiAgICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKGNvbnRlbnQsIHN0YXRlLm1kLCBzdGF0ZS5lbnYsIHRva2VucyA9IFtdKTtcbiAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiaW1hZ2VcIiwgXCJpbWdcIiwgMCk7XG4gICAgICAgIHRva2VuLmF0dHJzID0gYXR0cnMgPSBbW1wic3JjXCIsIGhyZWZdLCBbXCJhbHRcIiwgXCJcIl1dO1xuICAgICAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICAgICAgdG9rZW4uY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgIGF0dHJzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgc3RhdGUucG9zTWF4ID0gbWF4MjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qc1xudmFyIHJlcXVpcmVfYXV0b2xpbmsgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9hdXRvbGluay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBFTUFJTF9SRSA9IC9eKFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopJC87XG4gICAgdmFyIEFVVE9MSU5LX1JFID0gL14oW2EtekEtWl1bYS16QS1aMC05Ky5cXC1dezEsMzF9KTooW148PlxceDAwLVxceDIwXSopJC87XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhdXRvbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gICAgICB2YXIgdXJsLCBmdWxsVXJsLCB0b2tlbiwgY2gsIHN0YXJ0LCBtYXgyLCBwb3MgPSBzdGF0ZS5wb3M7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gNjApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gICAgICBtYXgyID0gc3RhdGUucG9zTWF4O1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGlmICgrK3BvcyA+PSBtYXgyKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY2ggPT09IDYwKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNoID09PSA2MilcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHVybCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHBvcyk7XG4gICAgICBpZiAoQVVUT0xJTktfUkUudGVzdCh1cmwpKSB7XG4gICAgICAgIGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybCk7XG4gICAgICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19vcGVuXCIsIFwiYVwiLCAxKTtcbiAgICAgICAgICB0b2tlbi5hdHRycyA9IFtbXCJocmVmXCIsIGZ1bGxVcmxdXTtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImF1dG9saW5rXCI7XG4gICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybCk7XG4gICAgICAgICAgdG9rZW4gPSBzdGF0ZS5wdXNoKFwibGlua19jbG9zZVwiLCBcImFcIiwgLTEpO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCA9IFwiYXV0b2xpbmtcIjtcbiAgICAgICAgICB0b2tlbi5pbmZvID0gXCJhdXRvXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IHVybC5sZW5ndGggKyAyO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFTUFJTF9SRS50ZXN0KHVybCkpIHtcbiAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoXCJtYWlsdG86XCIgKyB1cmwpO1xuICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImxpbmtfb3BlblwiLCBcImFcIiwgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgPSBbW1wiaHJlZlwiLCBmdWxsVXJsXV07XG4gICAgICAgICAgdG9rZW4ubWFya3VwID0gXCJhdXRvbGlua1wiO1xuICAgICAgICAgIHRva2VuLmluZm8gPSBcImF1dG9cIjtcbiAgICAgICAgICB0b2tlbiA9IHN0YXRlLnB1c2goXCJ0ZXh0XCIsIFwiXCIsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpO1xuICAgICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImxpbmtfY2xvc2VcIiwgXCJhXCIsIC0xKTtcbiAgICAgICAgICB0b2tlbi5tYXJrdXAgPSBcImF1dG9saW5rXCI7XG4gICAgICAgICAgdG9rZW4uaW5mbyA9IFwiYXV0b1wiO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBvcyArPSB1cmwubGVuZ3RoICsgMjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzXG52YXIgcmVxdWlyZV9odG1sX2lubGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZV9odG1sX3JlKCkuSFRNTF9UQUdfUkU7XG4gICAgZnVuY3Rpb24gaXNMZXR0ZXIoY2gpIHtcbiAgICAgIHZhciBsYyA9IGNoIHwgMzI7XG4gICAgICByZXR1cm4gbGMgPj0gOTcgJiYgbGMgPD0gMTIyO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgbWF0Y2gsIG1heDIsIHRva2VuLCBwb3MgPSBzdGF0ZS5wb3M7XG4gICAgICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtYXgyID0gc3RhdGUucG9zTWF4O1xuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDYwIHx8IHBvcyArIDIgPj0gbWF4Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKGNoICE9PSAzMyAmJiBjaCAhPT0gNjMgJiYgY2ggIT09IDQ3ICYmICFpc0xldHRlcihjaCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRva2VuID0gc3RhdGUucHVzaChcImh0bWxfaW5saW5lXCIsIFwiXCIsIDApO1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzXG52YXIgcmVxdWlyZV9lbnRpdHkgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZW50aXRpZXMgPSByZXF1aXJlX2VudGl0aWVzMigpO1xuICAgIHZhciBoYXMgPSByZXF1aXJlX3V0aWxzKCkuaGFzO1xuICAgIHZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1ZhbGlkRW50aXR5Q29kZTtcbiAgICB2YXIgZnJvbUNvZGVQb2ludCA9IHJlcXVpcmVfdXRpbHMoKS5mcm9tQ29kZVBvaW50O1xuICAgIHZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw2fXxbMC05XXsxLDd9KSk7L2k7XG4gICAgdmFyIE5BTUVEX1JFID0gL14mKFthLXpdW2EtejAtOV17MSwzMX0pOy9pO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW50aXR5KHN0YXRlLCBzaWxlbnQpIHtcbiAgICAgIHZhciBjaCwgY29kZTIsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heDIgPSBzdGF0ZS5wb3NNYXg7XG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMzgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBvcyArIDEgPCBtYXgyKSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgIGlmIChjaCA9PT0gMzUpIHtcbiAgICAgICAgICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgICAgY29kZTIgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSBcInhcIiA/IHBhcnNlSW50KG1hdGNoWzFdLnNsaWNlKDEpLCAxNikgOiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUyKSA/IGZyb21Db2RlUG9pbnQoY29kZTIpIDogZnJvbUNvZGVQb2ludCg2NTUzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IFwiJlwiO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qc1xudmFyIHJlcXVpcmVfYmFsYW5jZV9wYWlycyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgZGVsaW1pdGVycykge1xuICAgICAgdmFyIGNsb3NlcklkeCwgb3BlbmVySWR4LCBjbG9zZXIsIG9wZW5lciwgbWluT3BlbmVySWR4LCBuZXdNaW5PcGVuZXJJZHgsIGlzT2RkTWF0Y2gsIGxhc3RKdW1wLCBvcGVuZXJzQm90dG9tID0ge30sIG1heDIgPSBkZWxpbWl0ZXJzLmxlbmd0aDtcbiAgICAgIGlmICghbWF4MilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIGhlYWRlcklkeCA9IDA7XG4gICAgICB2YXIgbGFzdFRva2VuSWR4ID0gLTI7XG4gICAgICB2YXIganVtcHMgPSBbXTtcbiAgICAgIGZvciAoY2xvc2VySWR4ID0gMDsgY2xvc2VySWR4IDwgbWF4MjsgY2xvc2VySWR4KyspIHtcbiAgICAgICAgY2xvc2VyID0gZGVsaW1pdGVyc1tjbG9zZXJJZHhdO1xuICAgICAgICBqdW1wcy5wdXNoKDApO1xuICAgICAgICBpZiAoZGVsaW1pdGVyc1toZWFkZXJJZHhdLm1hcmtlciAhPT0gY2xvc2VyLm1hcmtlciB8fCBsYXN0VG9rZW5JZHggIT09IGNsb3Nlci50b2tlbiAtIDEpIHtcbiAgICAgICAgICBoZWFkZXJJZHggPSBjbG9zZXJJZHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRva2VuSWR4ID0gY2xvc2VyLnRva2VuO1xuICAgICAgICBjbG9zZXIubGVuZ3RoID0gY2xvc2VyLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAoIWNsb3Nlci5jbG9zZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFvcGVuZXJzQm90dG9tLmhhc093blByb3BlcnR5KGNsb3Nlci5tYXJrZXIpKSB7XG4gICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXSA9IFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBtaW5PcGVuZXJJZHggPSBvcGVuZXJzQm90dG9tW2Nsb3Nlci5tYXJrZXJdWyhjbG9zZXIub3BlbiA/IDMgOiAwKSArIGNsb3Nlci5sZW5ndGggJSAzXTtcbiAgICAgICAgb3BlbmVySWR4ID0gaGVhZGVySWR4IC0ganVtcHNbaGVhZGVySWR4XSAtIDE7XG4gICAgICAgIG5ld01pbk9wZW5lcklkeCA9IG9wZW5lcklkeDtcbiAgICAgICAgZm9yICg7IG9wZW5lcklkeCA+IG1pbk9wZW5lcklkeDsgb3BlbmVySWR4IC09IGp1bXBzW29wZW5lcklkeF0gKyAxKSB7XG4gICAgICAgICAgb3BlbmVyID0gZGVsaW1pdGVyc1tvcGVuZXJJZHhdO1xuICAgICAgICAgIGlmIChvcGVuZXIubWFya2VyICE9PSBjbG9zZXIubWFya2VyKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKG9wZW5lci5vcGVuICYmIG9wZW5lci5lbmQgPCAwKSB7XG4gICAgICAgICAgICBpc09kZE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAob3BlbmVyLmNsb3NlIHx8IGNsb3Nlci5vcGVuKSB7XG4gICAgICAgICAgICAgIGlmICgob3BlbmVyLmxlbmd0aCArIGNsb3Nlci5sZW5ndGgpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubGVuZ3RoICUgMyAhPT0gMCB8fCBjbG9zZXIubGVuZ3RoICUgMyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaXNPZGRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzT2RkTWF0Y2gpIHtcbiAgICAgICAgICAgICAgbGFzdEp1bXAgPSBvcGVuZXJJZHggPiAwICYmICFkZWxpbWl0ZXJzW29wZW5lcklkeCAtIDFdLm9wZW4gPyBqdW1wc1tvcGVuZXJJZHggLSAxXSArIDEgOiAwO1xuICAgICAgICAgICAgICBqdW1wc1tjbG9zZXJJZHhdID0gY2xvc2VySWR4IC0gb3BlbmVySWR4ICsgbGFzdEp1bXA7XG4gICAgICAgICAgICAgIGp1bXBzW29wZW5lcklkeF0gPSBsYXN0SnVtcDtcbiAgICAgICAgICAgICAgY2xvc2VyLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgb3BlbmVyLmVuZCA9IGNsb3NlcklkeDtcbiAgICAgICAgICAgICAgb3BlbmVyLmNsb3NlID0gZmFsc2U7XG4gICAgICAgICAgICAgIG5ld01pbk9wZW5lcklkeCA9IC0xO1xuICAgICAgICAgICAgICBsYXN0VG9rZW5JZHggPSAtMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdNaW5PcGVuZXJJZHggIT09IC0xKSB7XG4gICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXVsoY2xvc2VyLm9wZW4gPyAzIDogMCkgKyAoY2xvc2VyLmxlbmd0aCB8fCAwKSAlIDNdID0gbmV3TWluT3BlbmVySWR4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlua19wYWlycyhzdGF0ZSkge1xuICAgICAgdmFyIGN1cnIsIHRva2Vuc19tZXRhID0gc3RhdGUudG9rZW5zX21ldGEsIG1heDIgPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGg7XG4gICAgICBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgc3RhdGUuZGVsaW1pdGVycyk7XG4gICAgICBmb3IgKGN1cnIgPSAwOyBjdXJyIDwgbWF4MjsgY3VycisrKSB7XG4gICAgICAgIGlmICh0b2tlbnNfbWV0YVtjdXJyXSAmJiB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKSB7XG4gICAgICAgICAgcHJvY2Vzc0RlbGltaXRlcnMoc3RhdGUsIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UuanNcbnZhciByZXF1aXJlX3RleHRfY29sbGFwc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gICAgICB2YXIgY3VyciwgbGFzdCwgbGV2ZWwgPSAwLCB0b2tlbnMgPSBzdGF0ZS50b2tlbnMsIG1heDIgPSBzdGF0ZS50b2tlbnMubGVuZ3RoO1xuICAgICAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXgyOyBjdXJyKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nIDwgMClcbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nID4gMClcbiAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAodG9rZW5zW2N1cnJdLnR5cGUgPT09IFwidGV4dFwiICYmIGN1cnIgKyAxIDwgbWF4MiAmJiB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICAgICAgICAgIHRva2Vuc1tsYXN0XSA9IHRva2Vuc1tjdXJyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgICAgICB0b2tlbnMubGVuZ3RoID0gbGFzdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzXG52YXIgcmVxdWlyZV9zdGF0ZV9pbmxpbmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgVG9rZW4gPSByZXF1aXJlX3Rva2VuKCk7XG4gICAgdmFyIGlzV2hpdGVTcGFjZSA9IHJlcXVpcmVfdXRpbHMoKS5pc1doaXRlU3BhY2U7XG4gICAgdmFyIGlzUHVuY3RDaGFyID0gcmVxdWlyZV91dGlscygpLmlzUHVuY3RDaGFyO1xuICAgIHZhciBpc01kQXNjaWlQdW5jdCA9IHJlcXVpcmVfdXRpbHMoKS5pc01kQXNjaWlQdW5jdDtcbiAgICBmdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICB0aGlzLmVudiA9IGVudjtcbiAgICAgIHRoaXMubWQgPSBtZDtcbiAgICAgIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zO1xuICAgICAgdGhpcy50b2tlbnNfbWV0YSA9IEFycmF5KG91dFRva2Vucy5sZW5ndGgpO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5wb3NNYXggPSB0aGlzLnNyYy5sZW5ndGg7XG4gICAgICB0aGlzLmxldmVsID0gMDtcbiAgICAgIHRoaXMucGVuZGluZyA9IFwiXCI7XG4gICAgICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG4gICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB0aGlzLmRlbGltaXRlcnMgPSBbXTtcbiAgICAgIHRoaXMuX3ByZXZfZGVsaW1pdGVycyA9IFtdO1xuICAgICAgdGhpcy5iYWNrdGlja3MgPSB7fTtcbiAgICAgIHRoaXMuYmFja3RpY2tzU2Nhbm5lZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbihcInRleHRcIiwgXCJcIiwgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgdGhpcy5wZW5kaW5nID0gXCJcIjtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIFN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgICAgIHRoaXMucHVzaFBlbmRpbmcoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICAgICAgdmFyIHRva2VuX21ldGEgPSBudWxsO1xuICAgICAgaWYgKG5lc3RpbmcgPCAwKSB7XG4gICAgICAgIHRoaXMubGV2ZWwtLTtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gdGhpcy5fcHJldl9kZWxpbWl0ZXJzLnBvcCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgaWYgKG5lc3RpbmcgPiAwKSB7XG4gICAgICAgIHRoaXMubGV2ZWwrKztcbiAgICAgICAgdGhpcy5fcHJldl9kZWxpbWl0ZXJzLnB1c2godGhpcy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gW107XG4gICAgICAgIHRva2VuX21ldGEgPSB7IGRlbGltaXRlcnM6IHRoaXMuZGVsaW1pdGVycyB9O1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB0aGlzLnRva2Vuc19tZXRhLnB1c2godG9rZW5fbWV0YSk7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfTtcbiAgICBTdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uKHN0YXJ0LCBjYW5TcGxpdFdvcmQpIHtcbiAgICAgIHZhciBwb3MgPSBzdGFydCwgbGFzdENoYXIsIG5leHRDaGFyLCBjb3VudCwgY2FuX29wZW4sIGNhbl9jbG9zZSwgaXNMYXN0V2hpdGVTcGFjZSwgaXNMYXN0UHVuY3RDaGFyLCBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsIGxlZnRfZmxhbmtpbmcgPSB0cnVlLCByaWdodF9mbGFua2luZyA9IHRydWUsIG1heDIgPSB0aGlzLnBvc01heCwgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG4gICAgICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDMyO1xuICAgICAgd2hpbGUgKHBvcyA8IG1heDIgJiYgdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpID09PSBtYXJrZXIpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICB9XG4gICAgICBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuICAgICAgbmV4dENoYXIgPSBwb3MgPCBtYXgyID8gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpIDogMzI7XG4gICAgICBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpO1xuICAgICAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIHJpZ2h0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc05leHRXaGl0ZVNwYWNlIHx8IGlzTmV4dFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgICAgICBjYW5fb3BlbiA9IGxlZnRfZmxhbmtpbmcgJiYgKCFyaWdodF9mbGFua2luZyB8fCBpc0xhc3RQdW5jdENoYXIpO1xuICAgICAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgfHwgaXNOZXh0UHVuY3RDaGFyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbl9vcGVuID0gbGVmdF9mbGFua2luZztcbiAgICAgICAgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5fb3BlbixcbiAgICAgICAgY2FuX2Nsb3NlLFxuICAgICAgICBsZW5ndGg6IGNvdW50XG4gICAgICB9O1xuICAgIH07XG4gICAgU3RhdGVJbmxpbmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUlubGluZTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qc1xudmFyIHJlcXVpcmVfcGFyc2VyX2lubGluZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBSdWxlciA9IHJlcXVpcmVfcnVsZXIoKTtcbiAgICB2YXIgX3J1bGVzID0gW1xuICAgICAgW1widGV4dFwiLCByZXF1aXJlX3RleHQoKV0sXG4gICAgICBbXCJuZXdsaW5lXCIsIHJlcXVpcmVfbmV3bGluZSgpXSxcbiAgICAgIFtcImVzY2FwZVwiLCByZXF1aXJlX2VzY2FwZSgpXSxcbiAgICAgIFtcImJhY2t0aWNrc1wiLCByZXF1aXJlX2JhY2t0aWNrcygpXSxcbiAgICAgIFtcInN0cmlrZXRocm91Z2hcIiwgcmVxdWlyZV9zdHJpa2V0aHJvdWdoKCkudG9rZW5pemVdLFxuICAgICAgW1wiZW1waGFzaXNcIiwgcmVxdWlyZV9lbXBoYXNpcygpLnRva2VuaXplXSxcbiAgICAgIFtcImxpbmtcIiwgcmVxdWlyZV9saW5rKCldLFxuICAgICAgW1wiaW1hZ2VcIiwgcmVxdWlyZV9pbWFnZSgpXSxcbiAgICAgIFtcImF1dG9saW5rXCIsIHJlcXVpcmVfYXV0b2xpbmsoKV0sXG4gICAgICBbXCJodG1sX2lubGluZVwiLCByZXF1aXJlX2h0bWxfaW5saW5lKCldLFxuICAgICAgW1wiZW50aXR5XCIsIHJlcXVpcmVfZW50aXR5KCldXG4gICAgXTtcbiAgICB2YXIgX3J1bGVzMiA9IFtcbiAgICAgIFtcImJhbGFuY2VfcGFpcnNcIiwgcmVxdWlyZV9iYWxhbmNlX3BhaXJzKCldLFxuICAgICAgW1wic3RyaWtldGhyb3VnaFwiLCByZXF1aXJlX3N0cmlrZXRocm91Z2goKS5wb3N0UHJvY2Vzc10sXG4gICAgICBbXCJlbXBoYXNpc1wiLCByZXF1aXJlX2VtcGhhc2lzKCkucG9zdFByb2Nlc3NdLFxuICAgICAgW1widGV4dF9jb2xsYXBzZVwiLCByZXF1aXJlX3RleHRfY29sbGFwc2UoKV1cbiAgICBdO1xuICAgIGZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydWxlcjIgPSBuZXcgUnVsZXIoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucnVsZXIyLnB1c2goX3J1bGVzMltpXVswXSwgX3J1bGVzMltpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLCBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoXCJcIiksIGxlbiA9IHJ1bGVzLmxlbmd0aCwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZywgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcbiAgICAgIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgICAgc3RhdGUubGV2ZWwtLTtcbiAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucG9zID0gc3RhdGUucG9zTWF4O1xuICAgICAgfVxuICAgICAgaWYgKCFvaykge1xuICAgICAgICBzdGF0ZS5wb3MrKztcbiAgICAgIH1cbiAgICAgIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG4gICAgfTtcbiAgICBQYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciBvaywgaSwgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKFwiXCIpLCBsZW4gPSBydWxlcy5sZW5ndGgsIGVuZCA9IHN0YXRlLnBvc01heCwgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZztcbiAgICAgIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgICAgIHN0YXRlLnB1c2hQZW5kaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXJJbmxpbmUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgICAgIHZhciBpLCBydWxlcywgbGVuO1xuICAgICAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuICAgICAgdGhpcy50b2tlbml6ZShzdGF0ZSk7XG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKFwiXCIpO1xuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlX3N0YXRlX2lubGluZSgpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gUGFyc2VySW5saW5lO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzXG52YXIgcmVxdWlyZV9yZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2xpYi9yZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIHJlID0ge307XG4gICAgICByZS5zcmNfQW55ID0gcmVxdWlyZV9yZWdleDIoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfQ2MgPSByZXF1aXJlX3JlZ2V4MygpLnNvdXJjZTtcbiAgICAgIHJlLnNyY19aID0gcmVxdWlyZV9yZWdleDUoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfUCA9IHJlcXVpcmVfcmVnZXgoKS5zb3VyY2U7XG4gICAgICByZS5zcmNfWlBDYyA9IFtyZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DY10uam9pbihcInxcIik7XG4gICAgICByZS5zcmNfWkNjID0gW3JlLnNyY19aLCByZS5zcmNfQ2NdLmpvaW4oXCJ8XCIpO1xuICAgICAgdmFyIHRleHRfc2VwYXJhdG9ycyA9IFwiWz48XFx1RkY1Q11cIjtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyID0gXCIoPzooPyFcIiArIHRleHRfc2VwYXJhdG9ycyArIFwifFwiICsgcmUuc3JjX1pQQ2MgKyBcIilcIiArIHJlLnNyY19BbnkgKyBcIilcIjtcbiAgICAgIHJlLnNyY19pcDQgPSBcIig/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcIjtcbiAgICAgIHJlLnNyY19hdXRoID0gXCIoPzooPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbQC9cXFxcW1xcXFxdKCldKS4pK0ApP1wiO1xuICAgICAgcmUuc3JjX3BvcnQgPSBcIig/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpP1wiO1xuICAgICAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9IFwiKD89JHxcIiArIHRleHRfc2VwYXJhdG9ycyArIFwifFwiICsgcmUuc3JjX1pQQ2MgKyBcIikoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8XCIgKyByZS5zcmNfWlBDYyArIFwiKSlcIjtcbiAgICAgIHJlLnNyY19wYXRoID0gXCIoPzpbLz8jXSg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFwiICsgdGV4dF9zZXBhcmF0b3JzICsgYHxbKClbXFxcXF17fS4sXCInPyFcXFxcLTtdKS58XFxcXFsoPzooPyFgICsgcmUuc3JjX1pDYyArIFwifFxcXFxdKS4pKlxcXFxdfFxcXFwoKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyldKS4pKlxcXFwpfFxcXFx7KD86KD8hXCIgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18XFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyBgfFtcIl0pLikrXFxcXFwifFxcXFwnKD86KD8hYCArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgXCJ8Wy1dKS58XFxcXC57Mix9W2EtekEtWjAtOSUvJl18XFxcXC4oPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbLl0pLnxcIiArIChvcHRzICYmIG9wdHNbXCItLS1cIl0gPyBcIlxcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXxcIiA6IFwiXFxcXC0rfFwiKSArIFwiLCg/IVwiICsgcmUuc3JjX1pDYyArIFwiKS58Oyg/IVwiICsgcmUuc3JjX1pDYyArIFwiKS58XFxcXCErKD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyFdKS58XFxcXD8oPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbP10pLikrfFxcXFwvKT9cIjtcbiAgICAgIHJlLnNyY19lbWFpbF9uYW1lID0gJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFwuYS16QS1aMC05X11bXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKic7XG4gICAgICByZS5zcmNfeG4gPSBcInhuLS1bYS16MC05XFxcXC1dezEsNTl9XCI7XG4gICAgICByZS5zcmNfZG9tYWluX3Jvb3QgPSBcIig/OlwiICsgcmUuc3JjX3huICsgXCJ8XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArIFwiezEsNjN9KVwiO1xuICAgICAgcmUuc3JjX2RvbWFpbiA9IFwiKD86XCIgKyByZS5zcmNfeG4gKyBcInwoPzpcIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgXCIpfCg/OlwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyBcIig/Oi18XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArIFwiKXswLDYxfVwiICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyBcIikpXCI7XG4gICAgICByZS5zcmNfaG9zdCA9IFwiKD86KD86KD86KD86XCIgKyByZS5zcmNfZG9tYWluICsgXCIpXFxcXC4pKlwiICsgcmUuc3JjX2RvbWFpbiArIFwiKSlcIjtcbiAgICAgIHJlLnRwbF9ob3N0X2Z1enp5ID0gXCIoPzpcIiArIHJlLnNyY19pcDQgKyBcInwoPzooPzooPzpcIiArIHJlLnNyY19kb21haW4gKyBcIilcXFxcLikrKD86JVRMRFMlKSkpXCI7XG4gICAgICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9IFwiKD86KD86KD86XCIgKyByZS5zcmNfZG9tYWluICsgXCIpXFxcXC4pKyg/OiVUTERTJSkpXCI7XG4gICAgICByZS5zcmNfaG9zdF9zdHJpY3QgPSByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPSByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS5zcmNfaG9zdF9wb3J0X3N0cmljdCA9IHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuICAgICAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPSByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcbiAgICAgIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID0gcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG4gICAgICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID0gXCJsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86XCIgKyByZS5zcmNfWlBDYyArIFwifD58JCkpXCI7XG4gICAgICByZS50cGxfZW1haWxfZnV6enkgPSBcIihefFwiICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcInxcXFxcKHwnICsgcmUuc3JjX1pDYyArIFwiKShcIiArIHJlLnNyY19lbWFpbF9uYW1lICsgXCJAXCIgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyBcIilcIjtcbiAgICAgIHJlLnRwbF9saW5rX2Z1enp5ID0gXCIoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1RkY1Q118XCIgKyByZS5zcmNfWlBDYyArIFwiKSkoKD8hWyQrPD0+XmB8XFx1RkY1Q10pXCIgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgXCIpXCI7XG4gICAgICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9IFwiKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdUZGNUNdfFwiICsgcmUuc3JjX1pQQ2MgKyBcIikpKCg/IVskKzw9Pl5gfFxcdUZGNUNdKVwiICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArIFwiKVwiO1xuICAgICAgcmV0dXJuIHJlO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGlua2lmeV9pdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gYXNzaWduKG9iaikge1xuICAgICAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9jbGFzcyhvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgICByZXR1cm4gX2NsYXNzKG9iaikgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIF9jbGFzcyhvYmopID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcbiAgICAgIHJldHVybiBfY2xhc3Mob2JqKSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbjIob2JqKSB7XG4gICAgICByZXR1cm4gX2NsYXNzKG9iaikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgXCJcXFxcJCZcIik7XG4gICAgfVxuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGZ1enp5TGluazogdHJ1ZSxcbiAgICAgIGZ1enp5RW1haWw6IHRydWUsXG4gICAgICBmdXp6eUlQOiBmYWxzZVxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgaykge1xuICAgICAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICAgICBcImh0dHA6XCI6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHRleHQyLCBwb3MsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgICAgIHNlbGYucmUuaHR0cCA9IG5ldyBSZWdFeHAoXCJeXFxcXC9cXFxcL1wiICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCBcImlcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5odHRwKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwczpcIjogXCJodHRwOlwiLFxuICAgICAgXCJmdHA6XCI6IFwiaHR0cDpcIixcbiAgICAgIFwiLy9cIjoge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24odGV4dDIsIHBvcywgc2VsZikge1xuICAgICAgICAgIHZhciB0YWlsID0gdGV4dDIuc2xpY2UocG9zKTtcbiAgICAgICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgICAgICAgc2VsZi5yZS5ub19odHRwID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlbGYucmUuc3JjX2F1dGggKyBcIig/OmxvY2FsaG9zdHwoPzooPzpcIiArIHNlbGYucmUuc3JjX2RvbWFpbiArIFwiKVxcXFwuKStcIiArIHNlbGYucmUuc3JjX2RvbWFpbl9yb290ICsgXCIpXCIgKyBzZWxmLnJlLnNyY19wb3J0ICsgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICsgc2VsZi5yZS5zcmNfcGF0aCwgXCJpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0Mltwb3MgLSAzXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dDJbcG9zIC0gM10gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJtYWlsdG86XCI6IHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uKHRleHQyLCBwb3MsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSBuZXcgUmVnRXhwKFwiXlwiICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArIFwiQFwiICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsIFwiaVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubWFpbHRvKVswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdGxkc18yY2hfc3JjX3JlID0gXCJhW2NkZWZnaWxtbm9xcnN0dXd4el18YlthYmRlZmdoaWptbm9yc3R2d3l6XXxjW2FjZGZnaGlrbG1ub3J1dnd4eXpdfGRbZWprbW96XXxlW2NlZ3JzdHVdfGZbaWprbW9yXXxnW2FiZGVmZ2hpbG1ucHFyc3R1d3ldfGhba21ucnR1XXxpW2RlbG1ub3Fyc3RdfGpbZW1vcF18a1tlZ2hpbW5wcnd5el18bFthYmNpa3JzdHV2eV18bVthY2RlZ2hrbG1ub3BxcnN0dXZ3eHl6XXxuW2FjZWZnaWxvcHJ1el18b218cFthZWZnaGtsbW5yc3R3eV18cWF8cltlb3N1d118c1thYmNkZWdoaWprbG1ub3J0dXZ4eXpdfHRbY2RmZ2hqa2xtbm9ydHZ3el18dVthZ2tzeXpdfHZbYWNlZ2ludV18d1tmc118eVtldF18elthbXddXCI7XG4gICAgdmFyIHRsZHNfZGVmYXVsdCA9IFwiYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfFxcdTA0NDBcXHUwNDQ0XCIuc3BsaXQoXCJ8XCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgICAgIHNlbGYuX19pbmRleF9fID0gLTE7XG4gICAgICBzZWxmLl9fdGV4dF9jYWNoZV9fID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHJlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odGV4dDIsIHBvcykge1xuICAgICAgICB2YXIgdGFpbCA9IHRleHQyLnNsaWNlKHBvcyk7XG4gICAgICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2gocmUpWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6ZXIoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obWF0Y2gsIHNlbGYpIHtcbiAgICAgICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShzZWxmKSB7XG4gICAgICB2YXIgcmUgPSBzZWxmLnJlID0gcmVxdWlyZV9yZSgpKHNlbGYuX19vcHRzX18pO1xuICAgICAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG4gICAgICBzZWxmLm9uQ29tcGlsZSgpO1xuICAgICAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICAgICAgfVxuICAgICAgdGxkcy5wdXNoKHJlLnNyY194bik7XG4gICAgICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbihcInxcIik7XG4gICAgICBmdW5jdGlvbiB1bnRwbCh0cGwpIHtcbiAgICAgICAgcmV0dXJuIHRwbC5yZXBsYWNlKFwiJVRMRFMlXCIsIHJlLnNyY190bGRzKTtcbiAgICAgIH1cbiAgICAgIHJlLmVtYWlsX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksIFwiaVwiKTtcbiAgICAgIHJlLmxpbmtfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCBcImlcIik7XG4gICAgICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgXCJpXCIpO1xuICAgICAgcmUuaG9zdF9mdXp6eV90ZXN0ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCBcImlcIik7XG4gICAgICB2YXIgYWxpYXNlcyA9IFtdO1xuICAgICAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fTtcbiAgICAgIGZ1bmN0aW9uIHNjaGVtYUVycm9yKG5hbWUsIHZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcbiAgICAgICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZDtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICBpZiAoaXNSZWdFeHAodmFsLnZhbGlkYXRlKSkge1xuICAgICAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24yKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbjIodmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICAgICAgfSBlbHNlIGlmICghdmFsLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9KTtcbiAgICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbihhbGlhcykge1xuICAgICAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10udmFsaWRhdGUgPSBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS5ub3JtYWxpemUgPSBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICAgICAgfSk7XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tcIlwiXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG4gICAgICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXykuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXTtcbiAgICAgIH0pLm1hcChlc2NhcGVSRSkuam9pbihcInxcIik7XG4gICAgICBzZWxmLnJlLnNjaGVtYV90ZXN0ID0gUmVnRXhwKFwiKF58KD8hXykoPzpbPjxcXHVGRjVDXXxcIiArIHJlLnNyY19aUENjICsgXCIpKShcIiArIHNsaXN0ICsgXCIpXCIsIFwiaVwiKTtcbiAgICAgIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cChcIihefCg/IV8pKD86Wz48XFx1RkY1Q118XCIgKyByZS5zcmNfWlBDYyArIFwiKSkoXCIgKyBzbGlzdCArIFwiKVwiLCBcImlnXCIpO1xuICAgICAgc2VsZi5yZS5wcmV0ZXN0ID0gUmVnRXhwKFwiKFwiICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyBcIil8KFwiICsgc2VsZi5yZS5ob3N0X2Z1enp5X3Rlc3Quc291cmNlICsgXCIpfEBcIiwgXCJpXCIpO1xuICAgICAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXywgZW5kID0gc2VsZi5fX2xhc3RfaW5kZXhfXywgdGV4dDIgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgdGhpcy5zY2hlbWEgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuaW5kZXggPSBzdGFydCArIHNoaWZ0O1xuICAgICAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgICAgIHRoaXMucmF3ID0gdGV4dDI7XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICAgIHRoaXMudXJsID0gdGV4dDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuICAgICAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucykge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzT3B0aW9uc09iaihzY2hlbWFzKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAtMTtcbiAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSAtMTtcbiAgICAgIHRoaXMuX19zY2hlbWFfXyA9IFwiXCI7XG4gICAgICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gXCJcIjtcbiAgICAgIHRoaXMuX19zY2hlbWFzX18gPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgICAgIHRoaXMuX19jb21waWxlZF9fID0ge307XG4gICAgICB0aGlzLl9fdGxkc19fID0gdGxkc19kZWZhdWx0O1xuICAgICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5yZSA9IHt9O1xuICAgICAgY29tcGlsZSh0aGlzKTtcbiAgICB9XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gICAgICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICAgICAgY29tcGlsZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0Mikge1xuICAgICAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQyO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAtMTtcbiAgICAgIGlmICghdGV4dDIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG4gICAgICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQyKSkge1xuICAgICAgICByZSA9IHRoaXMucmUuc2NoZW1hX3NlYXJjaDtcbiAgICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0MikpICE9PSBudWxsKSB7XG4gICAgICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dDIsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fID0gbVsyXTtcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fW1wiaHR0cDpcIl0pIHtcbiAgICAgICAgdGxkX3BvcyA9IHRleHQyLnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgaWYgKChtbCA9IHRleHQyLm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gPSBzaGlmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bXCJtYWlsdG86XCJdKSB7XG4gICAgICAgIGF0X3BvcyA9IHRleHQyLmluZGV4T2YoXCJAXCIpO1xuICAgICAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgICAgICBpZiAoKG1lID0gdGV4dDIubWF0Y2godGhpcy5yZS5lbWFpbF9mdXp6eSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8IHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykge1xuICAgICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gPSBcIm1haWx0bzpcIjtcbiAgICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gPSBzaGlmdDtcbiAgICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2luZGV4X18gPj0gMDtcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0Mik7XG4gICAgfTtcbiAgICBMaW5raWZ5SXQucHJvdG90eXBlLnRlc3RTY2hlbWFBdCA9IGZ1bmN0aW9uIHRlc3RTY2hlbWFBdCh0ZXh0Miwgc2NoZW1hLCBwb3MpIHtcbiAgICAgIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0MiwgcG9zLCB0aGlzKTtcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0Mikge1xuICAgICAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0Mikge1xuICAgICAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgICAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gICAgICB9XG4gICAgICB2YXIgdGFpbCA9IHNoaWZ0ID8gdGV4dDIuc2xpY2Uoc2hpZnQpIDogdGV4dDI7XG4gICAgICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgICAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGlua2lmeUl0LnByb3RvdHlwZS50bGRzID0gZnVuY3Rpb24gdGxkcyhsaXN0Miwga2VlcE9sZCkge1xuICAgICAgbGlzdDIgPSBBcnJheS5pc0FycmF5KGxpc3QyKSA/IGxpc3QyIDogW2xpc3QyXTtcbiAgICAgIGlmICgha2VlcE9sZCkge1xuICAgICAgICB0aGlzLl9fdGxkc19fID0gbGlzdDIuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyA9IHRydWU7XG4gICAgICAgIGNvbXBpbGUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QyKS5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uKGVsLCBpZHgsIGFycikge1xuICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgIGNvbXBpbGUodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG4gICAgICBpZiAoIW1hdGNoLnNjaGVtYSkge1xuICAgICAgICBtYXRjaC51cmwgPSBcImh0dHA6Ly9cIiArIG1hdGNoLnVybDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5zY2hlbWEgPT09IFwibWFpbHRvOlwiICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICAgICAgbWF0Y2gudXJsID0gXCJtYWlsdG86XCIgKyBtYXRjaC51cmw7XG4gICAgICB9XG4gICAgfTtcbiAgICBMaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzXG52YXIgcmVxdWlyZV9wdW55Y29kZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3O1xuICAgIHZhciBiYXNlID0gMzY7XG4gICAgdmFyIHRNaW4gPSAxO1xuICAgIHZhciB0TWF4ID0gMjY7XG4gICAgdmFyIHNrZXcgPSAzODtcbiAgICB2YXIgZGFtcCA9IDcwMDtcbiAgICB2YXIgaW5pdGlhbEJpYXMgPSA3MjtcbiAgICB2YXIgaW5pdGlhbE4gPSAxMjg7XG4gICAgdmFyIGRlbGltaXRlciA9IFwiLVwiO1xuICAgIHZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbiAgICB2YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3RV0vO1xuICAgIHZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nO1xuICAgIHZhciBlcnJvcnMgPSB7XG4gICAgICBcIm92ZXJmbG93XCI6IFwiT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3NcIixcbiAgICAgIFwibm90LWJhc2ljXCI6IFwiSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KVwiLFxuICAgICAgXCJpbnZhbGlkLWlucHV0XCI6IFwiSW52YWxpZCBpbnB1dFwiXG4gICAgfTtcbiAgICB2YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gICAgZnVuY3Rpb24gZXJyb3IyKHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gc3RyaW5nLnNwbGl0KFwiQFwiKTtcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyBcIkBcIjtcbiAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsIFwiLlwiKTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oXCIuXCIpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSA1NTI5NiAmJiB2YWx1ZSA8PSA1NjMxOSAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgIGlmICgoZXh0cmEgJiA2NDUxMikgPT0gNTYzMjApIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAxMDIzKSA8PCAxMCkgKyAoZXh0cmEgJiAxMDIzKSArIDY1NTM2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHZhciB1Y3MyZW5jb2RlID0gKGFycmF5KSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5hcnJheSk7XG4gICAgdmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuICAgICAgaWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfTtcbiAgICB2YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcbiAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG4gICAgfTtcbiAgICB2YXIgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICAgIGxldCBrID0gMDtcbiAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gICAgICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gICAgICBmb3IgKDsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG4gICAgfTtcbiAgICB2YXIgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsZXQgbiA9IGluaXRpYWxOO1xuICAgICAgbGV0IGJpYXMgPSBpbml0aWFsQmlhcztcbiAgICAgIGxldCBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG4gICAgICBpZiAoYmFzaWMgPCAwKSB7XG4gICAgICAgIGJhc2ljID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAxMjgpIHtcbiAgICAgICAgICBlcnJvcjIoXCJub3QtYmFzaWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7ICkge1xuICAgICAgICBsZXQgb2xkaSA9IGk7XG4gICAgICAgIGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9yMihcImludmFsaWQtaW5wdXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuICAgICAgICAgIGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcbiAgICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IGRpZ2l0ICogdztcbiAgICAgICAgICBjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG4gICAgICAgICAgICBlcnJvcjIoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdyAqPSBiYXNlTWludXNUO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcbiAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7XG4gICAgICAgIGkgJT0gb3V0O1xuICAgICAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4ub3V0cHV0KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuICAgICAgbGV0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgbGV0IG4gPSBpbml0aWFsTjtcbiAgICAgIGxldCBkZWx0YSA9IDA7XG4gICAgICBsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDEyOCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgIGxldCBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICBsZXQgbSA9IG1heEludDtcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgICAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgICAgIG4gPSBtO1xuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcbiAgICAgICAgICAgIGVycm9yMihcIm92ZXJmbG93XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgICAgIGxldCBxID0gZGVsdGE7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gYmFzZTsgOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgY29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuICAgICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG4gICAgICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG4gICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytkZWx0YTtcbiAgICAgICAgKytuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xuICAgIH07XG4gICAgdmFyIHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHRvQVNDSUkgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/IFwieG4tLVwiICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBwdW55Y29kZSA9IHtcbiAgICAgIFwidmVyc2lvblwiOiBcIjIuMS4wXCIsXG4gICAgICBcInVjczJcIjoge1xuICAgICAgICBcImRlY29kZVwiOiB1Y3MyZGVjb2RlLFxuICAgICAgICBcImVuY29kZVwiOiB1Y3MyZW5jb2RlXG4gICAgICB9LFxuICAgICAgXCJkZWNvZGVcIjogZGVjb2RlLFxuICAgICAgXCJlbmNvZGVcIjogZW5jb2RlLFxuICAgICAgXCJ0b0FTQ0lJXCI6IHRvQVNDSUksXG4gICAgICBcInRvVW5pY29kZVwiOiB0b1VuaWNvZGVcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5qc1xudmFyIHJlcXVpcmVfZGVmYXVsdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgICB4aHRtbE91dDogZmFsc2UsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGxhbmdQcmVmaXg6IFwibGFuZ3VhZ2UtXCIsXG4gICAgICAgIGxpbmtpZnk6IGZhbHNlLFxuICAgICAgICB0eXBvZ3JhcGhlcjogZmFsc2UsXG4gICAgICAgIHF1b3RlczogXCJcXHUyMDFDXFx1MjAxRFxcdTIwMThcXHUyMDE5XCIsXG4gICAgICAgIGhpZ2hsaWdodDogbnVsbCxcbiAgICAgICAgbWF4TmVzdGluZzogMTAwXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICBjb3JlOiB7fSxcbiAgICAgICAgYmxvY2s6IHt9LFxuICAgICAgICBpbmxpbmU6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzXG52YXIgcmVxdWlyZV96ZXJvID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8uanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaHRtbDogZmFsc2UsXG4gICAgICAgIHhodG1sT3V0OiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgbGFuZ1ByZWZpeDogXCJsYW5ndWFnZS1cIixcbiAgICAgICAgbGlua2lmeTogZmFsc2UsXG4gICAgICAgIHR5cG9ncmFwaGVyOiBmYWxzZSxcbiAgICAgICAgcXVvdGVzOiBcIlxcdTIwMUNcXHUyMDFEXFx1MjAxOFxcdTIwMTlcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBtYXhOZXN0aW5nOiAyMFxuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgY29yZToge1xuICAgICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICBcIm5vcm1hbGl6ZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiLFxuICAgICAgICAgICAgXCJpbmxpbmVcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJwYXJhZ3JhcGhcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgaW5saW5lOiB7XG4gICAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlczI6IFtcbiAgICAgICAgICAgIFwiYmFsYW5jZV9wYWlyc1wiLFxuICAgICAgICAgICAgXCJ0ZXh0X2NvbGxhcHNlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanNcbnZhciByZXF1aXJlX2NvbW1vbm1hcmsgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvY29tbW9ubWFyay5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICBodG1sOiB0cnVlLFxuICAgICAgICB4aHRtbE91dDogdHJ1ZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgbGFuZ1ByZWZpeDogXCJsYW5ndWFnZS1cIixcbiAgICAgICAgbGlua2lmeTogZmFsc2UsXG4gICAgICAgIHR5cG9ncmFwaGVyOiBmYWxzZSxcbiAgICAgICAgcXVvdGVzOiBcIlxcdTIwMUNcXHUyMDFEXFx1MjAxOFxcdTIwMTlcIixcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBtYXhOZXN0aW5nOiAyMFxuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgY29yZToge1xuICAgICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgICBcIm5vcm1hbGl6ZVwiLFxuICAgICAgICAgICAgXCJibG9ja1wiLFxuICAgICAgICAgICAgXCJpbmxpbmVcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYmxvY2s6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJibG9ja3F1b3RlXCIsXG4gICAgICAgICAgICBcImNvZGVcIixcbiAgICAgICAgICAgIFwiZmVuY2VcIixcbiAgICAgICAgICAgIFwiaGVhZGluZ1wiLFxuICAgICAgICAgICAgXCJoclwiLFxuICAgICAgICAgICAgXCJodG1sX2Jsb2NrXCIsXG4gICAgICAgICAgICBcImxoZWFkaW5nXCIsXG4gICAgICAgICAgICBcImxpc3RcIixcbiAgICAgICAgICAgIFwicmVmZXJlbmNlXCIsXG4gICAgICAgICAgICBcInBhcmFncmFwaFwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBpbmxpbmU6IHtcbiAgICAgICAgICBydWxlczogW1xuICAgICAgICAgICAgXCJhdXRvbGlua1wiLFxuICAgICAgICAgICAgXCJiYWNrdGlja3NcIixcbiAgICAgICAgICAgIFwiZW1waGFzaXNcIixcbiAgICAgICAgICAgIFwiZW50aXR5XCIsXG4gICAgICAgICAgICBcImVzY2FwZVwiLFxuICAgICAgICAgICAgXCJodG1sX2lubGluZVwiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICAgICAgXCJsaW5rXCIsXG4gICAgICAgICAgICBcIm5ld2xpbmVcIixcbiAgICAgICAgICAgIFwidGV4dFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBydWxlczI6IFtcbiAgICAgICAgICAgIFwiYmFsYW5jZV9wYWlyc1wiLFxuICAgICAgICAgICAgXCJlbXBoYXNpc1wiLFxuICAgICAgICAgICAgXCJ0ZXh0X2NvbGxhcHNlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qc1xudmFyIHJlcXVpcmVfbGliID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmVfdXRpbHMoKTtcbiAgICB2YXIgaGVscGVycyA9IHJlcXVpcmVfaGVscGVycygpO1xuICAgIHZhciBSZW5kZXJlciA9IHJlcXVpcmVfcmVuZGVyZXIoKTtcbiAgICB2YXIgUGFyc2VyQ29yZSA9IHJlcXVpcmVfcGFyc2VyX2NvcmUoKTtcbiAgICB2YXIgUGFyc2VyQmxvY2sgPSByZXF1aXJlX3BhcnNlcl9ibG9jaygpO1xuICAgIHZhciBQYXJzZXJJbmxpbmUgPSByZXF1aXJlX3BhcnNlcl9pbmxpbmUoKTtcbiAgICB2YXIgTGlua2lmeUl0ID0gcmVxdWlyZV9saW5raWZ5X2l0KCk7XG4gICAgdmFyIG1kdXJsID0gcmVxdWlyZV9tZHVybCgpO1xuICAgIHZhciBwdW55Y29kZSA9IHJlcXVpcmVfcHVueWNvZGUoKTtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgZGVmYXVsdDogcmVxdWlyZV9kZWZhdWx0KCksXG4gICAgICB6ZXJvOiByZXF1aXJlX3plcm8oKSxcbiAgICAgIGNvbW1vbm1hcms6IHJlcXVpcmVfY29tbW9ubWFyaygpXG4gICAgfTtcbiAgICB2YXIgQkFEX1BST1RPX1JFID0gL14odmJzY3JpcHR8amF2YXNjcmlwdHxmaWxlfGRhdGEpOi87XG4gICAgdmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUxpbmsodXJsKSB7XG4gICAgICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyBHT09EX0RBVEFfUkUudGVzdChzdHIpID8gdHJ1ZSA6IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gICAgdmFyIFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbXCJodHRwOlwiLCBcImh0dHBzOlwiLCBcIm1haWx0bzpcIl07XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTGluayh1cmwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuICAgICAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgICAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICAgICAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG4gICAgICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9Vbmljb2RlKHBhcnNlZC5ob3N0bmFtZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZHVybC5kZWNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCksIG1kdXJsLmRlY29kZS5kZWZhdWx0Q2hhcnMgKyBcIiVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcmtkb3duSXQzKHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXJrZG93bkl0MykpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0MyhwcmVzZXROYW1lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IHByZXNldE5hbWUgfHwge307XG4gICAgICAgICAgcHJlc2V0TmFtZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmlubGluZSA9IG5ldyBQYXJzZXJJbmxpbmUoKTtcbiAgICAgIHRoaXMuYmxvY2sgPSBuZXcgUGFyc2VyQmxvY2soKTtcbiAgICAgIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCk7XG4gICAgICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG4gICAgICB0aGlzLnZhbGlkYXRlTGluayA9IHZhbGlkYXRlTGluaztcbiAgICAgIHRoaXMubm9ybWFsaXplTGluayA9IG5vcm1hbGl6ZUxpbms7XG4gICAgICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG4gICAgICB0aGlzLnV0aWxzID0gdXRpbHM7XG4gICAgICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihwcmVzZXRzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG4gICAgICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICAgICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV07XG4gICAgICAgIGlmICghcHJlc2V0cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQgXCInICsgcHJlc2V0TmFtZSArICdcIiwgY2hlY2sgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXByZXNldHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhbid0IGJlIGVtcHR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMub3B0aW9ucykge1xuICAgICAgICBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50cykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcmVzZXRzLmNvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIGlmIChwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpIHtcbiAgICAgICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24obGlzdDIsIGlnbm9yZUludmFsaWQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0MikpIHtcbiAgICAgICAgbGlzdDIgPSBbbGlzdDJdO1xuICAgICAgfVxuICAgICAgW1wiY29yZVwiLCBcImJsb2NrXCIsIFwiaW5saW5lXCJdLmZvckVhY2goZnVuY3Rpb24oY2hhaW4pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdDIsIHRydWUpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZW5hYmxlKGxpc3QyLCB0cnVlKSk7XG4gICAgICB2YXIgbWlzc2VkID0gbGlzdDIuZmlsdGVyKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMDtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1pc3NlZC5sZW5ndGggJiYgIWlnbm9yZUludmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6IFwiICsgbWlzc2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsaXN0MiwgaWdub3JlSW52YWxpZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QyKSkge1xuICAgICAgICBsaXN0MiA9IFtsaXN0Ml07XG4gICAgICB9XG4gICAgICBbXCJjb3JlXCIsIFwiYmxvY2tcIiwgXCJpbmxpbmVcIl0uZm9yRWFjaChmdW5jdGlvbihjaGFpbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmRpc2FibGUobGlzdDIsIHRydWUpKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLmlubGluZS5ydWxlcjIuZGlzYWJsZShsaXN0MiwgdHJ1ZSkpO1xuICAgICAgdmFyIG1pc3NlZCA9IGxpc3QyLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDA7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcmtkb3duSXQuIEZhaWxlZCB0byBkaXNhYmxlIHVua25vd24gcnVsZShzKTogXCIgKyBtaXNzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNYXJrZG93bkl0My5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24ocGx1Z2luMykge1xuICAgICAgdmFyIGFyZ3MgPSBbdGhpc10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgcGx1Z2luMy5hcHBseShwbHVnaW4zLCBhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjLCBlbnYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudik7XG4gICAgICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5zO1xuICAgIH07XG4gICAgTWFya2Rvd25JdDMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNyYywgZW52KSB7XG4gICAgICBlbnYgPSBlbnYgfHwge307XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uKHNyYywgZW52KSB7XG4gICAgICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcbiAgICAgIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICAgICAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VucztcbiAgICB9O1xuICAgIE1hcmtkb3duSXQzLnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbihzcmMsIGVudikge1xuICAgICAgZW52ID0gZW52IHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQzO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9tYXJrZG93bl9pdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9saWIoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9hc3QvYmFzZS50c1xudmFyIGJhc2VfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoYmFzZV9leHBvcnRzLCB7XG4gIGdldEFzdFZhbHVlczogKCkgPT4gZ2V0QXN0VmFsdWVzLFxuICBpc0FzdDogKCkgPT4gaXNBc3QsXG4gIGlzRnVuY3Rpb246ICgpID0+IGlzRnVuY3Rpb24sXG4gIGlzVmFyaWFibGU6ICgpID0+IGlzVmFyaWFibGUsXG4gIHJlc29sdmU6ICgpID0+IHJlc29sdmVcbn0pO1xuZnVuY3Rpb24gaXNBc3QodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU/LiQkbWR0eXBlO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWU/LiQkbWR0eXBlID09PSBcIkZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWU/LiQkbWR0eXBlID09PSBcIlZhcmlhYmxlXCIpO1xufVxuZnVuY3Rpb24qIGdldEFzdFZhbHVlcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgeWllbGQqIGdldEFzdFZhbHVlcyh2KTtcbiAgaWYgKGlzQXN0KHZhbHVlKSlcbiAgICB5aWVsZCB2YWx1ZTtcbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgIT09IE9iamVjdC5wcm90b3R5cGUpXG4gICAgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpXG4gICAgeWllbGQqIGdldEFzdFZhbHVlcyh2KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUsIGNvbmZpZyA9IHt9KSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUubWFwKChpdGVtMikgPT4gcmVzb2x2ZShpdGVtMiwgY29uZmlnKSk7XG4gIGlmIChpc0FzdCh2YWx1ZSkgJiYgdmFsdWU/LnJlc29sdmUgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICByZXR1cm4gdmFsdWUucmVzb2x2ZShjb25maWcpO1xuICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSAhPT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IG91dHB1dCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpXG4gICAgb3V0cHV0W2tdID0gcmVzb2x2ZSh2LCBjb25maWcpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBzcmMvdGFnLnRzXG52YXIgVGFnID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihuYW1lID0gXCJkaXZcIiwgYXR0cmlidXRlcyA9IHt9LCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgdGhpcy4kJG1kdHlwZSA9IFwiVGFnXCI7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfVxufTtcblxuLy8gc3JjL3NjaGVtYS10eXBlcy9jbGFzcy50c1xudmFyIENsYXNzID0gY2xhc3Mge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcImF0dHJpYnV0ZS10eXBlLWludmFsaWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEF0dHJpYnV0ZSAnY2xhc3MnIG11c3QgYmUgdHlwZSAnc3RyaW5nIHwgb2JqZWN0J2BcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIHRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSA/PyB7fSkpXG4gICAgICBpZiAodilcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGspO1xuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBpbXBvcnRfdGFnID0gX190b01vZHVsZShyZXF1aXJlX3RhZygpKTtcblxuLy8gc3JjL2FzdC92YXJpYWJsZS50c1xudmFyIFZhcmlhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXRoID0gW10pIHtcbiAgICB0aGlzLiQkbWR0eXBlID0gXCJWYXJpYWJsZVwiO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbiAgcmVzb2x2ZSh7IHZhcmlhYmxlcyB9ID0ge30pIHtcbiAgICByZXR1cm4gdmFyaWFibGVzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB2YXJpYWJsZXModGhpcy5wYXRoKSA6IHRoaXMucGF0aC5yZWR1Y2UoKG9iaiA9IHt9LCBrZXkpID0+IG9ialtrZXldLCB2YXJpYWJsZXMpO1xuICB9XG59O1xuXG4vLyBzcmMvYXN0L2Z1bmN0aW9uLnRzXG52YXIgRnVuY3Rpb24yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy4kJG1kdHlwZSA9IFwiRnVuY3Rpb25cIjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gIH1cbiAgcmVzb2x2ZShjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGZuID0gY29uZmlnPy5mdW5jdGlvbnM/Llt0aGlzLm5hbWVdO1xuICAgIGlmICghZm4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gcmVzb2x2ZSh0aGlzLnBhcmFtZXRlcnMsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZuLnRyYW5zZm9ybT8uKHBhcmFtZXRlcnMsIGNvbmZpZyk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy50c1xudmFyIFNUQVRFUztcbihmdW5jdGlvbihTVEFURVMyKSB7XG4gIFNUQVRFUzJbU1RBVEVTMltcIm5vcm1hbFwiXSA9IDBdID0gXCJub3JtYWxcIjtcbiAgU1RBVEVTMltTVEFURVMyW1wic3RyaW5nXCJdID0gMV0gPSBcInN0cmluZ1wiO1xuICBTVEFURVMyW1NUQVRFUzJbXCJlc2NhcGVcIl0gPSAyXSA9IFwiZXNjYXBlXCI7XG59KShTVEFURVMgfHwgKFNUQVRFUyA9IHt9KSk7XG52YXIgT1BFTiA9IFwieyVcIjtcbnZhciBDTE9TRSA9IFwiJX1cIjtcbmZ1bmN0aW9uIGlzUHJvbWlzZShhKSB7XG4gIHJldHVybiBhICYmIHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBhLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZpbmRUYWdFbmQoY29udGVudCwgc3RhcnQgPSAwKSB7XG4gIGxldCBzdGF0ZSA9IDA7XG4gIGZvciAobGV0IHBvcyA9IHN0YXJ0OyBwb3MgPCBjb250ZW50Lmxlbmd0aDsgcG9zKyspIHtcbiAgICBjb25zdCBjaGFyID0gY29udGVudFtwb3NdO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIHN0YXRlID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoY2hhciA9PT0gJ1wiJylcbiAgICAgICAgICBzdGF0ZSA9IDE7XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQuc3RhcnRzV2l0aChDTE9TRSwgcG9zKSlcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlVGFnKGNvbnRlbnQsIGxpbmUsIGNvbnRlbnRTdGFydCkge1xuICB0cnkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3RhZy5wYXJzZSkoY29udGVudCwgeyBWYXJpYWJsZSwgRnVuY3Rpb246IEZ1bmN0aW9uMiB9KTtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgaWYgKCEoZXJyb3IyIGluc3RhbmNlb2YgaW1wb3J0X3RhZy5TeW50YXhFcnJvcikpXG4gICAgICB0aHJvdyBlcnJvcjI7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGxvY2F0aW9uOiB7IHN0YXJ0LCBlbmQgfVxuICAgIH0gPSBlcnJvcjI7XG4gICAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgICBzdGFydDogeyBsaW5lLCBjaGFyYWN0ZXI6IHN0YXJ0Lm9mZnNldCArIGNvbnRlbnRTdGFydCB9LFxuICAgICAgZW5kOiB7IGxpbmU6IGxpbmUgKyAxLCBjaGFyYWN0ZXI6IGVuZC5vZmZzZXQgKyBjb250ZW50U3RhcnQgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBtZXRhOiB7IGVycm9yOiB7IG1lc3NhZ2UsIGxvY2F0aW9uIH0gfSB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRhZ3MoY29udGVudCwgZmlyc3RMaW5lID0gMCkge1xuICBsZXQgbGluZSA9IGZpcnN0TGluZSArIDE7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBsZXQgc3RhcnQgPSAwO1xuICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBjb250ZW50Lmxlbmd0aDsgcG9zKyspIHtcbiAgICBpZiAoY29udGVudFtwb3NdID09PSBcIlxcblwiKSB7XG4gICAgICBsaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFjb250ZW50LnN0YXJ0c1dpdGgoT1BFTiwgcG9zKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGVuZCA9IGZpbmRUYWdFbmQoY29udGVudCwgcG9zKTtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIHBvcyA9IHBvcyArIE9QRU4ubGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRleHQyID0gY29udGVudC5zbGljZShwb3MsIGVuZCArIENMT1NFLmxlbmd0aCk7XG4gICAgY29uc3QgaW5uZXIgPSBjb250ZW50LnNsaWNlKHBvcyArIE9QRU4ubGVuZ3RoLCBlbmQpO1xuICAgIGNvbnN0IGxpbmVTdGFydCA9IGNvbnRlbnQubGFzdEluZGV4T2YoXCJcXG5cIiwgcG9zKTtcbiAgICBjb25zdCBsaW5lRW5kID0gY29udGVudC5pbmRleE9mKFwiXFxuXCIsIGVuZCk7XG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBjb250ZW50LnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgY29uc3QgdGFnID0gcGFyc2VUYWcoaW5uZXIudHJpbSgpLCBsaW5lLCBwb3MgLSBsaW5lU3RhcnQpO1xuICAgIGNvbnN0IHByZWNlZGluZ1RleHRFbmQgPSBsaW5lQ29udGVudC50cmltKCkgPT09IHRleHQyID8gbGluZVN0YXJ0IDogcG9zO1xuICAgIGNvbnN0IHByZWNlZGluZ1RleHQgPSBjb250ZW50LnNsaWNlKHN0YXJ0LCBwcmVjZWRpbmdUZXh0RW5kKTtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBwb3MgLSAxLFxuICAgICAgY29udGVudDogcHJlY2VkaW5nVGV4dFxuICAgIH0pO1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIG1hcDogW2xpbmUsIGxpbmUgKyAxXSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwb3MgLSBsaW5lU3RhcnQsXG4gICAgICAgIGVuZDogcG9zIC0gbGluZVN0YXJ0ICsgdGV4dDIubGVuZ3RoXG4gICAgICB9LFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zICsgdGV4dDIubGVuZ3RoIC0gMSxcbiAgICAgIGluZm86IHRleHQyLFxuICAgICAgLi4udGFnXG4gICAgfSk7XG4gICAgc3RhcnQgPSBlbmQgKyBDTE9TRS5sZW5ndGg7XG4gICAgcG9zID0gc3RhcnQgLSAxO1xuICB9XG4gIG91dHB1dC5wdXNoKHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBzdGFydCxcbiAgICBlbmQ6IGNvbnRlbnQubGVuZ3RoIC0gMSxcbiAgICBjb250ZW50OiBjb250ZW50LnNsaWNlKHN0YXJ0KVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybWVyLnRzXG52YXIgZ2xvYmFsQXR0cmlidXRlcyA9IHtcbiAgY2xhc3M6IHsgdHlwZTogQ2xhc3MsIHJlbmRlcjogdHJ1ZSB9LFxuICBpZDogeyB0eXBlOiBTdHJpbmcsIHJlbmRlcjogdHJ1ZSB9XG59O1xudmFyIHRyYW5zZm9ybWVyX2RlZmF1bHQgPSB7XG4gIGZpbmRTY2hlbWEobm9kZTIsIHsgbm9kZXMgPSB7fSwgdGFncyA9IHt9IH0gPSB7fSkge1xuICAgIHJldHVybiBub2RlMi50YWcgPyB0YWdzW25vZGUyLnRhZ10gOiBub2Rlc1tub2RlMi50eXBlXTtcbiAgfSxcbiAgYXR0cmlidXRlcyhub2RlMiwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmZpbmRTY2hlbWEobm9kZTIsIGNvbmZpZykgPz8ge307XG4gICAgY29uc3Qgb3V0cHV0ID0ge307XG4gICAgY29uc3QgYXR0cnMgPSB7IC4uLmdsb2JhbEF0dHJpYnV0ZXMsIC4uLnNjaGVtYS5hdHRyaWJ1dGVzIH07XG4gICAgZm9yIChjb25zdCBba2V5LCBhdHRyXSBvZiBPYmplY3QuZW50cmllcyhhdHRycykpIHtcbiAgICAgIGlmIChhdHRyLnJlbmRlciA9PSBmYWxzZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGF0dHIucmVuZGVyID09PSBcInN0cmluZ1wiID8gYXR0ci5yZW5kZXIgOiBrZXk7XG4gICAgICBsZXQgdmFsdWUgPSBub2RlMi5hdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGF0dHIudHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGF0dHIudHlwZSgpO1xuICAgICAgICBpZiAoaW5zdGFuY2UudHJhbnNmb3JtKSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnN0YW5jZS50cmFuc2Zvcm0odmFsdWUsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IHZvaWQgMCA/IGF0dHIuZGVmYXVsdCA6IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgb3V0cHV0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG4gIGNoaWxkcmVuKG5vZGUyLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZTIuY2hpbGRyZW4uZmxhdE1hcCgoY2hpbGQpID0+IHRoaXMubm9kZShjaGlsZCwgY29uZmlnKSk7XG4gICAgaWYgKGNoaWxkcmVuLnNvbWUoaXNQcm9taXNlKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBub2RlKG5vZGUyLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuZmluZFNjaGVtYShub2RlMiwgY29uZmlnKSA/PyB7fTtcbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS50cmFuc2Zvcm0gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgIHJldHVybiBzY2hlbWEudHJhbnNmb3JtKG5vZGUyLCBjb25maWcpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbihub2RlMiwgY29uZmlnKTtcbiAgICBpZiAoIXNjaGVtYSB8fCAhc2NoZW1hLnJlbmRlcilcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzKG5vZGUyLCBjb25maWcpO1xuICAgIGlmIChpc1Byb21pc2UoYXR0cmlidXRlcykgfHwgaXNQcm9taXNlKGNoaWxkcmVuKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFthdHRyaWJ1dGVzLCBjaGlsZHJlbl0pLnRoZW4oKHZhbHVlcykgPT4gbmV3IFRhZyhzY2hlbWEucmVuZGVyLCAuLi52YWx1ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUYWcoc2NoZW1hLnJlbmRlciwgYXR0cmlidXRlcywgY2hpbGRyZW4pO1xuICB9XG59O1xuXG4vLyBzcmMvYXN0L25vZGUudHNcbnZhciBOb2RlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlID0gXCJub2RlXCIsIGF0dHJpYnV0ZXMgPSB7fSwgY2hpbGRyZW4gPSBbXSwgdGFnKSB7XG4gICAgdGhpcy4kJG1kdHlwZSA9IFwiTm9kZVwiO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMuaW5saW5lID0gZmFsc2U7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmFubm90YXRpb25zID0gW107XG4gIH1cbiAgKndhbGsoKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICB5aWVsZCBjaGlsZDtcbiAgICAgIHlpZWxkKiBjaGlsZC53YWxrKCk7XG4gICAgfVxuICB9XG4gIHB1c2gobm9kZTIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gobm9kZTIpO1xuICB9XG4gIHJlc29sdmUoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgTm9kZSgpLCB0aGlzLCB7XG4gICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5yZXNvbHZlKGNvbmZpZykpLFxuICAgICAgYXR0cmlidXRlczogcmVzb2x2ZSh0aGlzLmF0dHJpYnV0ZXMsIGNvbmZpZylcbiAgICB9KTtcbiAgfVxuICBmaW5kU2NoZW1hKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQuZmluZFNjaGVtYSh0aGlzLCBjb25maWcpO1xuICB9XG4gIHRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXJfZGVmYXVsdC5hdHRyaWJ1dGVzKHRoaXMsIGNvbmZpZyk7XG4gIH1cbiAgdHJhbnNmb3JtQ2hpbGRyZW4oY29uZmlnKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQuY2hpbGRyZW4odGhpcywgY29uZmlnKTtcbiAgfVxuICB0cmFuc2Zvcm0oY29uZmlnKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyX2RlZmF1bHQubm9kZSh0aGlzLCBjb25maWcpO1xuICB9XG59O1xuXG4vLyBzcmMvYXN0L2luZGV4LnRzXG52YXIgQXN0VHlwZXMgPSB7XG4gIEZ1bmN0aW9uOiBGdW5jdGlvbjIsXG4gIE5vZGUsXG4gIFZhcmlhYmxlXG59O1xuZnVuY3Rpb24gcmV2aXZlcihfLCB2YWx1ZSkge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgY29uc3Qga2xhc3MgPSBBc3RUeXBlc1t2YWx1ZS4kJG1kdHlwZV07XG4gIHJldHVybiBrbGFzcyA/IE9iamVjdC5hc3NpZ24obmV3IGtsYXNzKCksIHZhbHVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZnJvbUpTT04odGV4dDIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UodGV4dDIsIHJldml2ZXIpO1xufVxudmFyIGFzdF9kZWZhdWx0ID0ge1xuICAuLi5Bc3RUeXBlcyxcbiAgLi4uYmFzZV9leHBvcnRzLFxuICBmcm9tSlNPTlxufTtcblxuLy8gc3JjL2Zvcm1hdHRlci50c1xudmFyIFNQQUNFID0gXCIgXCI7XG52YXIgU0VQID0gXCIsIFwiO1xudmFyIE5MID0gXCJcXG5cIjtcbnZhciBPTCA9IFwiMS4gXCI7XG52YXIgVUwgPSBcIi0gXCI7XG52YXIgTUFYX1RBR19PUEVOSU5HX1dJRFRIID0gODA7XG52YXIgbWF4ID0gKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpO1xudmFyIGluY3JlbWVudCA9IChvLCBuID0gMikgPT4gKHtcbiAgLi4ubyxcbiAgaW5kZW50OiAoby5pbmRlbnQgfHwgMCkgKyBuXG59KTtcbmZ1bmN0aW9uKiBmb3JtYXRDaGlsZHJlbihhLCBvcHRpb25zKSB7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgYS5jaGlsZHJlbikge1xuICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShjaGlsZCwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uKiBmb3JtYXRUYWJsZVJvdyhpdGVtcykge1xuICB5aWVsZCBgfCAke2l0ZW1zLmpvaW4oXCIgfCBcIil9IHxgO1xufVxuZnVuY3Rpb24gZm9ybWF0U2NhbGFyKHYpIHtcbiAgaWYgKGFzdF9kZWZhdWx0LmlzQXN0KHYpKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh2KTtcbiAgfVxuICBpZiAodiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgdi5tYXAoZm9ybWF0U2NhbGFyKS5qb2luKFNFUCkgKyBcIl1cIjtcbiAgfVxuICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gXCJ7XCIgKyBPYmplY3QuZW50cmllcyh2KS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fTogJHtmb3JtYXRTY2FsYXIodmFsdWUpfWApLmpvaW4oU0VQKSArIFwifVwiO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFubm90YXRpb25WYWx1ZShhKSB7XG4gIGlmIChhLm5hbWUgPT09IFwicHJpbWFyeVwiKVxuICAgIHJldHVybiBmb3JtYXRTY2FsYXIoYS52YWx1ZSk7XG4gIGlmIChhLm5hbWUgPT09IFwiaWRcIiAmJiB0eXBlb2YgYS52YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gXCIjXCIgKyBhLnZhbHVlO1xuICBpZiAoYS50eXBlID09PSBcImNsYXNzXCIpXG4gICAgcmV0dXJuIFwiLlwiICsgYS5uYW1lO1xuICByZXR1cm4gYCR7YS5uYW1lfT0ke2Zvcm1hdFNjYWxhcihhLnZhbHVlKX1gO1xufVxuZnVuY3Rpb24qIGZvcm1hdEF0dHJpYnV0ZXMobikge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhuLmF0dHJpYnV0ZXMpKSB7XG4gICAgaWYgKGtleSA9PT0gXCJjbGFzc1wiICYmICFhc3RfZGVmYXVsdC5pc0FzdCh2YWx1ZSkpXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgIHlpZWxkIGZvcm1hdEFubm90YXRpb25WYWx1ZSh7IHR5cGU6IFwiY2xhc3NcIiwgbmFtZSwgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgeWllbGQgZm9ybWF0QW5ub3RhdGlvblZhbHVlKHsgdHlwZTogXCJhdHRyaWJ1dGVcIiwgbmFtZToga2V5LCB2YWx1ZSB9KTtcbiAgfVxufVxuZnVuY3Rpb24qIGZvcm1hdEFubm90YXRpb25zKG4pIHtcbiAgaWYgKG4uYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgeWllbGQgT1BFTiArIFNQQUNFO1xuICAgIHlpZWxkIG4uYW5ub3RhdGlvbnMubWFwKGZvcm1hdEFubm90YXRpb25WYWx1ZSkuam9pbihTUEFDRSk7XG4gICAgeWllbGQgU1BBQ0UgKyBDTE9TRTtcbiAgfVxufVxuZnVuY3Rpb24qIGZvcm1hdFZhcmlhYmxlKHYpIHtcbiAgeWllbGQgXCIkXCI7XG4gIHlpZWxkIHYucGF0aC5qb2luKFwiLlwiKTtcbn1cbmZ1bmN0aW9uKiBmb3JtYXRGdW5jdGlvbihmKSB7XG4gIHlpZWxkIGYubmFtZTtcbiAgeWllbGQgXCIoXCI7XG4gIHlpZWxkIE9iamVjdC52YWx1ZXMoZi5wYXJhbWV0ZXJzKS5tYXAoZm9ybWF0U2NhbGFyKS5qb2luKFNFUCk7XG4gIHlpZWxkIFwiKVwiO1xufVxuZnVuY3Rpb24qIHRyaW1TdGFydChnKSB7XG4gIGxldCBuO1xuICBkbyB7XG4gICAgbiA9IGcubmV4dCgpLnZhbHVlLnRyaW1TdGFydCgpO1xuICB9IHdoaWxlICghbi5sZW5ndGgpO1xuICB5aWVsZCBuO1xuICB5aWVsZCogZztcbn1cbmZ1bmN0aW9uKiBmb3JtYXROb2RlKG4sIG8gPSB7fSkge1xuICBjb25zdCBubyA9IHsgLi4ubywgcGFyZW50OiBuIH07XG4gIGNvbnN0IGluZGVudCA9IFNQQUNFLnJlcGVhdChuby5pbmRlbnQgfHwgMCk7XG4gIHN3aXRjaCAobi50eXBlKSB7XG4gICAgY2FzZSBcImRvY3VtZW50XCI6IHtcbiAgICAgIGlmIChuLmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIgJiYgbi5hdHRyaWJ1dGVzLmZyb250bWF0dGVyLmxlbmd0aCkge1xuICAgICAgICB5aWVsZCBcIi0tLVwiICsgTkwgKyBuLmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIgKyBOTCArIFwiLS0tXCIgKyBOTCArIE5MO1xuICAgICAgfVxuICAgICAgeWllbGQqIHRyaW1TdGFydChmb3JtYXRDaGlsZHJlbihuLCBubykpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJoZWFkaW5nXCI6IHtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgeWllbGQgXCIjXCIucmVwZWF0KG4uYXR0cmlidXRlcy5sZXZlbCB8fCAxKTtcbiAgICAgIHlpZWxkIFNQQUNFO1xuICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vKTtcbiAgICAgIHlpZWxkKiBmb3JtYXRBbm5vdGF0aW9ucyhuKTtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJwYXJhZ3JhcGhcIjoge1xuICAgICAgeWllbGQgTkw7XG4gICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICB5aWVsZCogZm9ybWF0Q2hpbGRyZW4obiwgbm8pO1xuICAgICAgeWllbGQqIGZvcm1hdEFubm90YXRpb25zKG4pO1xuICAgICAgeWllbGQgTkw7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImlubGluZVwiOiB7XG4gICAgICB5aWVsZCogZm9ybWF0Q2hpbGRyZW4obiwgbm8pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJsaW5rXCI6IHtcbiAgICAgIHlpZWxkIFwiW1wiO1xuICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vKTtcbiAgICAgIHlpZWxkIFwiXVwiO1xuICAgICAgeWllbGQgXCIoXCI7XG4gICAgICB5aWVsZCogZm9ybWF0VmFsdWUobi5hdHRyaWJ1dGVzLmhyZWYsIG5vKTtcbiAgICAgIHlpZWxkIFwiKVwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgIGlmIChhc3RfZGVmYXVsdC5pc0FzdChuLmF0dHJpYnV0ZXMuY29udGVudCkpXG4gICAgICAgIHlpZWxkIE9QRU4gKyBTUEFDRTtcbiAgICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShuLmF0dHJpYnV0ZXMuY29udGVudCwgbm8pO1xuICAgICAgaWYgKGFzdF9kZWZhdWx0LmlzQXN0KG4uYXR0cmlidXRlcy5jb250ZW50KSlcbiAgICAgICAgeWllbGQgU1BBQ0UgKyBDTE9TRTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYmxvY2txdW90ZVwiOiB7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIHlpZWxkIFwiPiBcIjtcbiAgICAgIHlpZWxkKiB0cmltU3RhcnQoZm9ybWF0Q2hpbGRyZW4obiwgbm8pKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaHJcIjoge1xuICAgICAgeWllbGQgTkw7XG4gICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICB5aWVsZCBcIi0tLVwiO1xuICAgICAgeWllbGQgTkw7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIHlpZWxkIFwiIVwiO1xuICAgICAgeWllbGQgXCJbXCI7XG4gICAgICB5aWVsZCogZm9ybWF0VmFsdWUobi5hdHRyaWJ1dGVzLmFsdCwgbm8pO1xuICAgICAgeWllbGQgXCJdXCI7XG4gICAgICB5aWVsZCBcIihcIjtcbiAgICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShuLmF0dHJpYnV0ZXMuc3JjLCBubyk7XG4gICAgICB5aWVsZCBcIilcIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZmVuY2VcIjoge1xuICAgICAgeWllbGQgTkw7XG4gICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICB5aWVsZCBcImBgYFwiO1xuICAgICAgeWllbGQgKG4uYXR0cmlidXRlcy5sYW5ndWFnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG4uYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgICAgICB5aWVsZCBTUEFDRTtcbiAgICAgIHlpZWxkKiBmb3JtYXRBbm5vdGF0aW9ucyhuKTtcbiAgICAgIHlpZWxkIE5MO1xuICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vKTtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIHlpZWxkIFwiYGBgXCI7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGFnXCI6IHtcbiAgICAgIGlmICghbi5pbmxpbmUpIHtcbiAgICAgICAgeWllbGQgTkw7XG4gICAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZW4gPSBPUEVOICsgU1BBQ0U7XG4gICAgICBjb25zdCB0YWcgPSBbb3BlbiArIG4udGFnLCAuLi5mb3JtYXRBdHRyaWJ1dGVzKG4pXTtcbiAgICAgIGNvbnN0IGlubGluZVRhZyA9IHRhZy5qb2luKFNQQUNFKTtcbiAgICAgIGNvbnN0IGlzTG9uZ1RhZ09wZW5pbmcgPSBpbmxpbmVUYWcubGVuZ3RoICsgb3Blbi5sZW5ndGggKiAyID4gKG8ubWF4VGFnT3BlbmluZ1dpZHRoIHx8IE1BWF9UQUdfT1BFTklOR19XSURUSCk7XG4gICAgICB5aWVsZCAoaXNMb25nVGFnT3BlbmluZyA/IHRhZy5qb2luKE5MICsgU1BBQ0UucmVwZWF0KG9wZW4ubGVuZ3RoKSArIGluZGVudCkgOiBpbmxpbmVUYWcpICsgU1BBQ0UgKyAobi5jaGlsZHJlbi5sZW5ndGggPyBcIlwiIDogXCIvXCIpICsgQ0xPU0U7XG4gICAgICBpZiAobi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vLmFsbG93SW5kZW50YXRpb24gPyBpbmNyZW1lbnQobm8pIDogbm8pO1xuICAgICAgICBpZiAoIW4uaW5saW5lKSB7XG4gICAgICAgICAgeWllbGQgaW5kZW50O1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIE9QRU4gKyBTUEFDRSArIFwiL1wiICsgbi50YWcgKyBTUEFDRSArIENMT1NFO1xuICAgICAgfVxuICAgICAgaWYgKCFuLmlubGluZSkge1xuICAgICAgICB5aWVsZCBOTDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibGlzdFwiOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBuLmF0dHJpYnV0ZXMub3JkZXJlZCA/IE9MIDogVUw7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbi5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkID0gZm9ybWF0KGNoaWxkLCBpbmNyZW1lbnQobm8sIHByZWZpeC5sZW5ndGgpKS50cmltKCk7XG4gICAgICAgIHlpZWxkIGluZGVudCArIHByZWZpeCArIGQ7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpdGVtXCI6IHtcbiAgICAgIHlpZWxkKiBmb3JtYXRDaGlsZHJlbihuLCBubyk7XG4gICAgICB5aWVsZCogZm9ybWF0QW5ub3RhdGlvbnMobik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInN0cm9uZ1wiOiB7XG4gICAgICB5aWVsZCBcIioqXCI7XG4gICAgICB5aWVsZCogZm9ybWF0Q2hpbGRyZW4obiwgbm8pO1xuICAgICAgeWllbGQgXCIqKlwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJlbVwiOiB7XG4gICAgICB5aWVsZCBcIl9cIjtcbiAgICAgIHlpZWxkKiBmb3JtYXRDaGlsZHJlbihuLCBubyk7XG4gICAgICB5aWVsZCBcIl9cIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiY29kZVwiOiB7XG4gICAgICB5aWVsZCBcImBcIjtcbiAgICAgIHlpZWxkKiBmb3JtYXRWYWx1ZShuLmF0dHJpYnV0ZXMuY29udGVudCwgbm8pO1xuICAgICAgeWllbGQgXCJgXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgeWllbGQgXCJ+flwiO1xuICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vKTtcbiAgICAgIHlpZWxkIFwifn5cIjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaGFyZGJyZWFrXCI6IHtcbiAgICAgIHlpZWxkIFwiXFxcXFwiICsgTkw7XG4gICAgICB5aWVsZCBpbmRlbnQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNvZnRicmVha1wiOiB7XG4gICAgICB5aWVsZCBOTDtcbiAgICAgIHlpZWxkIGluZGVudDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGFibGVcIjoge1xuICAgICAgY29uc3QgdGFibGUzID0gWy4uLmZvcm1hdENoaWxkcmVuKG4sIGluY3JlbWVudChubykpXTtcbiAgICAgIGlmIChvLnBhcmVudCAmJiBvLnBhcmVudC50eXBlID09PSBcInRhZ1wiICYmIG8ucGFyZW50LnRhZyA9PT0gXCJ0YWJsZVwiKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGUzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgcm93ID0gdGFibGUzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2Ygcm93ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocm93LnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgeWllbGQgTkw7XG4gICAgICAgICAgICAgIHlpZWxkIHJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgICAgeWllbGQgTkw7XG4gICAgICAgICAgICAgIHlpZWxkIGluZGVudCArIFwiLS0tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCBkID0gcm93W2pdO1xuICAgICAgICAgICAgICB5aWVsZCBOTDtcbiAgICAgICAgICAgICAgeWllbGQgaW5kZW50ICsgVUwgKyBkLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgTkw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBOTDtcbiAgICAgICAgY29uc3QgW2hlYWQsIC4uLnJvd3NdID0gdGFibGUzO1xuICAgICAgICBjb25zdCBtbCA9IHRhYmxlMy5tYXAoKGFycikgPT4gYXJyLm1hcCgoczIpID0+IHMyLmxlbmd0aCkucmVkdWNlKG1heCkpLnJlZHVjZShtYXgpO1xuICAgICAgICB5aWVsZCogZm9ybWF0VGFibGVSb3coaGVhZC5tYXAoKGgpID0+IGggKyBTUEFDRS5yZXBlYXQobWwgLSBoLmxlbmd0aCkpKTtcbiAgICAgICAgeWllbGQgTkw7XG4gICAgICAgIHlpZWxkKiBmb3JtYXRUYWJsZVJvdyhoZWFkLm1hcCgoKSA9PiBcIi1cIi5yZXBlYXQobWwpKSk7XG4gICAgICAgIHlpZWxkIE5MO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgeWllbGQqIGZvcm1hdFRhYmxlUm93KHJvdy5tYXAoKHIpID0+IHIgKyBTUEFDRS5yZXBlYXQobWwgLSByLmxlbmd0aCkpKTtcbiAgICAgICAgICB5aWVsZCBOTDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0aGVhZFwiOiB7XG4gICAgICBjb25zdCBbaGVhZF0gPSBbLi4uZm9ybWF0Q2hpbGRyZW4obiwgbm8pXTtcbiAgICAgIHlpZWxkIGhlYWQgfHwgW107XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRyXCI6IHtcbiAgICAgIHlpZWxkIFsuLi5mb3JtYXRDaGlsZHJlbihuLCBubyldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0ZFwiOlxuICAgIGNhc2UgXCJ0aFwiOiB7XG4gICAgICB5aWVsZCBbLi4uZm9ybWF0Q2hpbGRyZW4obiwgbm8pLCAuLi5mb3JtYXRBbm5vdGF0aW9ucyhuKV0uam9pbihcIlwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGJvZHlcIjoge1xuICAgICAgeWllbGQqIGZvcm1hdENoaWxkcmVuKG4sIG5vKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgY29uc29sZS5lcnJvcihuKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uKiBmb3JtYXRWYWx1ZSh2LCBvID0ge30pIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgeWllbGQgdi50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgaWYgKHYgPT09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIHYpXG4gICAgICAgICAgeWllbGQqIGZvcm1hdFZhbHVlKG4sIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodi4kJG1kdHlwZSkge1xuICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjoge1xuICAgICAgICAgIHlpZWxkKiBmb3JtYXRGdW5jdGlvbih2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTm9kZVwiOlxuICAgICAgICAgIHlpZWxkKiBmb3JtYXROb2RlKHYsIG8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVmFyaWFibGVcIjoge1xuICAgICAgICAgIHlpZWxkKiBmb3JtYXRWYXJpYWJsZSh2KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pbXBsZW1lbnRlZDogXCIke3YuJCRtZHR5cGV9XCJgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0KHYsIG9wdGlvbnMpIHtcbiAgbGV0IGRvYyA9IFwiXCI7XG4gIGZvciAoY29uc3QgczIgb2YgZm9ybWF0VmFsdWUodiwgb3B0aW9ucykpXG4gICAgZG9jICs9IHMyO1xuICByZXR1cm4gZG9jLnRyaW1TdGFydCgpO1xufVxuXG4vLyBzcmMvdGFncy9jb25kaXRpb25hbC50c1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlbmRlckNvbmRpdGlvbnMobm9kZTIpIHtcbiAgY29uc3QgY29uZGl0aW9ucyA9IFtcbiAgICB7IGNvbmRpdGlvbjogbm9kZTIuYXR0cmlidXRlcy5wcmltYXJ5LCBjaGlsZHJlbjogW10gfVxuICBdO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUyLmNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwidGFnXCIgJiYgY2hpbGQudGFnID09PSBcImVsc2VcIilcbiAgICAgIGNvbmRpdGlvbnMucHVzaCh7XG4gICAgICAgIGNvbmRpdGlvbjogXCJwcmltYXJ5XCIgaW4gY2hpbGQuYXR0cmlidXRlcyA/IGNoaWxkLmF0dHJpYnV0ZXMucHJpbWFyeSA6IHRydWUsXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgY29uZGl0aW9uc1tjb25kaXRpb25zLmxlbmd0aCAtIDFdLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG4gIHJldHVybiBjb25kaXRpb25zO1xufVxudmFyIHRhZ0lmID0ge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgcHJpbWFyeTogeyB0eXBlOiBPYmplY3QsIHJlbmRlcjogZmFsc2UgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIGNvbnN0IGNvbmRpdGlvbnMgPSByZW5kZXJDb25kaXRpb25zKG5vZGUyKTtcbiAgICBmb3IgKGNvbnN0IHsgY29uZGl0aW9uLCBjaGlsZHJlbiB9IG9mIGNvbmRpdGlvbnMpXG4gICAgICBpZiAodHJ1dGh5KGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbi5mbGF0TWFwKChjaGlsZCkgPT4gY2hpbGQudHJhbnNmb3JtKGNvbmZpZykpO1xuICAgICAgICBpZiAobm9kZXMuc29tZShpc1Byb21pc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG5vZGVzKS50aGVuKChub2RlczIpID0+IG5vZGVzMi5mbGF0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbn07XG52YXIgdGFnRWxzZSA9IHtcbiAgc2VsZkNsb3Npbmc6IHRydWUsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBwcmltYXJ5OiB7IHR5cGU6IE9iamVjdCwgcmVuZGVyOiBmYWxzZSB9XG4gIH1cbn07XG5cbi8vIHNyYy9mdW5jdGlvbnMvaW5kZXgudHNcbnZhciBhbmQgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykuZXZlcnkoKHgpID0+IHRydXRoeSh4KSk7XG4gIH1cbn07XG52YXIgb3IgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykuZmluZCgoeCkgPT4gdHJ1dGh5KHgpKSAhPT0gdm9pZCAwO1xuICB9XG59O1xudmFyIG5vdCA9IHtcbiAgcGFyYW1ldGVyczoge1xuICAgIDA6IHsgcmVxdWlyZWQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0ocGFyYW1ldGVycykge1xuICAgIHJldHVybiAhdHJ1dGh5KHBhcmFtZXRlcnNbMF0pO1xuICB9XG59O1xudmFyIGVxdWFscyA9IHtcbiAgdHJhbnNmb3JtKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoKHYpID0+IHYgPT09IHZhbHVlc1swXSk7XG4gIH1cbn07XG52YXIgZGVidWcgPSB7XG4gIHRyYW5zZm9ybShwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtZXRlcnNbMF0sIG51bGwsIDIpO1xuICB9XG59O1xudmFyIGRlZmF1bHRGbiA9IHtcbiAgdHJhbnNmb3JtKHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gcGFyYW1ldGVyc1swXSA9PT0gdm9pZCAwID8gcGFyYW1ldGVyc1sxXSA6IHBhcmFtZXRlcnNbMF07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25zX2RlZmF1bHQgPSB7IGFuZCwgb3IsIG5vdCwgZXF1YWxzLCBkZWZhdWx0OiBkZWZhdWx0Rm4sIGRlYnVnIH07XG5cbi8vIHNyYy90cmFuc2Zvcm1zL3RhYmxlLnRzXG5mdW5jdGlvbiBjb252ZXJ0VG9Sb3cobm9kZTIsIGNlbGxUeXBlID0gXCJ0ZFwiKSB7XG4gIG5vZGUyLnR5cGUgPSBcInRyXCI7XG4gIG5vZGUyLmF0dHJpYnV0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBjZWxsIG9mIG5vZGUyLmNoaWxkcmVuKVxuICAgIGNlbGwudHlwZSA9IGNlbGxUeXBlO1xuICByZXR1cm4gbm9kZTI7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZG9jdW1lbnQyKSB7XG4gIGZvciAoY29uc3Qgbm9kZTIgb2YgZG9jdW1lbnQyLndhbGsoKSkge1xuICAgIGlmIChub2RlMi50eXBlICE9PSBcInRhZ1wiIHx8IG5vZGUyLnRhZyAhPT0gXCJ0YWJsZVwiKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgW2ZpcnN0LCAuLi5yZXN0XSA9IG5vZGUyLmNoaWxkcmVuO1xuICAgIGlmICghZmlyc3QgfHwgZmlyc3QudHlwZSA9PT0gXCJ0YWJsZVwiKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgdGFibGUzID0gbmV3IGFzdF9kZWZhdWx0Lk5vZGUoXCJ0YWJsZVwiLCBub2RlMi5hdHRyaWJ1dGVzLCBbXG4gICAgICBuZXcgYXN0X2RlZmF1bHQuTm9kZShcInRoZWFkXCIpLFxuICAgICAgbmV3IGFzdF9kZWZhdWx0Lk5vZGUoXCJ0Ym9keVwiKVxuICAgIF0pO1xuICAgIGNvbnN0IFt0aGVhZDIsIHRib2R5Ml0gPSB0YWJsZTMuY2hpbGRyZW47XG4gICAgaWYgKGZpcnN0LnR5cGUgPT09IFwibGlzdFwiKVxuICAgICAgdGhlYWQyLnB1c2goY29udmVydFRvUm93KGZpcnN0LCBcInRoXCIpKTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiByZXN0KSB7XG4gICAgICBpZiAocm93LnR5cGUgPT09IFwibGlzdFwiKVxuICAgICAgICBjb252ZXJ0VG9Sb3cocm93KTtcbiAgICAgIGVsc2UgaWYgKHJvdy50eXBlID09PSBcInRhZ1wiICYmIHJvdy50YWcgPT09IFwiaWZcIikge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvdy5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImhyXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJsaXN0XCIpXG4gICAgICAgICAgICBjb252ZXJ0VG9Sb3coY2hpbGQpO1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJvdy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGJvZHkyLnB1c2gocm93KTtcbiAgICB9XG4gICAgbm9kZTIuY2hpbGRyZW4gPSBbdGFibGUzXTtcbiAgfVxufVxuXG4vLyBzcmMvdHJhbnNmb3Jtcy9pbmRleC50c1xudmFyIHRyYW5zZm9ybXNfZGVmYXVsdCA9IFt0cmFuc2Zvcm1dO1xuXG4vLyBzcmMvcGFyc2VyLnRzXG52YXIgbWFwcGluZ3MgPSB7XG4gIG9yZGVyZWRfbGlzdDogXCJsaXN0XCIsXG4gIGJ1bGxldF9saXN0OiBcImxpc3RcIixcbiAgY29kZV9pbmxpbmU6IFwiY29kZVwiLFxuICBsaXN0X2l0ZW06IFwiaXRlbVwiLFxuICB2YXJpYWJsZTogXCJ0ZXh0XCJcbn07XG5mdW5jdGlvbiBhbm5vdGF0ZShub2RlMiwgYXR0cmlidXRlcykge1xuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgbm9kZTIuYW5ub3RhdGlvbnMucHVzaChhdHRyaWJ1dGUpO1xuICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUsIHR5cGUgfSA9IGF0dHJpYnV0ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJhdHRyaWJ1dGVcIilcbiAgICAgIG5vZGUyLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICBlbHNlIGlmICh0eXBlID09PSBcImNsYXNzXCIpXG4gICAgICBpZiAobm9kZTIuYXR0cmlidXRlcy5jbGFzcylcbiAgICAgICAgbm9kZTIuYXR0cmlidXRlcy5jbGFzc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgZWxzZVxuICAgICAgICBub2RlMi5hdHRyaWJ1dGVzLmNsYXNzID0geyBbbmFtZV06IHZhbHVlIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUF0dHJzKHRva2VuLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJoZWFkaW5nXCI6XG4gICAgICByZXR1cm4geyBsZXZlbDogTnVtYmVyKHRva2VuLnRhZy5yZXBsYWNlKFwiaFwiLCBcIlwiKSkgfTtcbiAgICBjYXNlIFwibGlzdFwiOlxuICAgICAgcmV0dXJuIHsgb3JkZXJlZDogdG9rZW4udHlwZS5zdGFydHNXaXRoKFwib3JkZXJlZFwiKSB9O1xuICAgIGNhc2UgXCJsaW5rXCI6IHtcbiAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRva2VuLmF0dHJzKTtcbiAgICAgIHJldHVybiBhdHRycy50aXRsZSA/IHsgaHJlZjogYXR0cnMuaHJlZiwgdGl0bGU6IGF0dHJzLnRpdGxlIH0gOiB7IGhyZWY6IGF0dHJzLmhyZWYgfTtcbiAgICB9XG4gICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmZyb21FbnRyaWVzKHRva2VuLmF0dHJzKTtcbiAgICAgIHJldHVybiBhdHRycy50aXRsZSA/IHsgYWx0OiB0b2tlbi5jb250ZW50LCBzcmM6IGF0dHJzLnNyYywgdGl0bGU6IGF0dHJzLnRpdGxlIH0gOiB7IGFsdDogdG9rZW4uY29udGVudCwgc3JjOiBhdHRycy5zcmMgfTtcbiAgICB9XG4gICAgY2FzZSBcInRleHRcIjpcbiAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgcmV0dXJuIHsgY29udGVudDogKHRva2VuLm1ldGEgfHwge30pLnZhcmlhYmxlIHx8IHRva2VuLmNvbnRlbnQgfTtcbiAgICBjYXNlIFwiZmVuY2VcIjoge1xuICAgICAgY29uc3QgW2xhbmd1YWdlXSA9IHRva2VuLmluZm8uc3BsaXQoXCIgXCIsIDEpO1xuICAgICAgcmV0dXJuIGxhbmd1YWdlID09PSBcIlwiID8geyBjb250ZW50OiB0b2tlbi5jb250ZW50IH0gOiB7IGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQsIGxhbmd1YWdlIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0ZFwiOlxuICAgIGNhc2UgXCJ0aFwiOiB7XG4gICAgICBpZiAodG9rZW4uYXR0cnMpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBPYmplY3QuZnJvbUVudHJpZXModG9rZW4uYXR0cnMpO1xuICAgICAgICBsZXQgYWxpZ247XG4gICAgICAgIGlmIChhdHRycy5zdHlsZSkge1xuICAgICAgICAgIGlmIChhdHRycy5zdHlsZS5pbmNsdWRlcyhcImxlZnRcIikpIHtcbiAgICAgICAgICAgIGFsaWduID0gXCJsZWZ0XCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRycy5zdHlsZS5pbmNsdWRlcyhcImNlbnRlclwiKSkge1xuICAgICAgICAgICAgYWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0cnMuc3R5bGUuaW5jbHVkZXMoXCJyaWdodFwiKSkge1xuICAgICAgICAgICAgYWxpZ24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlnbikge1xuICAgICAgICAgIHJldHVybiB7IGFsaWduIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7fTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlVG9rZW4odG9rZW4sIG5vZGVzLCBmaWxlLCBpbmxpbmVQYXJlbnQpIHtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFwiZnJvbnRtYXR0ZXJcIikge1xuICAgIG5vZGVzWzBdLmF0dHJpYnV0ZXMuZnJvbnRtYXR0ZXIgPSB0b2tlbi5jb250ZW50O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodG9rZW4uaGlkZGVuIHx8IHRva2VuLnR5cGUgPT09IFwidGV4dFwiICYmIHRva2VuLmNvbnRlbnQgPT09IFwiXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBlcnJvcnMgPSB0b2tlbi5lcnJvcnMgfHwgW107XG4gIGNvbnN0IHBhcmVudCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICBjb25zdCB7IHRhZywgYXR0cmlidXRlcywgZXJyb3I6IGVycm9yMiB9ID0gdG9rZW4ubWV0YSB8fCB7fTtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFwiYW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKGlubGluZVBhcmVudClcbiAgICAgIHJldHVybiBhbm5vdGF0ZShpbmxpbmVQYXJlbnQsIGF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBwYXJlbnQuZXJyb3JzLnB1c2goe1xuICAgICAgaWQ6IFwibm8taW5saW5lLWFubm90YXRpb25zXCIsXG4gICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgbWVzc2FnZTogYENhbid0IGFwcGx5IGlubGluZSBhbm5vdGF0aW9ucyB0byAnJHtwYXJlbnQudHlwZX0nYFxuICAgIH0pO1xuICB9XG4gIGxldCB0eXBlTmFtZSA9IHRva2VuLnR5cGUucmVwbGFjZSgvXyhvcGVufGNsb3NlKSQvLCBcIlwiKTtcbiAgaWYgKG1hcHBpbmdzW3R5cGVOYW1lXSlcbiAgICB0eXBlTmFtZSA9IG1hcHBpbmdzW3R5cGVOYW1lXTtcbiAgaWYgKHR5cGVOYW1lID09PSBcImVycm9yXCIpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGxvY2F0aW9uIH0gPSBlcnJvcjI7XG4gICAgZXJyb3JzLnB1c2goeyBpZDogXCJwYXJzZS1lcnJvclwiLCBsZXZlbDogXCJjcml0aWNhbFwiLCBtZXNzYWdlLCBsb2NhdGlvbiB9KTtcbiAgfVxuICBpZiAodG9rZW4ubmVzdGluZyA8IDApIHtcbiAgICBpZiAocGFyZW50LnR5cGUgPT09IHR5cGVOYW1lKSB7XG4gICAgICBpZiAocGFyZW50LmxpbmVzICYmIHRva2VuLm1hcClcbiAgICAgICAgcGFyZW50LmxpbmVzLnB1c2goLi4udG9rZW4ubWFwKTtcbiAgICAgIHJldHVybiBub2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgaWQ6IFwibWlzc2luZy1vcGVuaW5nXCIsXG4gICAgICBsZXZlbDogXCJjcml0aWNhbFwiLFxuICAgICAgbWVzc2FnZTogYE5vZGUgJyR7dHlwZU5hbWV9JyBpcyBtaXNzaW5nIG9wZW5pbmdgXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBoYW5kbGVBdHRycyh0b2tlbiwgdHlwZU5hbWUpO1xuICBjb25zdCBub2RlMiA9IG5ldyBOb2RlKHR5cGVOYW1lLCBhdHRycywgdm9pZCAwLCB0YWcgfHwgdm9pZCAwKTtcbiAgY29uc3QgeyBwb3NpdGlvbiA9IHt9IH0gPSB0b2tlbjtcbiAgbm9kZTIuZXJyb3JzID0gZXJyb3JzO1xuICBub2RlMi5saW5lcyA9IHRva2VuLm1hcCB8fCBwYXJlbnQubGluZXMgfHwgW107XG4gIG5vZGUyLmxvY2F0aW9uID0ge1xuICAgIGZpbGUsXG4gICAgc3RhcnQ6IHtcbiAgICAgIGxpbmU6IG5vZGUyLmxpbmVzWzBdLFxuICAgICAgY2hhcmFjdGVyOiBwb3NpdGlvbi5zdGFydFxuICAgIH0sXG4gICAgZW5kOiB7XG4gICAgICBsaW5lOiBub2RlMi5saW5lc1sxXSxcbiAgICAgIGNoYXJhY3RlcjogcG9zaXRpb24uZW5kXG4gICAgfVxuICB9O1xuICBpZiAoaW5saW5lUGFyZW50KVxuICAgIG5vZGUyLmlubGluZSA9IHRydWU7XG4gIGlmIChhdHRyaWJ1dGVzICYmIFtcInRhZ1wiLCBcImZlbmNlXCIsIFwiaW1hZ2VcIl0uaW5jbHVkZXModHlwZU5hbWUpKVxuICAgIGFubm90YXRlKG5vZGUyLCBhdHRyaWJ1dGVzKTtcbiAgcGFyZW50LnB1c2gobm9kZTIpO1xuICBpZiAodG9rZW4ubmVzdGluZyA+IDApXG4gICAgbm9kZXMucHVzaChub2RlMik7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbi5jaGlsZHJlbikpXG4gICAgcmV0dXJuO1xuICBpbmxpbmVQYXJlbnQgPSBwYXJlbnQ7XG4gIG5vZGVzLnB1c2gobm9kZTIpO1xuICBjb25zdCBpc0xlYWZOb2RlID0gdHlwZU5hbWUgPT09IFwiaW1hZ2VcIjtcbiAgaWYgKCFpc0xlYWZOb2RlKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0b2tlbi5jaGlsZHJlbilcbiAgICAgIGhhbmRsZVRva2VuKGNoaWxkLCBub2RlcywgZmlsZSwgaW5saW5lUGFyZW50KTtcbiAgfVxuICBub2Rlcy5wb3AoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlcih0b2tlbnMsIGZpbGUpIHtcbiAgY29uc3QgZG9jID0gbmV3IE5vZGUoXCJkb2N1bWVudFwiKTtcbiAgY29uc3Qgbm9kZXMgPSBbZG9jXTtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpXG4gICAgaGFuZGxlVG9rZW4odG9rZW4sIG5vZGVzLCBmaWxlKTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpXG4gICAgZm9yIChjb25zdCBub2RlMiBvZiBub2Rlcy5zbGljZSgxKSlcbiAgICAgIG5vZGUyLmVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwibWlzc2luZy1jbG9zaW5nXCIsXG4gICAgICAgIGxldmVsOiBcImNyaXRpY2FsXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBOb2RlICcke25vZGUyLnRhZyB8fCBub2RlMi50eXBlfScgaXMgbWlzc2luZyBjbG9zaW5nYFxuICAgICAgfSk7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtMyBvZiB0cmFuc2Zvcm1zX2RlZmF1bHQpXG4gICAgdHJhbnNmb3JtMyhkb2MpO1xuICByZXR1cm4gZG9jO1xufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG52YXIgc2NoZW1hX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNjaGVtYV9leHBvcnRzLCB7XG4gIGJsb2NrcXVvdGU6ICgpID0+IGJsb2NrcXVvdGUsXG4gIGNvZGU6ICgpID0+IGNvZGUsXG4gIGRvY3VtZW50OiAoKSA9PiBkb2N1bWVudCxcbiAgZW06ICgpID0+IGVtLFxuICBlcnJvcjogKCkgPT4gZXJyb3IsXG4gIGZlbmNlOiAoKSA9PiBmZW5jZSxcbiAgaGFyZGJyZWFrOiAoKSA9PiBoYXJkYnJlYWssXG4gIGhlYWRpbmc6ICgpID0+IGhlYWRpbmcsXG4gIGhyOiAoKSA9PiBocixcbiAgaW1hZ2U6ICgpID0+IGltYWdlLFxuICBpbmxpbmU6ICgpID0+IGlubGluZSxcbiAgaXRlbTogKCkgPT4gaXRlbSxcbiAgbGluazogKCkgPT4gbGluayxcbiAgbGlzdDogKCkgPT4gbGlzdCxcbiAgbm9kZTogKCkgPT4gbm9kZSxcbiAgcGFyYWdyYXBoOiAoKSA9PiBwYXJhZ3JhcGgsXG4gIHM6ICgpID0+IHMsXG4gIHNvZnRicmVhazogKCkgPT4gc29mdGJyZWFrLFxuICBzdHJvbmc6ICgpID0+IHN0cm9uZyxcbiAgdGFibGU6ICgpID0+IHRhYmxlLFxuICB0Ym9keTogKCkgPT4gdGJvZHksXG4gIHRkOiAoKSA9PiB0ZCxcbiAgdGV4dDogKCkgPT4gdGV4dCxcbiAgdGg6ICgpID0+IHRoLFxuICB0aGVhZDogKCkgPT4gdGhlYWQsXG4gIHRyOiAoKSA9PiB0clxufSk7XG52YXIgZG9jdW1lbnQgPSB7XG4gIHJlbmRlcjogXCJhcnRpY2xlXCIsXG4gIGNoaWxkcmVuOiBbXG4gICAgXCJoZWFkaW5nXCIsXG4gICAgXCJwYXJhZ3JhcGhcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidGFnXCIsXG4gICAgXCJmZW5jZVwiLFxuICAgIFwiYmxvY2txdW90ZVwiLFxuICAgIFwibGlzdFwiLFxuICAgIFwiaHJcIlxuICBdLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgZnJvbnRtYXR0ZXI6IHsgcmVuZGVyOiBmYWxzZSB9XG4gIH1cbn07XG52YXIgaGVhZGluZyA9IHtcbiAgY2hpbGRyZW46IFtcImlubGluZVwiXSxcbiAgYXR0cmlidXRlczoge1xuICAgIGxldmVsOiB7IHR5cGU6IE51bWJlciwgcmVuZGVyOiBmYWxzZSwgcmVxdWlyZWQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgVGFnKGBoJHtub2RlMi5hdHRyaWJ1dGVzW1wibGV2ZWxcIl19YCwgbm9kZTIudHJhbnNmb3JtQXR0cmlidXRlcyhjb25maWcpLCBub2RlMi50cmFuc2Zvcm1DaGlsZHJlbihjb25maWcpKTtcbiAgfVxufTtcbnZhciBwYXJhZ3JhcGggPSB7XG4gIHJlbmRlcjogXCJwXCIsXG4gIGNoaWxkcmVuOiBbXCJpbmxpbmVcIl1cbn07XG52YXIgaW1hZ2UgPSB7XG4gIHJlbmRlcjogXCJpbWdcIixcbiAgYXR0cmlidXRlczoge1xuICAgIHNyYzogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gICAgYWx0OiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZyB9XG4gIH1cbn07XG52YXIgZmVuY2UgPSB7XG4gIHJlbmRlcjogXCJwcmVcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGNvbnRlbnQ6IHsgdHlwZTogU3RyaW5nLCByZW5kZXI6IGZhbHNlLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIGxhbmd1YWdlOiB7IHR5cGU6IFN0cmluZywgcmVuZGVyOiBcImRhdGEtbGFuZ3VhZ2VcIiB9LFxuICAgIHByb2Nlc3M6IHsgdHlwZTogQm9vbGVhbiwgcmVuZGVyOiBmYWxzZSwgZGVmYXVsdDogdHJ1ZSB9XG4gIH0sXG4gIHRyYW5zZm9ybShub2RlMiwgY29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUyLnRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUyLmNoaWxkcmVuLmxlbmd0aCA/IG5vZGUyLnRyYW5zZm9ybUNoaWxkcmVuKGNvbmZpZykgOiBbbm9kZTIuYXR0cmlidXRlcy5jb250ZW50XTtcbiAgICByZXR1cm4gbmV3IFRhZyhcInByZVwiLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XG4gIH1cbn07XG52YXIgYmxvY2txdW90ZSA9IHtcbiAgcmVuZGVyOiBcImJsb2NrcXVvdGVcIixcbiAgY2hpbGRyZW46IFtcbiAgICBcImhlYWRpbmdcIixcbiAgICBcInBhcmFncmFwaFwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0YWdcIixcbiAgICBcImZlbmNlXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJsaXN0XCIsXG4gICAgXCJoclwiXG4gIF1cbn07XG52YXIgaXRlbSA9IHtcbiAgcmVuZGVyOiBcImxpXCIsXG4gIGNoaWxkcmVuOiBbXG4gICAgXCJpbmxpbmVcIixcbiAgICBcImhlYWRpbmdcIixcbiAgICBcInBhcmFncmFwaFwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0YWdcIixcbiAgICBcImZlbmNlXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJsaXN0XCIsXG4gICAgXCJoclwiXG4gIF1cbn07XG52YXIgbGlzdCA9IHtcbiAgY2hpbGRyZW46IFtcIml0ZW1cIl0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBvcmRlcmVkOiB7IHR5cGU6IEJvb2xlYW4sIHJlbmRlcjogZmFsc2UsIHJlcXVpcmVkOiB0cnVlIH1cbiAgfSxcbiAgdHJhbnNmb3JtKG5vZGUyLCBjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFRhZyhub2RlMi5hdHRyaWJ1dGVzLm9yZGVyZWQgPyBcIm9sXCIgOiBcInVsXCIsIG5vZGUyLnRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnKSwgbm9kZTIudHJhbnNmb3JtQ2hpbGRyZW4oY29uZmlnKSk7XG4gIH1cbn07XG52YXIgaHIgPSB7XG4gIHJlbmRlcjogXCJoclwiXG59O1xudmFyIHRhYmxlID0ge1xuICByZW5kZXI6IFwidGFibGVcIlxufTtcbnZhciB0ZCA9IHtcbiAgcmVuZGVyOiBcInRkXCIsXG4gIGNoaWxkcmVuOiBbXG4gICAgXCJpbmxpbmVcIixcbiAgICBcImhlYWRpbmdcIixcbiAgICBcInBhcmFncmFwaFwiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJ0YWdcIixcbiAgICBcImZlbmNlXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJsaXN0XCIsXG4gICAgXCJoclwiXG4gIF0sXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb2xzcGFuOiB7IHR5cGU6IE51bWJlciB9LFxuICAgIHJvd3NwYW46IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgYWxpZ246IHsgdHlwZTogU3RyaW5nIH1cbiAgfVxufTtcbnZhciB0aCA9IHtcbiAgcmVuZGVyOiBcInRoXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB3aWR0aDogeyB0eXBlOiBOdW1iZXIgfSxcbiAgICBhbGlnbjogeyB0eXBlOiBTdHJpbmcgfVxuICB9XG59O1xudmFyIHRyID0ge1xuICByZW5kZXI6IFwidHJcIixcbiAgY2hpbGRyZW46IFtcInRoXCIsIFwidGRcIl1cbn07XG52YXIgdGJvZHkgPSB7XG4gIHJlbmRlcjogXCJ0Ym9keVwiLFxuICBjaGlsZHJlbjogW1widHJcIiwgXCJ0YWdcIl1cbn07XG52YXIgdGhlYWQgPSB7XG4gIHJlbmRlcjogXCJ0aGVhZFwiLFxuICBjaGlsZHJlbjogW1widHJcIl1cbn07XG52YXIgc3Ryb25nID0ge1xuICByZW5kZXI6IFwic3Ryb25nXCIsXG4gIGNoaWxkcmVuOiBbXCJlbVwiLCBcInNcIiwgXCJsaW5rXCIsIFwiY29kZVwiLCBcInRleHRcIiwgXCJ0YWdcIl1cbn07XG52YXIgZW0gPSB7XG4gIHJlbmRlcjogXCJlbVwiLFxuICBjaGlsZHJlbjogW1wic3Ryb25nXCIsIFwic1wiLCBcImxpbmtcIiwgXCJjb2RlXCIsIFwidGV4dFwiLCBcInRhZ1wiXVxufTtcbnZhciBzID0ge1xuICByZW5kZXI6IFwic1wiLFxuICBjaGlsZHJlbjogW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJsaW5rXCIsIFwiY29kZVwiLCBcInRleHRcIiwgXCJ0YWdcIl1cbn07XG52YXIgaW5saW5lID0ge1xuICBjaGlsZHJlbjogW1xuICAgIFwic3Ryb25nXCIsXG4gICAgXCJlbVwiLFxuICAgIFwic1wiLFxuICAgIFwiY29kZVwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwidGFnXCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwiaGFyZGJyZWFrXCIsXG4gICAgXCJzb2Z0YnJlYWtcIlxuICBdXG59O1xudmFyIGxpbmsgPSB7XG4gIHJlbmRlcjogXCJhXCIsXG4gIGNoaWxkcmVuOiBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcInNcIiwgXCJjb2RlXCIsIFwidGV4dFwiLCBcInRhZ1wiXSxcbiAgYXR0cmlidXRlczoge1xuICAgIGhyZWY6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIHRpdGxlOiB7IHR5cGU6IFN0cmluZyB9XG4gIH1cbn07XG52YXIgY29kZSA9IHtcbiAgcmVuZGVyOiBcImNvZGVcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGNvbnRlbnQ6IHsgdHlwZTogU3RyaW5nLCByZW5kZXI6IGZhbHNlLCByZXF1aXJlZDogdHJ1ZSB9XG4gIH0sXG4gIHRyYW5zZm9ybShub2RlMiwgY29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUyLnRyYW5zZm9ybUF0dHJpYnV0ZXMoY29uZmlnKTtcbiAgICByZXR1cm4gbmV3IFRhZyhcImNvZGVcIiwgYXR0cmlidXRlcywgW25vZGUyLmF0dHJpYnV0ZXMuY29udGVudF0pO1xuICB9XG59O1xudmFyIHRleHQgPSB7XG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjb250ZW50OiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIpIHtcbiAgICByZXR1cm4gbm9kZTIuYXR0cmlidXRlcy5jb250ZW50O1xuICB9XG59O1xudmFyIGhhcmRicmVhayA9IHtcbiAgcmVuZGVyOiBcImJyXCJcbn07XG52YXIgc29mdGJyZWFrID0ge1xuICB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIFwiIFwiO1xuICB9XG59O1xudmFyIGVycm9yID0ge307XG52YXIgbm9kZSA9IHt9O1xuXG4vLyBzcmMvcmVuZGVyZXJzL2h0bWwudHNcbnZhciBpbXBvcnRfbWFya2Rvd25faXQgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbWFya2Rvd25faXQoKSk7XG52YXIgeyBlc2NhcGVIdG1sIH0gPSAoMCwgaW1wb3J0X21hcmtkb3duX2l0LmRlZmF1bHQpKCkudXRpbHM7XG52YXIgdm9pZEVsZW1lbnRzID0gbmV3IFNldChbXG4gIFwiYXJlYVwiLFxuICBcImJhc2VcIixcbiAgXCJiclwiLFxuICBcImNvbFwiLFxuICBcImVtYmVkXCIsXG4gIFwiaHJcIixcbiAgXCJpbWdcIixcbiAgXCJpbnB1dFwiLFxuICBcImxpbmtcIixcbiAgXCJtZXRhXCIsXG4gIFwicGFyYW1cIixcbiAgXCJzb3VyY2VcIixcbiAgXCJ0cmFja1wiLFxuICBcIndiclwiXG5dKTtcbmZ1bmN0aW9uIHJlbmRlcihub2RlMikge1xuICBpZiAodHlwZW9mIG5vZGUyID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBlc2NhcGVIdG1sKG5vZGUyKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZTIpKVxuICAgIHJldHVybiBub2RlMi5tYXAocmVuZGVyKS5qb2luKFwiXCIpO1xuICBpZiAobm9kZTIgPT09IG51bGwgfHwgdHlwZW9mIG5vZGUyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCB7IG5hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuID0gW10gfSA9IG5vZGUyO1xuICBpZiAoIW5hbWUpXG4gICAgcmV0dXJuIHJlbmRlcihjaGlsZHJlbik7XG4gIGxldCBvdXRwdXQgPSBgPCR7bmFtZX1gO1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzID8/IHt9KSlcbiAgICBvdXRwdXQgKz0gYCAke2t9PVwiJHtlc2NhcGVIdG1sKFN0cmluZyh2KSl9XCJgO1xuICBvdXRwdXQgKz0gXCI+XCI7XG4gIGlmICh2b2lkRWxlbWVudHMuaGFzKG5hbWUpKVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpXG4gICAgb3V0cHV0ICs9IHJlbmRlcihjaGlsZHJlbik7XG4gIG91dHB1dCArPSBgPC8ke25hbWV9PmA7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIHNyYy9yZW5kZXJlcnMvcmVhY3Qvc2hhcmVkLnRzXG5mdW5jdGlvbiB0YWdOYW1lKG5hbWUsIGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiID8gXCJGcmFnbWVudFwiIDogbmFtZVswXSAhPT0gbmFtZVswXS50b1VwcGVyQ2FzZSgpID8gbmFtZSA6IGNvbXBvbmVudHMgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGNvbXBvbmVudHMobmFtZSkgOiBjb21wb25lbnRzW25hbWVdO1xufVxuXG4vLyBzcmMvcmVuZGVyZXJzL3JlYWN0L3JlYWN0LnRzXG5mdW5jdGlvbiBkeW5hbWljKG5vZGUyLCBSZWFjdCwgeyBjb21wb25lbnRzID0ge30gfSA9IHt9KSB7XG4gIGZ1bmN0aW9uIGRlZXBSZW5kZXIyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGl0ZW0yKSA9PiBkZWVwUmVuZGVyMihpdGVtMikpO1xuICAgIGlmICh2YWx1ZS4kJG1kdHlwZSA9PT0gXCJUYWdcIilcbiAgICAgIHJldHVybiByZW5kZXIzKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgIG91dHB1dFtrXSA9IGRlZXBSZW5kZXIyKHYpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyMyhub2RlMykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUzKSlcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAuLi5ub2RlMy5tYXAocmVuZGVyMykpO1xuICAgIGlmIChub2RlMyA9PT0gbnVsbCB8fCB0eXBlb2Ygbm9kZTMgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gbm9kZTM7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IGNsYXNzTmFtZSwgLi4uYXR0cnMgfSA9IHt9LFxuICAgICAgY2hpbGRyZW4gPSBbXVxuICAgIH0gPSBub2RlMztcbiAgICBpZiAoY2xhc3NOYW1lKVxuICAgICAgYXR0cnMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZ05hbWUobmFtZSwgY29tcG9uZW50cyksIE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGggPT0gMCA/IG51bGwgOiBkZWVwUmVuZGVyMihhdHRycyksIC4uLmNoaWxkcmVuLm1hcChyZW5kZXIzKSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcjMobm9kZTIpO1xufVxuXG4vLyBzcmMvcmVuZGVyZXJzL3JlYWN0L3N0YXRpYy50c1xuZnVuY3Rpb24gcmVuZGVyQXJyYXkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLm1hcChyZW5kZXIyKS5qb2luKFwiLCBcIik7XG59XG5mdW5jdGlvbiBkZWVwUmVuZGVyKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgcmV0dXJuIGBbJHt2YWx1ZS5tYXAoKGl0ZW0yKSA9PiBkZWVwUmVuZGVyKGl0ZW0yKSkuam9pbihcIiwgXCIpfV1gO1xuICBpZiAodmFsdWUuJCRtZHR5cGUgPT09IFwiVGFnXCIpXG4gICAgcmV0dXJuIHJlbmRlcjIodmFsdWUpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIGNvbnN0IG9iamVjdCA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gW0pTT04uc3RyaW5naWZ5KGspLCBkZWVwUmVuZGVyKHYpXS5qb2luKFwiOiBcIikpLmpvaW4oXCIsIFwiKTtcbiAgcmV0dXJuIGB7JHtvYmplY3R9fWA7XG59XG5mdW5jdGlvbiByZW5kZXIyKG5vZGUyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUyKSlcbiAgICByZXR1cm4gYFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsICR7cmVuZGVyQXJyYXkobm9kZTIpfSlgO1xuICBpZiAobm9kZTIgPT09IG51bGwgfHwgdHlwZW9mIG5vZGUyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShub2RlMik7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIGF0dHJpYnV0ZXM6IHsgY2xhc3M6IGNsYXNzTmFtZSwgLi4uYXR0cnMgfSA9IHt9LFxuICAgIGNoaWxkcmVuID0gW11cbiAgfSA9IG5vZGUyO1xuICBpZiAoY2xhc3NOYW1lKVxuICAgIGF0dHJzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgcmV0dXJuIGBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIHRhZ05hbWUoJHtKU09OLnN0cmluZ2lmeShuYW1lKX0sIGNvbXBvbmVudHMpLFxuICAgICR7T2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA9PSAwID8gXCJudWxsXCIgOiBkZWVwUmVuZGVyKGF0dHJzKX0sXG4gICAgJHtyZW5kZXJBcnJheShjaGlsZHJlbil9KWA7XG59XG5mdW5jdGlvbiByZWFjdFN0YXRpYyhub2RlMikge1xuICByZXR1cm4gYFxuICAoKHtjb21wb25lbnRzID0ge319ID0ge30pID0+IHtcbiAgICAke3RhZ05hbWV9XG4gICAgcmV0dXJuICR7cmVuZGVyMihub2RlMil9O1xuICB9KVxuYDtcbn1cblxuLy8gc3JjL3JlbmRlcmVycy9pbmRleC50c1xudmFyIHJlbmRlcmVyc19kZWZhdWx0ID0geyBodG1sOiByZW5kZXIsIHJlYWN0OiBkeW5hbWljLCByZWFjdFN0YXRpYyB9O1xuXG4vLyBzcmMvdGFncy9wYXJ0aWFsLnRzXG52YXIgUGFydGlhbEZpbGUgPSBjbGFzcyB7XG4gIHZhbGlkYXRlKGZpbGUsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgcGFydGlhbHMgPSB7fSB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHBhcnRpYWwyID0gcGFydGlhbHNbZmlsZV07XG4gICAgaWYgKCFwYXJ0aWFsMilcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJhdHRyaWJ1dGUtdmFsdWUtaW52YWxpZFwiLFxuICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogYFBhcnRpYWwgXFxgJHtmaWxlfVxcYCBub3QgZm91bmQuIFRoZSAnZmlsZScgYXR0cmlidXRlIG11c3QgYmUgc2V0IGluIFxcYGNvbmZpZy5wYXJ0aWFsc1xcYGBcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG52YXIgcGFydGlhbCA9IHtcbiAgc2VsZkNsb3Npbmc6IHRydWUsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBmaWxlOiB7IHR5cGU6IFBhcnRpYWxGaWxlLCByZW5kZXI6IGZhbHNlLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIHZhcmlhYmxlczogeyB0eXBlOiBPYmplY3QsIHJlbmRlcjogZmFsc2UgfVxuICB9LFxuICB0cmFuc2Zvcm0obm9kZTIsIGNvbmZpZykge1xuICAgIGNvbnN0IHsgcGFydGlhbHMgPSB7fSB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHsgZmlsZSwgdmFyaWFibGVzIH0gPSBub2RlMi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBhcnRpYWwyID0gcGFydGlhbHNbZmlsZV07XG4gICAgaWYgKCFwYXJ0aWFsMilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHNjb3BlZENvbmZpZyA9IHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAuLi5jb25maWcudmFyaWFibGVzLFxuICAgICAgICAuLi52YXJpYWJsZXMsXG4gICAgICAgIFtcIiQkcGFydGlhbDpmaWxlbmFtZVwiXTogZmlsZVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtQ2hpbGRyZW4gPSAocGFydCkgPT4gcGFydC5yZXNvbHZlKHNjb3BlZENvbmZpZykudHJhbnNmb3JtQ2hpbGRyZW4oc2NvcGVkQ29uZmlnKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJ0aWFsMikgPyBwYXJ0aWFsMi5mbGF0TWFwKHRyYW5zZm9ybUNoaWxkcmVuKSA6IHRyYW5zZm9ybUNoaWxkcmVuKHBhcnRpYWwyKTtcbiAgfVxufTtcblxuLy8gc3JjL3RhZ3MvdGFibGUudHNcbnZhciB0YWJsZTIgPSB7XG4gIGNoaWxkcmVuOiBbXCJ0YWJsZVwiXVxufTtcblxuLy8gc3JjL3RhZ3MvaW5kZXgudHNcbnZhciB0YWdzX2RlZmF1bHQgPSB7XG4gIGlmOiB0YWdJZixcbiAgZWxzZTogdGFnRWxzZSxcbiAgcGFydGlhbCxcbiAgdGFibGU6IHRhYmxlMlxufTtcblxuLy8gc3JjL3Rva2VuaXplci9pbmRleC50c1xudmFyIGltcG9ydF9saWIgPSBfX3RvTW9kdWxlKHJlcXVpcmVfbGliKCkpO1xuXG4vLyBzcmMvdG9rZW5pemVyL3BsdWdpbnMvYW5ub3RhdGlvbnMudHNcbnZhciBpbXBvcnRfdGFnNCA9IF9fdG9Nb2R1bGUocmVxdWlyZV90YWcoKSk7XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihzdGF0ZSwgY29udGVudCwgY29udGVudFN0YXJ0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyB0eXBlLCBtZXRhLCBuZXN0aW5nID0gMCB9ID0gKDAsIGltcG9ydF90YWc0LnBhcnNlKShjb250ZW50LCB7IFZhcmlhYmxlLCBGdW5jdGlvbjogRnVuY3Rpb24yIH0pO1xuICAgIGNvbnN0IHRva2VuID0gc3RhdGUucHVzaCh0eXBlLCBcIlwiLCBuZXN0aW5nKTtcbiAgICB0b2tlbi5pbmZvID0gY29udGVudDtcbiAgICB0b2tlbi5tZXRhID0gbWV0YTtcbiAgICBpZiAoIXN0YXRlLmRlbGltaXRlcnMpIHtcbiAgICAgIHN0YXRlLmRlbGltaXRlcnMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBpZiAoIShlcnJvcjIgaW5zdGFuY2VvZiBpbXBvcnRfdGFnNC5TeW50YXhFcnJvcikpXG4gICAgICB0aHJvdyBlcnJvcjI7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZSxcbiAgICAgIGxvY2F0aW9uOiB7IHN0YXJ0LCBlbmQgfVxuICAgIH0gPSBlcnJvcjI7XG4gICAgY29uc3QgbG9jYXRpb24gPSBjb250ZW50U3RhcnQgPyB7XG4gICAgICBzdGFydDogeyBvZmZzZXQ6IHN0YXJ0Lm9mZnNldCArIGNvbnRlbnRTdGFydCB9LFxuICAgICAgZW5kOiB7IG9mZnNldDogZW5kLm9mZnNldCArIGNvbnRlbnRTdGFydCB9XG4gICAgfSA6IG51bGw7XG4gICAgY29uc3QgdG9rZW4gPSBzdGF0ZS5wdXNoKFwiZXJyb3JcIiwgXCJcIiwgMCk7XG4gICAgdG9rZW4ubWV0YSA9IHsgZXJyb3I6IHsgbWVzc2FnZSwgbG9jYXRpb24gfSB9O1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxufVxuZnVuY3Rpb24gYmxvY2soc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIGNvbnN0IHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgY29uc3QgZmluaXNoID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG4gIGlmICghc3RhdGUuc3JjLnN0YXJ0c1dpdGgoT1BFTiwgc3RhcnQpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnRW5kID0gZmluZFRhZ0VuZChzdGF0ZS5zcmMsIHN0YXJ0KTtcbiAgY29uc3QgbGFzdFBvc3NpYmxlID0gc3RhdGUuc3JjLnNsaWNlKDAsIGZpbmlzaCkudHJpbSgpLmxlbmd0aDtcbiAgaWYgKCF0YWdFbmQgfHwgdGFnRW5kIDwgbGFzdFBvc3NpYmxlIC0gQ0xPU0UubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY29udGVudFN0YXJ0ID0gc3RhcnQgKyBPUEVOLmxlbmd0aDtcbiAgY29uc3QgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShjb250ZW50U3RhcnQsIHRhZ0VuZCkudHJpbSgpO1xuICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIikubGVuZ3RoO1xuICBpZiAoY29udGVudFswXSA9PT0gXCIkXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB0b2tlbiA9IGNyZWF0ZVRva2VuKHN0YXRlLCBjb250ZW50LCBjb250ZW50U3RhcnQpO1xuICB0b2tlbi5tYXAgPSBbc3RhcnRMaW5lLCBzdGFydExpbmUgKyBsaW5lc107XG4gIHN0YXRlLmxpbmUgKz0gbGluZXM7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaW5saW5lMihzdGF0ZSwgc2lsZW50KSB7XG4gIGlmICghc3RhdGUuc3JjLnN0YXJ0c1dpdGgoT1BFTiwgc3RhdGUucG9zKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHRhZ0VuZCA9IGZpbmRUYWdFbmQoc3RhdGUuc3JjLCBzdGF0ZS5wb3MpO1xuICBpZiAoIXRhZ0VuZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zICsgT1BFTi5sZW5ndGgsIHRhZ0VuZCk7XG4gIGlmICghc2lsZW50KVxuICAgIGNyZWF0ZVRva2VuKHN0YXRlLCBjb250ZW50LnRyaW0oKSk7XG4gIHN0YXRlLnBvcyA9IHRhZ0VuZCArIENMT1NFLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb3JlKHN0YXRlKSB7XG4gIGxldCB0b2tlbjtcbiAgZm9yICh0b2tlbiBvZiBzdGF0ZS50b2tlbnMpIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJmZW5jZVwiKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHRva2VuLmluZm8uaW5jbHVkZXMoT1BFTikpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gdG9rZW4uaW5mby5pbmRleE9mKE9QRU4pO1xuICAgICAgY29uc3QgZW5kID0gZmluZFRhZ0VuZCh0b2tlbi5pbmZvLCBzdGFydCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdG9rZW4uaW5mby5zbGljZShzdGFydCArIE9QRU4ubGVuZ3RoLCBlbmQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBtZXRhIH0gPSAoMCwgaW1wb3J0X3RhZzQucGFyc2UpKGNvbnRlbnQudHJpbSgpLCB7IFZhcmlhYmxlLCBGdW5jdGlvbjogRnVuY3Rpb24yIH0pO1xuICAgICAgICB0b2tlbi5tZXRhID0gbWV0YTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBpZiAoIShlcnJvcjIgaW5zdGFuY2VvZiBpbXBvcnRfdGFnNC5TeW50YXhFcnJvcikpXG4gICAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgICBpZiAoIXRva2VuLmVycm9ycylcbiAgICAgICAgICB0b2tlbi5lcnJvcnMgPSBbXTtcbiAgICAgICAgdG9rZW4uZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGlkOiBcImZlbmNlLXRhZy1lcnJvclwiLFxuICAgICAgICAgIGxldmVsOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogYFN5bnRheCBlcnJvciBpbiBmZW5jZSB0YWc6ICR7ZXJyb3IyLm1lc3NhZ2V9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2VuPy5tZXRhPy5hdHRyaWJ1dGVzPy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFwicHJvY2Vzc1wiICYmICFhdHRyLnZhbHVlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRva2VuLmNoaWxkcmVuID0gcGFyc2VUYWdzKHRva2VuLmNvbnRlbnQsIHRva2VuLm1hcFswXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBsdWdpbihtZCkge1xuICBtZC5ibG9jay5ydWxlci5iZWZvcmUoXCJwYXJhZ3JhcGhcIiwgXCJhbm5vdGF0aW9uc1wiLCBibG9jaywge1xuICAgIGFsdDogW1wicGFyYWdyYXBoXCIsIFwiYmxvY2txdW90ZVwiXVxuICB9KTtcbiAgbWQuaW5saW5lLnJ1bGVyLnB1c2goXCJjb250YWluZXJzXCIsIGlubGluZTIpO1xuICBtZC5jb3JlLnJ1bGVyLnB1c2goXCJhbm5vdGF0aW9uc1wiLCBjb3JlKTtcbn1cblxuLy8gc3JjL3Rva2VuaXplci9wbHVnaW5zL2Zyb250bWF0dGVyLnRzXG52YXIgZmVuY2UyID0gXCItLS1cIjtcbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIG4pIHtcbiAgcmV0dXJuIHN0YXRlLnNyYy5zbGljZShzdGF0ZS5iTWFya3Nbbl0sIHN0YXRlLmVNYXJrc1tuXSkudHJpbSgpO1xufVxuZnVuY3Rpb24gZmluZENsb3NlKHN0YXRlLCBlbmRMaW5lKSB7XG4gIGZvciAobGV0IGxpbmUgPSAxOyBsaW5lIDwgZW5kTGluZTsgbGluZSsrKVxuICAgIGlmIChnZXRMaW5lKHN0YXRlLCBsaW5lKSA9PT0gZmVuY2UyKVxuICAgICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBibG9jazIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIGlmIChzdGFydExpbmUgIT0gMCB8fCBnZXRMaW5lKHN0YXRlLCAwKSAhPSBmZW5jZTIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBjbG9zZSA9IGZpbmRDbG9zZShzdGF0ZSwgZW5kTGluZSk7XG4gIGlmICghY2xvc2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoc2lsZW50KVxuICAgIHJldHVybiB0cnVlO1xuICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2goXCJmcm9udG1hdHRlclwiLCBcIlwiLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5lTWFya3NbMF0sIHN0YXRlLmJNYXJrc1tjbG9zZV0pLnRyaW0oKTtcbiAgdG9rZW4ubWFwID0gWzAsIGNsb3NlXTtcbiAgdG9rZW4uaGlkZGVuID0gdHJ1ZTtcbiAgc3RhdGUubGluZSA9IGNsb3NlICsgMTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwbHVnaW4yKG1kKSB7XG4gIG1kLmJsb2NrLnJ1bGVyLmJlZm9yZShcImhyXCIsIFwiZnJvbnRtYXR0ZXJcIiwgYmxvY2syKTtcbn1cblxuLy8gc3JjL3Rva2VuaXplci9pbmRleC50c1xudmFyIFRva2VuaXplciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBpbXBvcnRfbGliLmRlZmF1bHQoY29uZmlnKTtcbiAgICB0aGlzLnBhcnNlci51c2UocGx1Z2luLCBcImFubm90YXRpb25zXCIsIHt9KTtcbiAgICB0aGlzLnBhcnNlci51c2UocGx1Z2luMiwgXCJmcm9udG1hdHRlclwiLCB7fSk7XG4gICAgdGhpcy5wYXJzZXIuZGlzYWJsZShbXG4gICAgICBcImxoZWFkaW5nXCIsXG4gICAgICBcImNvZGVcIlxuICAgIF0pO1xuICB9XG4gIHRva2VuaXplKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIucGFyc2UoY29udGVudC50b1N0cmluZygpLCB7fSk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbnZhciBUeXBlTWFwcGluZ3MgPSB7XG4gIFN0cmluZyxcbiAgTnVtYmVyLFxuICBBcnJheSxcbiAgT2JqZWN0LFxuICBCb29sZWFuXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGUsIHZhbHVlLCBjb25maWcpIHtcbiAgaWYgKCF0eXBlKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoYXN0X2RlZmF1bHQuaXNGdW5jdGlvbih2YWx1ZSkgJiYgY29uZmlnLnZhbGlkYXRpb24/LnZhbGlkYXRlRnVuY3Rpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gY29uZmlnLmZ1bmN0aW9ucz8uW3ZhbHVlLm5hbWVdO1xuICAgIHJldHVybiAhc2NoZW1hPy5yZXR1cm5zID8gdHJ1ZSA6IEFycmF5LmlzQXJyYXkoc2NoZW1hLnJldHVybnMpID8gc2NoZW1hLnJldHVybnMuZmluZCgodCkgPT4gdCA9PT0gdHlwZSkgIT09IHZvaWQgMCA6IHNjaGVtYS5yZXR1cm5zID09PSB0eXBlO1xuICB9XG4gIGlmIChhc3RfZGVmYXVsdC5pc0FzdCh2YWx1ZSkpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgIHJldHVybiB0eXBlLnNvbWUoKHQpID0+IHZhbGlkYXRlVHlwZSh0LCB2YWx1ZSwgY29uZmlnKSk7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICB0eXBlID0gVHlwZU1hcHBpbmdzW3R5cGVdO1xuICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHR5cGUoKTtcbiAgICBpZiAoaW5zdGFuY2UudmFsaWRhdGUpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS52YWxpZGF0ZSh2YWx1ZSwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IHR5cGU7XG59XG5mdW5jdGlvbiB0eXBlVG9TdHJpbmcodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHR5cGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgIHJldHVybiB0eXBlLm1hcCh0eXBlVG9TdHJpbmcpLmpvaW4oXCIgfCBcIik7XG4gIHJldHVybiB0eXBlLm5hbWU7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKGZuLCBjb25maWcpIHtcbiAgY29uc3Qgc2NoZW1hID0gY29uZmlnLmZ1bmN0aW9ucz8uW2ZuLm5hbWVdO1xuICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgaWYgKCFzY2hlbWEpXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiZnVuY3Rpb24tdW5kZWZpbmVkXCIsXG4gICAgICAgIGxldmVsOiBcImNyaXRpY2FsXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBVbmRlZmluZWQgZnVuY3Rpb246ICcke2ZuLm5hbWV9J2BcbiAgICAgIH1cbiAgICBdO1xuICBpZiAoc2NoZW1hLnZhbGlkYXRlKVxuICAgIGVycm9ycy5wdXNoKC4uLnNjaGVtYS52YWxpZGF0ZShmbiwgY29uZmlnKSk7XG4gIGlmIChzY2hlbWEucGFyYW1ldGVycykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZuLnBhcmFtZXRlcnMpKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHNjaGVtYS5wYXJhbWV0ZXJzPy5ba2V5XTtcbiAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGlkOiBcInBhcmFtZXRlci11bmRlZmluZWRcIixcbiAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHBhcmFtZXRlcjogJyR7a2V5fSdgXG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhc3RfZGVmYXVsdC5pc0FzdCh2YWx1ZSkgJiYgIWFzdF9kZWZhdWx0LmlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChwYXJhbS50eXBlKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gdmFsaWRhdGVUeXBlKHBhcmFtLnR5cGUsIHZhbHVlLCBjb25maWcpO1xuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IFwicGFyYW1ldGVyLXR5cGUtaW52YWxpZFwiLFxuICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQYXJhbWV0ZXIgJyR7a2V5fScgb2YgJyR7Zm4ubmFtZX0nIG11c3QgYmUgdHlwZSBvZiAnJHt0eXBlVG9TdHJpbmcocGFyYW0udHlwZSl9J2BcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbGlkKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHsgcmVxdWlyZWQgfV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnBhcmFtZXRlcnMgPz8ge30pKVxuICAgIGlmIChyZXF1aXJlZCAmJiBmbi5wYXJhbWV0ZXJzW2tleV0gPT09IHZvaWQgMClcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwicGFyYW1ldGVyLW1pc3NpbmctcmVxdWlyZWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiAnJHtrZXl9J2BcbiAgICAgIH0pO1xuICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUobm9kZTIsIGNvbmZpZykge1xuICBjb25zdCBzY2hlbWEgPSBub2RlMi5maW5kU2NoZW1hKGNvbmZpZyk7XG4gIGNvbnN0IGVycm9ycyA9IFsuLi5ub2RlMi5lcnJvcnMgfHwgW11dO1xuICBpZiAoIXNjaGVtYSkge1xuICAgIGVycm9ycy5wdXNoKHtcbiAgICAgIGlkOiBub2RlMi50YWcgPyBcInRhZy11bmRlZmluZWRcIiA6IFwibm9kZS11bmRlZmluZWRcIixcbiAgICAgIGxldmVsOiBcImNyaXRpY2FsXCIsXG4gICAgICBtZXNzYWdlOiBub2RlMi50YWcgPyBgVW5kZWZpbmVkIHRhZzogJyR7bm9kZTIudGFnfSdgIDogYFVuZGVmaW5lZCBub2RlOiAnJHtub2RlMi50eXBlfSdgXG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuICBpZiAoc2NoZW1hLnNlbGZDbG9zaW5nICYmIG5vZGUyLmNoaWxkcmVuLmxlbmd0aCA+IDApXG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgaWQ6IFwidGFnLXNlbGZjbG9zaW5nLWhhcy1jaGlsZHJlblwiLFxuICAgICAgbGV2ZWw6IFwiY3JpdGljYWxcIixcbiAgICAgIG1lc3NhZ2U6IGAnJHtub2RlMi50YWd9JyB0YWcgc2hvdWxkIGJlIHNlbGYtY2xvc2luZ2BcbiAgICB9KTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAuLi5nbG9iYWxBdHRyaWJ1dGVzLFxuICAgIC4uLnNjaGVtYS5hdHRyaWJ1dGVzXG4gIH07XG4gIGlmIChzY2hlbWEudmFsaWRhdGUpXG4gICAgZXJyb3JzLnB1c2goLi4uc2NoZW1hLnZhbGlkYXRlKG5vZGUyLCBjb25maWcpKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUyLmF0dHJpYnV0ZXMpKSB7XG4gICAgY29uc3QgYXR0cmliID0gYXR0cmlidXRlc1trZXldO1xuICAgIGlmICghYXR0cmliKSB7XG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGlkOiBcImF0dHJpYnV0ZS11bmRlZmluZWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgYXR0cmlidXRlOiAnJHtrZXl9J2BcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCB7IHR5cGUsIG1hdGNoZXMsIGVycm9yTGV2ZWwgfSA9IGF0dHJpYjtcbiAgICBpZiAoYXN0X2RlZmF1bHQuaXNBc3QodmFsdWUpKSB7XG4gICAgICBpZiAoYXN0X2RlZmF1bHQuaXNGdW5jdGlvbih2YWx1ZSkgJiYgY29uZmlnLnZhbGlkYXRpb24/LnZhbGlkYXRlRnVuY3Rpb25zKVxuICAgICAgICBlcnJvcnMucHVzaCguLi52YWxpZGF0ZUZ1bmN0aW9uKHZhbHVlLCBjb25maWcpKTtcbiAgICAgIGVsc2UgaWYgKGFzdF9kZWZhdWx0LmlzVmFyaWFibGUodmFsdWUpICYmIGNvbmZpZy52YXJpYWJsZXMpIHtcbiAgICAgICAgbGV0IG1pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHZhcmlhYmxlcyA9IGNvbmZpZy52YXJpYWJsZXM7XG4gICAgICAgIGZvciAoY29uc3Qga2V5MiBvZiB2YWx1ZS5wYXRoKSB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFyaWFibGVzLCBrZXkyKSkge1xuICAgICAgICAgICAgbWlzc2luZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyaWFibGVzID0gdmFyaWFibGVzW2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXNzaW5nKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IFwidmFyaWFibGUtdW5kZWZpbmVkXCIsXG4gICAgICAgICAgICBsZXZlbDogXCJlcnJvclwiLFxuICAgICAgICAgICAgbWVzc2FnZTogYFVuZGVmaW5lZCB2YXJpYWJsZTogJyR7dmFsdWUucGF0aC5qb2luKFwiLlwiKX0nYFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWU7XG4gICAgaWYgKGtleSA9PT0gXCJpZFwiICYmIHZhbHVlLm1hdGNoKC9eWzAtOV0vKSlcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwiYXR0cmlidXRlLXZhbHVlLWludmFsaWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogXCJUaGUgaWQgYXR0cmlidXRlIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGNvbnN0IHZhbGlkID0gdmFsaWRhdGVUeXBlKHR5cGUsIHZhbHVlLCBjb25maWcpO1xuICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IFwiYXR0cmlidXRlLXR5cGUtaW52YWxpZFwiLFxuICAgICAgICAgIGxldmVsOiBlcnJvckxldmVsIHx8IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgQXR0cmlidXRlICcke2tleX0nIG11c3QgYmUgdHlwZSBvZiAnJHt0eXBlVG9TdHJpbmcodHlwZSl9J2BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZCkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goLi4udmFsaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1hdGNoZXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzKGNvbmZpZyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2hlcykgJiYgIW1hdGNoZXMuaW5jbHVkZXModmFsdWUpKVxuICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICBpZDogXCJhdHRyaWJ1dGUtdmFsdWUtaW52YWxpZFwiLFxuICAgICAgICBsZXZlbDogZXJyb3JMZXZlbCB8fCBcImVycm9yXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBBdHRyaWJ1dGUgJyR7a2V5fScgbXVzdCBtYXRjaCBvbmUgb2YgJHtKU09OLnN0cmluZ2lmeShtYXRjaGVzKX0uIEdvdCAnJHt2YWx1ZX0nIGluc3RlYWQuYFxuICAgICAgfSk7XG4gICAgaWYgKG1hdGNoZXMgaW5zdGFuY2VvZiBSZWdFeHAgJiYgIW1hdGNoZXMudGVzdCh2YWx1ZSkpXG4gICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgIGlkOiBcImF0dHJpYnV0ZS12YWx1ZS1pbnZhbGlkXCIsXG4gICAgICAgIGxldmVsOiBlcnJvckxldmVsIHx8IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEF0dHJpYnV0ZSAnJHtrZXl9JyBtdXN0IG1hdGNoICR7bWF0Y2hlc30uIEdvdCAnJHt2YWx1ZX0nIGluc3RlYWQuYFxuICAgICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB7IHJlcXVpcmVkIH1dIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKVxuICAgIGlmIChyZXF1aXJlZCAmJiBub2RlMi5hdHRyaWJ1dGVzW2tleV0gPT09IHZvaWQgMClcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwiYXR0cmlidXRlLW1pc3NpbmctcmVxdWlyZWRcIixcbiAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlOiAnJHtrZXl9J2BcbiAgICAgIH0pO1xuICBmb3IgKGNvbnN0IHsgdHlwZSB9IG9mIG5vZGUyLmNoaWxkcmVuKSB7XG4gICAgaWYgKHNjaGVtYS5jaGlsZHJlbiAmJiB0eXBlICE9PSBcImVycm9yXCIgJiYgIXNjaGVtYS5jaGlsZHJlbi5pbmNsdWRlcyh0eXBlKSlcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgaWQ6IFwiY2hpbGQtaW52YWxpZFwiLFxuICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDYW4ndCBuZXN0ICcke3R5cGV9JyBpbiAnJHtub2RlMi50YWcgfHwgbm9kZTIudHlwZX0nYFxuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuLy8gaW5kZXgudHNcbnZhciB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKCk7XG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIC4uLmNvbmZpZyxcbiAgICB0YWdzOiB7XG4gICAgICAuLi50YWdzX2RlZmF1bHQsXG4gICAgICAuLi5jb25maWcudGFnc1xuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIC4uLnNjaGVtYV9leHBvcnRzLFxuICAgICAgLi4uY29uZmlnLm5vZGVzXG4gICAgfSxcbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIC4uLmZ1bmN0aW9uc19kZWZhdWx0LFxuICAgICAgLi4uY29uZmlnLmZ1bmN0aW9uc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlMyhjb250ZW50LCBmaWxlKSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICBjb250ZW50ID0gdG9rZW5pemVyLnRva2VuaXplKGNvbnRlbnQpO1xuICByZXR1cm4gcGFyc2VyKGNvbnRlbnQsIGZpbGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZTIoY29udGVudCwgY29uZmlnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKVxuICAgIHJldHVybiBjb250ZW50LmZsYXRNYXAoKGNoaWxkKSA9PiBjaGlsZC5yZXNvbHZlKGNvbmZpZykpO1xuICByZXR1cm4gY29udGVudC5yZXNvbHZlKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0yKG5vZGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IG1lcmdlQ29uZmlnKG9wdGlvbnMpO1xuICBjb25zdCBjb250ZW50ID0gcmVzb2x2ZTIobm9kZXMsIGNvbmZpZyk7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKVxuICAgIHJldHVybiBjb250ZW50LmZsYXRNYXAoKGNoaWxkKSA9PiBjaGlsZC50cmFuc2Zvcm0oY29uZmlnKSk7XG4gIHJldHVybiBjb250ZW50LnRyYW5zZm9ybShjb25maWcpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUyKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWcob3B0aW9ucyk7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBmb3IgKGNvbnN0IG5vZGUyIG9mIFtjb250ZW50LCAuLi5jb250ZW50LndhbGsoKV0pIHtcbiAgICBjb25zdCB7IHR5cGUsIGxpbmVzLCBsb2NhdGlvbiB9ID0gbm9kZTI7XG4gICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdGUobm9kZTIsIGNvbmZpZyk7XG4gICAgZm9yIChjb25zdCBlcnJvcjIgb2YgZXJyb3JzKVxuICAgICAgb3V0cHV0LnB1c2goeyB0eXBlLCBsaW5lcywgbG9jYXRpb24sIGVycm9yOiBlcnJvcjIgfSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcyA9IHt9LCAuLi5jaGlsZHJlbikge1xuICByZXR1cm4geyBuYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiB9O1xufVxudmFyIE1hcmtkb2MgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMucGFyc2UgPSBwYXJzZTM7XG4gICAgdGhpcy5yZXNvbHZlID0gKGNvbnRlbnQpID0+IHJlc29sdmUyKGNvbnRlbnQsIHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IChjb250ZW50KSA9PiB0cmFuc2Zvcm0yKGNvbnRlbnQsIHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLnZhbGlkYXRlID0gKGNvbnRlbnQpID0+IHZhbGlkYXRlMihjb250ZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbn07XG5NYXJrZG9jLm5vZGVzID0gc2NoZW1hX2V4cG9ydHM7XG5NYXJrZG9jLnRhZ3MgPSB0YWdzX2RlZmF1bHQ7XG5NYXJrZG9jLmZ1bmN0aW9ucyA9IGZ1bmN0aW9uc19kZWZhdWx0O1xuTWFya2RvYy5nbG9iYWxBdHRyaWJ1dGVzID0gZ2xvYmFsQXR0cmlidXRlcztcbk1hcmtkb2MucmVuZGVyZXJzID0gcmVuZGVyZXJzX2RlZmF1bHQ7XG5NYXJrZG9jLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1zX2RlZmF1bHQ7XG5NYXJrZG9jLkFzdCA9IGFzdF9kZWZhdWx0O1xuTWFya2RvYy5UYWcgPSBUYWc7XG5NYXJrZG9jLlRva2VuaXplciA9IFRva2VuaXplcjtcbk1hcmtkb2MucGFyc2VUYWdzID0gcGFyc2VUYWdzO1xuTWFya2RvYy50cmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyX2RlZmF1bHQ7XG5NYXJrZG9jLnZhbGlkYXRvciA9IHZhbGlkYXRlO1xuTWFya2RvYy5wYXJzZSA9IHBhcnNlMztcbk1hcmtkb2MudHJhbnNmb3JtID0gdHJhbnNmb3JtMjtcbk1hcmtkb2MudmFsaWRhdGUgPSB2YWxpZGF0ZTI7XG5NYXJrZG9jLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuTWFya2RvYy50cnV0aHkgPSB0cnV0aHk7XG5NYXJrZG9jLl9fRVhQRVJJTUVOVEFMX19mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnQge1xuICBhc3RfZGVmYXVsdCBhcyBBc3QsXG4gIFRhZyxcbiAgVG9rZW5pemVyLFxuICBmb3JtYXQgYXMgX19FWFBFUklNRU5UQUxfX2Zvcm1hdCxcbiAgY3JlYXRlRWxlbWVudCxcbiAgTWFya2RvYyBhcyBkZWZhdWx0LFxuICBmdW5jdGlvbnNfZGVmYXVsdCBhcyBmdW5jdGlvbnMsXG4gIGdsb2JhbEF0dHJpYnV0ZXMsXG4gIHNjaGVtYV9leHBvcnRzIGFzIG5vZGVzLFxuICBwYXJzZTMgYXMgcGFyc2UsXG4gIHBhcnNlVGFncyxcbiAgcmVuZGVyZXJzX2RlZmF1bHQgYXMgcmVuZGVyZXJzLFxuICByZXNvbHZlMiBhcyByZXNvbHZlLFxuICB0YWdzX2RlZmF1bHQgYXMgdGFncyxcbiAgdHJhbnNmb3JtMiBhcyB0cmFuc2Zvcm0sXG4gIHRyYW5zZm9ybWVyX2RlZmF1bHQgYXMgdHJhbnNmb3JtZXIsXG4gIHRyYW5zZm9ybXNfZGVmYXVsdCBhcyB0cmFuc2Zvcm1zLFxuICB0cnV0aHksXG4gIHZhbGlkYXRlMiBhcyB2YWxpZGF0ZSxcbiAgdmFsaWRhdGUgYXMgdmFsaWRhdG9yXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@markdoc/markdoc/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fperonif5%2FMyWorkspace%2FHeliumWorkspace%2Fmodular-governance%2Fpackages%2Fdocsite%2Fsrc%2Fpages%2Fdocs%2Fapi%2Ftoken-voter-sdk.md&page=%2Fdocs%2Fapi%2Ftoken-voter-sdk!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);